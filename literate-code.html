<!doctype html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script class="env" src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script>
<script class="env" src="//code.jquery.com/jquery-1.10.1.min.js"></script>
<script class="env" src="//d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js"></script>
<script class="env" src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.1/underscore-min.js"></script>
<script class="env" src="http://strd6.github.io/tempest/javascripts/envweb.js"></script>
</head><body><script>
  Function("ENV", "(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"actions\"] = function(data) {\n    return (function() {\n      var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"actions\");\n      actions = this.actions;\n      Object.keys(actions).each(function(name) {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, name.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return actions[name]();\n        });\n        return __pop();\n      });\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.issue_selector(this.issues));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"editor\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor\");\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"errors\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"console-wrap\");\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"errors\");\n      __each(this.errors, function(error) {\n        __element = document.createTextNode('');\n        __text(__element, error);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"notices\");\n      __each(this.notices, function(notice) {\n        __element = document.createTextNode('');\n        __text(__element, notice);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"filetree\"] = function(data) {\n    return (function() {\n      var files, selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"filetree\");\n      selectedFile = this.selectedFile;\n      files = this.files;\n      __each(files, function(file) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, file.displayName);\n        __push(__element);\n        __pop();\n        __on(\"click\", function(e) {\n          if ($(e.target).is('li')) {\n            return selectedFile(file);\n          }\n        });\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"delete\");\n        __on(\"click\", function() {\n          if (confirm(\"Delete \" + (file.path()) + \"?\")) {\n            return files.remove(file);\n          }\n        });\n        __element = document.createTextNode('');\n        __text(__element, \"X\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"gist_list\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"gists\");\n      __each(this.gists, function(gist) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, gist.id);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return alert(gist.id);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"github_status\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"status\");\n      if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n        __element = document.createTextNode('');\n        __text(__element, \"Authenticated Scopes:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n        __push(__element);\n        __pop();\n        __element = document.createElement(\"br\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \"Rate Limit Remaining:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \" / 5000\");\n        __push(__element);\n        __pop();\n      } else {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Auth\\n\");\n        __push(__element);\n        __pop();\n        __on(\"click\", Gistquire.auth);\n        __pop();\n      }\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"issue_selector\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"select\");\n      __push(__element);\n      __on(\"change\", this.currentIssue);\n      __element = document.createElement(\"option\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"- Default Branch -\");\n      __push(__element);\n      __pop();\n      __pop();\n      __each(this.issues, function() {\n        __element = document.createElement(\"option\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, this.optionText());\n        __push(__element);\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"main\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"main\");\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.actions({\n        actions: this.actions,\n        issues: this.issues\n      }));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.filetree(this.filetree));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.errors(this));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var commit, publish;\n\n  publish = function(_arg) {\n    var branch, builder, fileData, message, path, publishBranch, repository;\n    builder = _arg.builder, fileData = _arg.fileData, repository = _arg.repository;\n    branch = repository.branch();\n    message = \"Built \" + branch + \" in browser in strd6.github.io/tempest\";\n    if (branch === \"master\") {\n      path = \"index.html\";\n    } else {\n      path = \"\" + branch + \".html\";\n    }\n    publishBranch = \"gh-pages\";\n    return builder.build(fileData, function(build) {\n      return repository.writeFile({\n        path: path,\n        content: Base64.encode(builder.standAloneHtml(build)),\n        branch: publishBranch,\n        message: message\n      });\n    });\n  };\n\n  commit = function(_arg) {\n    var fileData, message, repository;\n    fileData = _arg.fileData, repository = _arg.repository, message = _arg.message;\n    return repository.commitTree({\n      tree: fileData,\n      message: message\n    });\n  };\n\n  this.Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    },\n    run: function(_arg) {\n      var builder, filetree;\n      builder = _arg.builder, filetree = _arg.filetree;\n      return builder.build(filetree.data(), function(build) {\n        var config, configData, sandbox, _base, _ref;\n        if (configData = (_ref = build.source[\"pixie.json\"]) != null ? _ref.content : void 0) {\n          config = JSON.parse(configData);\n        } else {\n          config = {};\n        }\n        sandbox = Sandbox({\n          width: config.width,\n          height: config.height\n        });\n        sandbox.document.open();\n        sandbox.document.write(builder.standAloneHtml(build));\n        sandbox.document.close();\n        return typeof (_base = builder.I).notices === \"function\" ? _base.notices([\"Running!\"]) : void 0;\n      });\n    },\n    load: function(_arg) {\n      var branch, filetree, processDirectory, repository;\n      filetree = _arg.filetree, repository = _arg.repository;\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      branch = repository.branch();\n      return repository.latestTree(branch).then(function(data) {\n        var deferred, treeFiles;\n        treeFiles = data.tree.select(function(file) {\n          return file.type === \"blob\";\n        });\n        async.map(treeFiles, function(datum, callback) {\n          return Gistquire.api(datum.url).then(function(data) {\n            return callback(null, Object.extend(datum, data));\n          }).fail(function(request, error, message) {\n            return callback(message);\n          });\n        }, function(error, results) {\n          var files;\n          if (error) {\n            deferred.reject(error);\n            return;\n          }\n          files = processDirectory(results);\n          filetree.load(files);\n          return deferred.resolve(treeFiles);\n        });\n        return deferred = $.Deferred();\n      });\n    }\n  };\n\n}).call(this);\n\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n;\n/**\n*\n*  Base64 encode / decode\n*  http://www.webtoolkit.info/\n*\n**/\n \nvar Base64 = {\n \n  // private property\n\t_keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n \n\t// public method for encoding\n\tencode : function (input) {\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = Base64._utf8_encode(input);\n \n\t\twhile (i < input.length) {\n \n\t\t\tchr1 = input.charCodeAt(i++);\n\t\t\tchr2 = input.charCodeAt(i++);\n\t\t\tchr3 = input.charCodeAt(i++);\n \n\t\t\tenc1 = chr1 >> 2;\n\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\tenc4 = chr3 & 63;\n \n\t\t\tif (isNaN(chr2)) {\n\t\t\t\tenc3 = enc4 = 64;\n\t\t\t} else if (isNaN(chr3)) {\n\t\t\t\tenc4 = 64;\n\t\t\t}\n \n\t\t\toutput = output +\n\t\t\tthis._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\n\t\t\tthis._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n \n\t\t}\n \n\t\treturn output;\n\t},\n \n\t// public method for decoding\n\tdecode : function (input) {\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3;\n\t\tvar enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n \n\t\twhile (i < input.length) {\n \n\t\t\tenc1 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc2 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc3 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc4 = this._keyStr.indexOf(input.charAt(i++));\n \n\t\t\tchr1 = (enc1 << 2) | (enc2 >> 4);\n\t\t\tchr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n\t\t\tchr3 = ((enc3 & 3) << 6) | enc4;\n \n\t\t\toutput = output + String.fromCharCode(chr1);\n \n\t\t\tif (enc3 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr2);\n\t\t\t}\n\t\t\tif (enc4 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr3);\n\t\t\t}\n \n\t\t}\n \n\t\toutput = Base64._utf8_decode(output);\n \n\t\treturn output;\n \n\t},\n \n\t// private method for UTF-8 encoding\n\t_utf8_encode : function (string) {\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\n\t\tvar utftext = \"\";\n \n\t\tfor (var n = 0; n < string.length; n++) {\n \n\t\t\tvar c = string.charCodeAt(n);\n \n\t\t\tif (c < 128) {\n\t\t\t\tutftext += String.fromCharCode(c);\n\t\t\t}\n\t\t\telse if((c > 127) && (c < 2048)) {\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n \n\t\t}\n \n\t\treturn utftext;\n\t},\n \n\t// private method for UTF-8 decoding\n\t_utf8_decode : function (utftext) {\n\t\tvar string = \"\";\n\t\tvar i = 0;\n\t\tvar c = c1 = c2 = 0;\n \n\t\twhile ( i < utftext.length ) {\n \n\t\t\tc = utftext.charCodeAt(i);\n \n\t\t\tif (c < 128) {\n\t\t\t\tstring += String.fromCharCode(c);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if((c > 191) && (c < 224)) {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tstring += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tc3 = utftext.charCodeAt(i+2);\n\t\t\t\tstring += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t\ti += 3;\n\t\t\t}\n \n\t\t}\n \n\t\treturn string;\n\t}\n \n}\n;;\n(function() {\n  var arrayToHash, compileFile, compileStyl, compileTemplate, stripMarkdown;\n\n  arrayToHash = function(array) {\n    return array.eachWithObject({}, function(file, hash) {\n      return hash[file.path] = file;\n    });\n  };\n\n  stripMarkdown = function(content) {\n    return content.split(\"\\n\").map(function(line) {\n      var match;\n      if (match = /^([ ]{4}|\\t)/.exec(line)) {\n        return line.slice(match[0].length);\n      } else {\n        return \"\";\n      }\n    }).join(\"\\n\");\n  };\n\n  compileTemplate = function(source, name) {\n    var ast;\n    if (name == null) {\n      name = \"test\";\n    }\n    ast = HAMLjr.parser.parse(source);\n    return HAMLjr.compile(ast, {\n      name: name,\n      compiler: CoffeeScript\n    });\n  };\n\n  compileStyl = function(source) {\n    return styl(source, {\n      whitespace: true\n    }).toString();\n  };\n\n  compileFile = function(_arg) {\n    var content, extension, name, path, result, _ref;\n    path = _arg.path, content = _arg.content;\n    _ref = [path.withoutExtension(), path.extension()], name = _ref[0], extension = _ref[1];\n    result = (function() {\n      switch (extension) {\n        case \"js\":\n          return {\n            code: content\n          };\n        case \"coffee\":\n          return {\n            code: CoffeeScript.compile(content)\n          };\n        case \"haml\":\n          return {\n            code: compileTemplate(content, name)\n          };\n        case \"styl\":\n          return {\n            style: compileStyl(content)\n          };\n        case \"md\":\n          return compileFile({\n            path: name,\n            content: stripMarkdown(content)\n          });\n        default:\n          return {};\n      }\n    })();\n    Object.defaults(result, {\n      name: name,\n      extension: extension\n    });\n    return Object.extend(result, {\n      path: path\n    });\n  };\n\n  this.Builder = function(I) {\n    var build, postProcessors;\n    if (I == null) {\n      I = {};\n    }\n    compileTemplate = function(source, name) {\n      var ast;\n      if (name == null) {\n        name = \"test\";\n      }\n      ast = HAMLjr.parser.parse(source);\n      return HAMLjr.compile(ast, {\n        name: name,\n        compiler: CoffeeScript\n      });\n    };\n    build = function(fileData) {\n      return fileData.map(function(_arg) {\n        var content, location, message, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          return compileFile({\n            path: path,\n            content: content\n          });\n        } catch (_error) {\n          location = _error.location, message = _error.message;\n          if (location != null) {\n            message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n          }\n          return {\n            error: \"\" + path + \" - \" + message\n          };\n        }\n      });\n    };\n    postProcessors = [];\n    return {\n      I: I,\n      addPostProcessor: function(fn) {\n        return postProcessors.push(fn);\n      },\n      build: function(fileData, callback) {\n        var builtItems, dist, distCode, distStyle, errors, results, _ref;\n        I.notices.push(\"Building...\");\n        _ref = build(fileData).partition(function(result) {\n          return result.error;\n        }), errors = _ref[0], builtItems = _ref[1];\n        if (errors.length) {\n          I.errors(errors);\n          return;\n        }\n        results = {\n          code: [],\n          style: [],\n          main: []\n        };\n        builtItems.eachWithObject(results, function(item, hash) {\n          var code, style;\n          if (code = item.code) {\n            if (item.name === \"main\" && (item.extension === \"js\" || item.extension === \"coffee\")) {\n              return hash.main.push(code);\n            } else {\n              return hash.code.push(code);\n            }\n          } else if (style = item.style) {\n            return hash.style.push(style);\n          } else {\n\n          }\n        });\n        distCode = results.code.concat(results.main).join(';').trim();\n        distStyle = results.style.join('').trim();\n        dist = [];\n        if (!distCode.blank()) {\n          dist.push({\n            path: \"build.js\",\n            content: distCode,\n            type: \"blob\"\n          });\n        }\n        if (!distStyle.blank()) {\n          dist.push({\n            path: \"style.css\",\n            content: distStyle,\n            type: \"blob\"\n          });\n        }\n        return callback(postProcessors.pipeline({\n          source: arrayToHash(fileData),\n          distribution: arrayToHash(dist)\n        }));\n      },\n      standAloneHtml: function(build) {\n        var content, distribution, entryPoint, program, source;\n        source = build.source, distribution = build.distribution;\n        content = [];\n        content.push(\"<!doctype html>\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        content = content.concat($('script.env').map(function() {\n          return this.outerHTML;\n        }).get());\n        entryPoint = \"build.js\";\n        program = distribution[entryPoint].content;\n        content.push(\"</head><body><script>\\n  Function(\\\"ENV\\\", \" + (JSON.stringify(program)) + \")(\" + (JSON.stringify(build)) + \");\\n<\\/script>\");\n        return content.join(\"\\n\");\n      }\n    };\n  };\n\n}).call(this);\n\n(function() {\n  var withDeferrence;\n\n  this.Deferred = $.Deferred;\n\n  withDeferrence = function(fn) {\n    var deferred, e;\n    deferred = Deferred();\n    try {\n      fn.defer(deferred);\n    } catch (_error) {\n      e = _error;\n      deferred.reject(e);\n    }\n    return deferred.promise();\n  };\n\n  Deferred.Confirm = function(message) {\n    return withDeferrence(function(deferred) {\n      if (window.confirm(message)) {\n        return deferred.resolve();\n      } else {\n        return deferred.reject();\n      }\n    });\n  };\n\n  Deferred.ConfirmIf = function(flag, message) {\n    if (flag) {\n      return Deferred.Confirm(message);\n    } else {\n      return withDeferrence(function(deferred) {\n        return deferred.resolve();\n      });\n    }\n  };\n\n  Deferred.ExecuteIf = function(flag, callback) {\n    return withDeferrence(function(deferred) {\n      if (flag) {\n        return callback().then(deferred.resolve);\n      } else {\n        return deferred.resolve();\n      }\n    });\n  };\n\n}).call(this);\n\n(function() {\n  String.prototype.dasherize = function() {\n    return this.trim().replace(/\\s+/g, \"-\").toLowerCase();\n  };\n\n}).call(this);\n\n(function() {\n  this.File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          case \"\":\n            return \"text\";\n          default:\n            return extension;\n        }\n      },\n      modified: Observable(false),\n      displayName: Observable(self.path())\n    });\n    self.content.observe(function() {\n      return self.modified(true);\n    });\n    self.modified.observe(function(modified) {\n      if (modified) {\n        return self.displayName(\"*\" + (self.path()));\n      } else {\n        return self.displayName(self.path());\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        if (Array.isArray(fileData)) {\n          files = fileData.sort(function(a, b) {\n            if (a.path < b.path) {\n              return -1;\n            } else if (b.path < a.path) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).map(File);\n        } else {\n          files = Object.keys(fileData).sort().map(function(name) {\n            return File(fileData[name]);\n          });\n        }\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.filename(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      },\n      hasUnsavedChanges: function() {\n        return self.files().select(function(file) {\n          return file.modified();\n        }).length;\n      },\n      markSaved: function() {\n        return self.files().each(function(file) {\n          return file.modified(false);\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    }\n  };\n\n}).call(this);\n\n(function() {\n  this.Issue = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    self = Model(I);\n    self.extend({\n      optionText: function() {\n        return \"\" + I.title;\n      },\n      fullDescription: function() {\n        return \"\" + (self.optionText()) + \"\\n\" + I.html_url + \"\\n\" + I.body;\n      },\n      branchName: function() {\n        var _ref;\n        return ((_ref = I.head) != null ? _ref.ref : void 0) || (\"issue-\" + I.number);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Issues = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      issues: []\n    });\n    self = Model(I);\n    self.attrModels(\"issues\");\n    self.attrObservable(\"currentIssue\");\n    self.extend({\n      reset: function(issueData) {\n        self.currentIssue(void 0);\n        return self.issues(issueData.map(Issue));\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Repository = function(I) {\n    var api, get, patch, post, put, requestOptions, self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      branch: \"master\",\n      defaultBranch: \"master\"\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"branch\");\n    requestOptions = function(type, data) {\n      return {\n        type: type,\n        data: JSON.stringify(data)\n      };\n    };\n    api = function(path, options) {\n      var url;\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"\" + (self.url()) + \"/\" + path;\n      }\n      return Gistquire.api(url, options);\n    };\n    get = function(path, data) {\n      return api(path, {\n        data: data\n      });\n    };\n    put = function(path, data) {\n      return api(path, requestOptions(\"PUT\", data));\n    };\n    post = function(path, data) {\n      return api(path, requestOptions(\"POST\", data));\n    };\n    patch = function(path, data) {\n      return api(path, requestOptions(\"PATCH\", data));\n    };\n    self.extend({\n      pullRequests: function() {\n        return get(\"pulls\");\n      },\n      createPullRequest: function(_arg) {\n        var head, title;\n        title = _arg.title;\n        head = title.dasherize();\n        return self.switchToBranch(head).then(self.commitEmpty).then(function() {\n          return post(\"pulls\", {\n            base: I.defaultBranch,\n            head: head,\n            title: title\n          });\n        });\n      },\n      initPagesBranch: function() {\n        var branch;\n        branch = \"gh-pages\";\n        return post(\"git/trees\", {\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/editor\"\n            }\n          ]\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            message: \"Initial gh-pages commit\",\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return post(\"git/refs\", {\n            ref: \"refs/heads/\" + branch,\n            sha: data.sha\n          });\n        });\n      },\n      writeFile: function(params) {\n        var branch, content, message, path;\n        branch = params.branch, path = params.path, content = params.content, message = params.message;\n        return get(\"contents/\" + path, {\n          ref: branch\n        }).then(function(data) {\n          return put(\"contents/\" + path, {\n            content: content,\n            sha: data.sha,\n            message: message,\n            branch: branch\n          });\n        }, function(request) {\n          var _ref, _ref1;\n          if (((_ref = request.responseJSON) != null ? _ref.message : void 0) === \"No commit found for the ref gh-pages\") {\n            return self.initPagesBranch().then(function() {\n              return self.writeFile(params);\n            });\n          } else if (request.status === 404) {\n            return put(\"contents/\" + path, {\n              content: content,\n              message: message,\n              branch: branch\n            });\n          } else {\n            return (_ref1 = Deferred()).reject.apply(_ref1, arguments);\n          }\n        });\n      },\n      latestTree: function(branch) {\n        if (branch == null) {\n          branch = \"master\";\n        }\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return get(\"\" + data.tree.url + \"?recursive=1\");\n        });\n      },\n      commitTree: function(_arg) {\n        var branch, latestCommitSha, message, tree;\n        message = _arg.message, tree = _arg.tree;\n        branch = self.branch();\n        if (message == null) {\n          message = \"Updated in browser at strd6.github.io/editor\";\n        }\n        if (!tree) {\n          throw Error(\"Must pass in a tree\");\n        }\n        latestCommitSha = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          latestCommitSha = data.object.sha;\n          return post(\"git/trees\", {\n            tree: tree\n          });\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [latestCommitSha],\n            message: message,\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      commitEmpty: function() {\n        var branch, latestCommit;\n        branch = self.branch();\n        latestCommit = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [data.sha],\n            message: \"This commit intentionally left blank\",\n            tree: data.tree.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      switchToBranch: function(branch) {\n        var ref, setBranch;\n        ref = \"refs/heads/\" + branch;\n        setBranch = function(data) {\n          self.branch(branch);\n          return data;\n        };\n        return get(\"git/\" + ref).then(setBranch, function(request) {\n          var branchNotFound, _ref;\n          branchNotFound = request.status === 404;\n          if (branchNotFound) {\n            return get(\"git/refs/heads/\" + (self.branch())).then(function(data) {\n              return post(\"git/refs\", {\n                ref: ref,\n                sha: data.object.sha\n              });\n            }).then(setBranch);\n          } else {\n            return (_ref = Deferred()).reject.apply(_ref, arguments);\n          }\n        });\n      },\n      mergeInto: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: branch,\n          head: self.branch()\n        });\n      },\n      pullFromBranch: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: self.branch(),\n          head: branch\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Sandbox = function(_arg) {\n    var height, methods, name, sandbox, width, _ref;\n    _ref = _arg != null ? _arg : {}, name = _ref.name, width = _ref.width, height = _ref.height, methods = _ref.methods;\n    if (name == null) {\n      name = \"sandbox\" + new Date;\n    }\n    if (width == null) {\n      width = 800;\n    }\n    if (height == null) {\n      height = 600;\n    }\n    if (methods == null) {\n      methods = {};\n    }\n    sandbox = window.open(\"\", name, \"width=\" + width + \",height=\" + height);\n    Object.extend(sandbox, methods);\n    return sandbox;\n  };\n\n}).call(this);\n\n(function() {\n  this.TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var $root, actions, branch, builder, classicError, confirmUnsaved, currentNode, distribution, errors, files, filetree, fullName, issues, notices, notify, owner, repo, repository, repositoryLoaded, styleContent, _ref, _ref1;\n\n  files = ENV.source, distribution = ENV.distribution;\n\n  window.ENV = ENV;\n\n  classicError = function(request) {\n    var message;\n    notices([]);\n    if (request.responseJSON) {\n      message = JSON.stringify(request.responseJSON, null, 2);\n    } else {\n      message = \"Error\";\n    }\n    return errors([message]);\n  };\n\n  notify = function(message) {\n    notices([message]);\n    return errors([]);\n  };\n\n  currentNode = function() {\n    var target;\n    target = document.documentElement;\n    while (target.childNodes.length && target.lastChild.nodeType === 1) {\n      target = target.lastChild;\n    }\n    return target.parentNode;\n  };\n\n  $root = $(currentNode());\n\n  if (styleContent = (_ref = distribution[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  Gistquire.onload();\n\n  _ref1 = ENV.repository, owner = _ref1.owner, repo = _ref1.repo, branch = _ref1.branch, fullName = _ref1.full_name;\n\n  fullName || (fullName = \"\" + owner + \"/\" + repo);\n\n  repository = Repository({\n    url: \"repos/\" + fullName\n  });\n\n  errors = Observable([]);\n\n  notices = Observable([\"Loaded!\"]);\n\n  builder = Builder({\n    errors: errors,\n    notices: notices\n  });\n\n  repositoryLoaded = function(repository) {\n    issues.repository = repository;\n    repository.pullRequests().then(issues.reset);\n    return notices([\"Finished loading!\"]);\n  };\n\n  confirmUnsaved = function() {\n    return Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\");\n  };\n\n  issues = Issues();\n\n  builder.addPostProcessor(function(data) {\n    data.repository = {\n      full_name: fullName,\n      branch: branch\n    };\n    return data;\n  });\n\n  builder.addPostProcessor(function(data) {\n    data.progenitor = {\n      url: \"http://strd6.github.io/editor/\"\n    };\n    return data;\n  });\n\n  actions = {\n    save: function() {\n      notices([\"Saving...\"]);\n      return Actions.save({\n        repository: repository,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        filetree.markSaved();\n        return notices([\"Saved and published!\"]);\n      });\n    },\n    run: function() {\n      return Actions.run({\n        builder: builder,\n        filetree: filetree\n      });\n    },\n    new_file: function() {\n      var name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        return filetree.files.push(File({\n          filename: name,\n          content: \"\"\n        }));\n      }\n    },\n    load_repo: function(skipPrompt) {\n      return confirmUnsaved().then(function() {\n        if (!skipPrompt) {\n          fullName = prompt(\"Github repo\", fullName);\n        }\n        if (fullName) {\n          repository = Repository({\n            url: \"repos/\" + fullName\n          });\n        } else {\n          errors([\"No repo given\"]);\n          return;\n        }\n        notices([\"Loading repo...\"]);\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return repositoryLoaded(repository);\n        }).fail(function() {\n          return errors([\"Error loading \" + (repository.url())]);\n        });\n      });\n    },\n    new_feature: function() {\n      var title;\n      if (title = prompt(\"Description\")) {\n        notices([\"Creating feature branch...\"]);\n        return repository.createPullRequest({\n          title: title\n        }).then(function(data) {\n          var issue;\n          issue = Issue(data);\n          issues.issues.push(issue);\n          issues.silent = true;\n          issues.currentIssue(issue);\n          issues.silent = false;\n          return notices.push(\"Created!\");\n        }, classicError);\n      }\n    },\n    pull_master: function() {\n      return confirmUnsaved().then(function() {\n        notify(\"Merging in default branch...\");\n        return repository.pullFromBranch();\n      }, classicError).then(function() {\n        var branchName;\n        notices.push(\"Merged!\");\n        branchName = repository.branch();\n        notices.push(\"\\nReloading branch \" + branchName + \"...\");\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return notices.push(\"Loaded!\");\n        });\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.templates.editor());\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        return file.content(value);\n      });\n    }\n  });\n\n  repositoryLoaded(repository);\n\n  issues.currentIssue.observe(function(issue) {\n    var changeBranch;\n    if (issues.silent) {\n      return;\n    }\n    changeBranch = function(branchName) {\n      var previousBranch;\n      previousBranch = repository.branch();\n      return confirmUnsaved().then(function() {\n        return repository.switchToBranch(branchName).then(function() {\n          notices.push(\"\\nLoading branch \" + branchName + \"...\");\n          return Actions.load({\n            repository: repository,\n            filetree: filetree\n          }).then(function() {\n            return notices.push(\"Loaded!\");\n          });\n        });\n      }, function() {\n        repository.branch(previousBranch);\n        return errors([\"Error switching to \" + branchName + \", still on \" + previousBranch]);\n      });\n    };\n    if (issue) {\n      notify(issue.fullDescription());\n      return changeBranch(issue.branchName());\n    } else {\n      notify(\"Default branch selected\");\n      return changeBranch(repository.defaultBranch());\n    }\n  });\n\n  $root.append(HAMLjr.templates.main({\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors,\n    issues: issues\n  }));\n\n  Gistquire.api(\"rate_limit\", {\n    complete: function(request, status) {\n      return $root.append(HAMLjr.templates.github_status({\n        request: request\n      }));\n    }\n  });\n\n  window.onbeforeunload = function() {\n    if (filetree.hasUnsavedChanges()) {\n      return \"You have some unsaved changes, if you leave now you will lose your work.\";\n    }\n  };\n\n}).call(this);\n")({"source":{"TODO":{"path":"TODO","mode":"100644","content":"TODO\n----\nLiterate Code\n\nGenerate Docs\n\nPublish build js files separate from HTML housing\n- Builds should be named <sha>.js and live in gh-pages\n- HTML should contain the Tempest environment\n- HTML should link to the <sha>.js for the branch it was built in\n\nDependencies\n- Dependencies should live in other git repos\n- Should be able to edit dependencies in a new editor easily\n- Track sha and version requirements\n- Build dependencies into published script\n- Dependencies shouldn't be in source\n- Dependency metadata should appear in publish script\n- Should dependency source files appear in publish metadata?\n- Allow remote and bundled dependencies?\n\nLive Update Demo\n- Display Demo Runtime Errors in console\n\nOpen published page in editor and run live demo with same state as when editor was opened\n- Pass git repo/branch metadata to published page for use in editor\n\nPersist state across demo reloads\n\nOrganize File tree by type\nFile icons\n\n.haml and .styl file type support\n- Build our own ace cdn\n\nTests\n\nDisplay Diffs\n\nFirst auth doesn't display in bar\n\nCache Git trees and files in some form of local storage\n\nSometimes editor appears blank when switching files\n\nEditor plugins\n- static analysis\n- find in files\n\nDONE\n----\nIntegrate with Github Issues\n- Select active issue\n- Display issue text in console\n- Create issues from editor\n- Auto-create branch for issue\n- Commit/deploy to branch for issue\n\nGistquire promises refactor\n\nRepository Object to encapsulate repo/branch and make creating/loading trees and issues easier\n\nCompile Error file and line number in error messages\n\nSaving UTF8 Characters gets messed up\n\nDelete Files\n\nAuth redirects to /tempest rather than /editor\n\nCombine commit/publish step\n- master branch should publish to index.html\n- other branches should publish to <branch>.html\n- Published branch is always latest\n\nDon't pass directories to filetree\n\nSaving repos with folders\n\nLoad file data better\n- Handle folders in repos\n\nHandle file types per extension\n\nSave back to repo from gh-pages demo build\n\nUse editor repo as the default rather than the gist\n- Boot from built gh-pages html files.\n\nDeploy a packaged app to gh-pages\n- html page named for branch/sha and with source included\n\nLoad from actual git repos\nSave changes back to real git repos\n\nVisualize Rate Limit Remaining\n\nMake errors like notices\nDisplay Auth Scopes\nDo not compile build.js if no js files\n\nMove Gistquire to editor\nMaintain editor state across open files\nError Log styles\nTell ace not to use worker becaues it fails to load cross domain","type":"blob"},"actions.coffee":{"path":"actions.coffee","mode":"100644","content":"publish = ({builder, fileData, repository}) ->\n  branch = repository.branch()\n  message = \"Built #{branch} in browser in strd6.github.io/tempest\"\n\n  if branch is \"master\"\n    path = \"index.html\"\n  else\n    path = \"#{branch}.html\"\n\n  # Assuming git repo with gh-pages branch\n  publishBranch = \"gh-pages\"\n  \n  builder.build fileData, (build) ->\n    # create <ref>.html in gh-pages branch\n    repository.writeFile\n      path: path\n      content: Base64.encode(builder.standAloneHtml(build))\n      branch: publishBranch\n      message: message\n\ncommit = ({fileData, repository, message}) ->\n  repository.commitTree\n    tree: fileData\n    message: message\n\n@Actions =\n  save: (params) ->\n    commit(params)\n      .then ->\n        publish(params)\n\n  run: ({builder, filetree}) ->\n    builder.build filetree.data(), (build) ->\n      if configData = build.source[\"pixie.json\"]?.content\n        config = JSON.parse(configData)\n      else\n        config = {}\n      \n      sandbox = Sandbox\n        width: config.width\n        height: config.height\n      \n      sandbox.document.open()\n      sandbox.document.write(builder.standAloneHtml(build))\n\n      sandbox.document.close()\n\n      builder.I.notices? [\"Running!\"]\n      # TODO: Catch and display runtime errors\n\n  load: ({filetree, repository}) ->\n    # Decode all content in place\n    processDirectory = (items) ->\n      items.each (item) ->\n        return item unless item.content\n\n        item.content = Base64.decode(item.content)\n        item.encoding = \"raw\"\n\n    branch = repository.branch()\n\n    repository.latestTree(branch)\n    .then (data) ->\n\n      treeFiles = data.tree.select (file) ->\n        file.type is \"blob\"\n\n      # Gather the data for each file\n      async.map treeFiles, (datum, callback) ->\n        Gistquire.api(datum.url)\n        .then (data) ->\n          callback(null, Object.extend(datum, data))\n        .fail (request, error, message) ->\n          callback(message)\n\n      , (error, results) ->\n        if error\n          deferred.reject(error)\n\n          return\n\n        files = processDirectory results\n        filetree.load files\n\n        deferred.resolve(treeFiles)\n\n      deferred = $.Deferred()\n","type":"blob"},"actions.haml":{"path":"actions.haml","mode":"100644","content":".actions\n  - actions = @actions\n  - Object.keys(actions).each (name) ->\n    %button\n      = name.titleize()\n      - on \"click\", ->\n        - actions[name]()\n\n  = HAMLjr.templates.issue_selector @issues\n","type":"blob"},"async.js":{"path":"async.js","mode":"100644","content":"/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","type":"blob"},"base64.js":{"path":"base64.js","mode":"100644","content":"/**\n*\n*  Base64 encode / decode\n*  http://www.webtoolkit.info/\n*\n**/\n \nvar Base64 = {\n \n  // private property\n\t_keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n \n\t// public method for encoding\n\tencode : function (input) {\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = Base64._utf8_encode(input);\n \n\t\twhile (i < input.length) {\n \n\t\t\tchr1 = input.charCodeAt(i++);\n\t\t\tchr2 = input.charCodeAt(i++);\n\t\t\tchr3 = input.charCodeAt(i++);\n \n\t\t\tenc1 = chr1 >> 2;\n\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\tenc4 = chr3 & 63;\n \n\t\t\tif (isNaN(chr2)) {\n\t\t\t\tenc3 = enc4 = 64;\n\t\t\t} else if (isNaN(chr3)) {\n\t\t\t\tenc4 = 64;\n\t\t\t}\n \n\t\t\toutput = output +\n\t\t\tthis._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\n\t\t\tthis._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n \n\t\t}\n \n\t\treturn output;\n\t},\n \n\t// public method for decoding\n\tdecode : function (input) {\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3;\n\t\tvar enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n \n\t\twhile (i < input.length) {\n \n\t\t\tenc1 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc2 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc3 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc4 = this._keyStr.indexOf(input.charAt(i++));\n \n\t\t\tchr1 = (enc1 << 2) | (enc2 >> 4);\n\t\t\tchr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n\t\t\tchr3 = ((enc3 & 3) << 6) | enc4;\n \n\t\t\toutput = output + String.fromCharCode(chr1);\n \n\t\t\tif (enc3 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr2);\n\t\t\t}\n\t\t\tif (enc4 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr3);\n\t\t\t}\n \n\t\t}\n \n\t\toutput = Base64._utf8_decode(output);\n \n\t\treturn output;\n \n\t},\n \n\t// private method for UTF-8 encoding\n\t_utf8_encode : function (string) {\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\n\t\tvar utftext = \"\";\n \n\t\tfor (var n = 0; n < string.length; n++) {\n \n\t\t\tvar c = string.charCodeAt(n);\n \n\t\t\tif (c < 128) {\n\t\t\t\tutftext += String.fromCharCode(c);\n\t\t\t}\n\t\t\telse if((c > 127) && (c < 2048)) {\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n \n\t\t}\n \n\t\treturn utftext;\n\t},\n \n\t// private method for UTF-8 decoding\n\t_utf8_decode : function (utftext) {\n\t\tvar string = \"\";\n\t\tvar i = 0;\n\t\tvar c = c1 = c2 = 0;\n \n\t\twhile ( i < utftext.length ) {\n \n\t\t\tc = utftext.charCodeAt(i);\n \n\t\t\tif (c < 128) {\n\t\t\t\tstring += String.fromCharCode(c);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if((c > 191) && (c < 224)) {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tstring += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tc3 = utftext.charCodeAt(i+2);\n\t\t\t\tstring += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t\ti += 3;\n\t\t\t}\n \n\t\t}\n \n\t\treturn string;\n\t}\n \n}\n;","type":"blob"},"builder.coffee":{"path":"builder.coffee","mode":"100644","content":"arrayToHash = (array) ->\n  array.eachWithObject {}, (file, hash) ->\n    hash[file.path] = file\n\nstripMarkdown = (content) ->\n  content.split(\"\\n\").map (line) ->\n    if match = (/^([ ]{4}|\\t)/).exec line\n      line[match[0].length..]\n    else\n      \"\"\n  .join(\"\\n\")\n\ncompileTemplate = (source, name=\"test\") ->\n  ast = HAMLjr.parser.parse(source)\n  \n  HAMLjr.compile ast, \n    name: name\n    compiler: CoffeeScript\n    \ncompileStyl = (source) ->\n  styl(source, whitespace: true).toString()\n\ncompileFile = ({path, content}) ->\n  [name, extension] = [path.withoutExtension(), path.extension()]\n  \n  result =\n    switch extension\n      when \"js\"\n        code: content\n      when \"coffee\"\n        code: CoffeeScript.compile(content)\n      when \"haml\"\n        code: compileTemplate(content, name)\n      when \"styl\"\n        style: compileStyl(content)\n      when \"md\"\n        # Separate out code and call compile again\n        compileFile\n          path: name\n          content: stripMarkdown(content)\n      else\n        {}\n\n  Object.defaults result,\n    name: name\n    extension: extension\n\n  Object.extend result,\n    path: path\n\n@Builder = (I={}) ->\n  compileTemplate = (source, name=\"test\") ->\n    ast = HAMLjr.parser.parse(source)\n    \n    HAMLjr.compile ast, \n      name: name\n      compiler: CoffeeScript\n  \n  build = (fileData) ->    \n    fileData.map ({path, content}) ->\n      try\n        # TODO: Separate out tests\n\n        compileFile\n          path: path\n          content: content\n      catch {location, message}\n        if location?\n          message = \"Error on line #{location.first_line + 1}: #{message}\"\n\n        error: \"#{path} - #{message}\"\n\n  postProcessors = []\n\n  I: I\n  \n  addPostProcessor: (fn) ->\n    postProcessors.push fn\n\n  build: (fileData, callback) ->\n    I.notices.push \"Building...\"\n\n    [errors, builtItems] = build(fileData).partition (result) ->\n      result.error\n\n    if errors.length\n      I.errors errors\n\n      return\n\n    results =\n      code: []\n      style: []\n      main: []\n\n    builtItems.eachWithObject results, (item, hash) ->\n      if code = item.code\n        if item.name is \"main\" and (item.extension is \"js\" or item.extension is \"coffee\")\n          hash.main.push code\n        else\n          hash.code.push code\n      else if style = item.style\n        hash.style.push style\n      else\n        # Do nothing, we don't know about this item\n    \n    distCode = results.code.concat(results.main).join(';').trim()\n    distStyle = results.style.join('').trim()\n\n    dist = []\n\n    unless distCode.blank()\n      dist.push\n        path: \"build.js\"\n        content: distCode\n        type: \"blob\"\n\n    unless distStyle.blank()\n      dist.push\n        path: \"style.css\"\n        content: distStyle\n        type: \"blob\"\n\n    callback postProcessors.pipeline\n      source: arrayToHash(fileData)\n      distribution: arrayToHash(dist)\n\n  standAloneHtml: (build) ->\n    {source, distribution} = build\n    \n    content = []\n\n    content.push \"\"\"\n      <!doctype html>\n      <head>\n      <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    \"\"\"\n\n    # TODO: Get these from a more robust method than just script tags with classes\n    content = content.concat $('script.env').map ->\n      @outerHTML\n    .get()\n  \n    entryPoint = \"build.js\"\n    program = distribution[entryPoint].content\n  \n    # TODO: Think about nesting, components\n    # TODO?: Exclude build.js from files\n    content.push \"\"\"</head><body><script>\n      Function(\"ENV\", #{JSON.stringify(program)})(#{JSON.stringify(build)});\n    <\\/script>\"\"\"\n    \n    content.join \"\\n\"\n","type":"blob"},"deferred.coffee":{"path":"deferred.coffee","mode":"100644","content":"# Use jQuery.Deferred to implement deferreds, but\n# stay insulated by not blasting the $ all over our code\n# that doesn't really depend on jQuery\n# This let's us swap our our Deferred provider more easily later.\n@Deferred = $.Deferred\n\nwithDeferrence = (fn) ->\n  deferred = Deferred()\n\n  # TODO: This try catch may be useless from deferring the fn\n  try\n    fn.defer(deferred)\n  catch e\n    deferred.reject(e)\n\n  return deferred.promise()\n\nDeferred.Confirm = (message) ->\n  withDeferrence (deferred) ->\n    if window.confirm(message)\n      deferred.resolve()\n    else\n      deferred.reject()\n\nDeferred.ConfirmIf = (flag, message) ->\n  if flag\n    return Deferred.Confirm(message)\n  else\n    withDeferrence (deferred) ->\n      deferred.resolve()\n\nDeferred.ExecuteIf = (flag, callback) ->\n  withDeferrence (deferred) ->\n    if flag\n      callback().then deferred.resolve\n    else\n      deferred.resolve()\n","type":"blob"},"duct_tape.coffee":{"path":"duct_tape.coffee","mode":"100644","content":"String::dasherize = ->\n  @trim()\n    .replace(/\\s+/g, \"-\")\n    .toLowerCase()\n","type":"blob"},"editor.haml":{"path":"editor.haml","mode":"100644","content":".editor-wrap\n  .editor\n","type":"blob"},"errors.haml":{"path":"errors.haml","mode":"100644","content":".console-wrap\n  %pre.errors\n    - each @errors, (error) ->\n      = error\n  %pre.notices\n    - each @notices, (notice) ->\n      = notice\n","type":"blob"},"file.coffee":{"path":"file.coffee","mode":"100644","content":"@File = (I={}) ->\n  I.path ?= I.filename\n  I.filename ?= I.path.split(\"/\").last()\n\n  self = Model(I).observeAll()\n\n  self.extend\n    extension: ->\n      self.filename().extension()\n\n    mode: ->\n      switch extension = self.extension()\n        when \"js\"\n          \"javascript\"\n        when \"\"\n          \"text\"\n        else\n          extension\n\n    modified: Observable(false)\n\n    displayName: Observable(self.path())\n\n  self.content.observe ->\n    self.modified(true)\n    \n  self.modified.observe (modified) ->\n    if modified\n      self.displayName(\"*#{self.path()}\")\n    else\n      self.displayName(self.path())\n\n  return self\n","type":"blob"},"filetree.coffee":{"path":"filetree.coffee","mode":"100644","content":"@Filetree = (I={}) ->\n  Object.defaults I,\n    files: []\n\n  self = Model(I).observeAll()\n\n  self.attrObservable \"selectedFile\"\n\n  self.extend\n    # Load files either from an array of file data objects\n    # or from an object with filenames as keys and file data objects as values\n    load: (fileData) ->\n      if Array.isArray(fileData)\n        files = fileData.sort (a, b) ->\n          if a.path < b.path\n            -1\n          else if b.path < a.path\n            1\n          else\n            0\n        .map File\n\n      else\n        files = Object.keys(fileData).sort().map (name) ->\n          File fileData[name]\n\n      self.files(files)\n\n    data: ->\n      self.files.map (file) ->\n        path: file.filename()\n        mode: \"100644\"\n        content: file.content()\n        type: \"blob\"\n\n    hasUnsavedChanges: ->\n      self.files().select (file) ->\n        file.modified()\n      .length\n\n    # TODO: Use git trees and content shas to robustly manage changed state\n    markSaved: ->\n      self.files().each (file) ->\n        file.modified(false)\n\n  return self\n","type":"blob"},"filetree.haml":{"path":"filetree.haml","mode":"100644","content":"%ul.filetree\n  - selectedFile = @selectedFile\n  - files = @files\n  - each files, (file) ->\n    %li= file.displayName\n      - on \"click\", (e) -> \n        - selectedFile(file) if $(e.target).is('li')\n      .delete\n        - on \"click\", -> files.remove(file) if confirm(\"Delete #{file.path()}?\")\n        X\n","type":"blob"},"gist_list.haml":{"path":"gist_list.haml","mode":"100644","content":"%ul.gists\n  - each @gists, (gist) ->\n    %li= gist.id\n      - on \"click\", ->\n        - alert gist.id\n","type":"blob"},"gistquire.coffee":{"path":"gistquire.coffee","mode":"100644","content":"@Gistquire =\n  accessToken: null\n\n  # Calling auth will redirect to github for authentication\n  auth: ->\n    scope = \"gist,repo,user:email\"\n    url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=#{scope}\"\n\n    window.location = url\n\n  # Call onload to check for the code returned from github authentication\n  # and to get our access token from our authorization app.\n  onload: ->\n    # TODO: Namespace local storage key\n\n    if code = window.location.href.match(/\\?code=(.*)/)?[1]\n      $.getJSON \"https://hamljr-auth.herokuapp.com/authenticate/#{code}\", (data) =>\n        if token = data.token\n          @accessToken = token\n          localStorage.authToken = token\n\n    if localStorage.authToken\n      @accessToken = localStorage.authToken\n\n  api: (path, options={}) ->\n    if path.match /^http/\n      url = path\n    else\n      url = \"https://api.github.com/#{path}\"\n    \n    options.headers ||= {}\n    \n    if @accessToken\n      options.headers[\"Authorization\"] = \"token #{@accessToken}\"\n\n    options = Object.extend\n      url: url\n      type: \"GET\"\n      dataType: 'json'\n    , options\n\n    $.ajax options\n","type":"blob"},"github_status.haml":{"path":"github_status.haml","mode":"100644","content":".status\n  - if @request and @request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)\n    Authenticated Scopes:\n    = @request.getResponseHeader(\"X-OAuth-Scopes\")\n    %br\n    Rate Limit Remaining:\n    = @request.getResponseHeader(\"X-RateLimit-Remaining\")\n    = \" / 5000\"\n  - else\n    %button Auth\n      - on \"click\", Gistquire.auth\n","type":"blob"},"issue.coffee":{"path":"issue.coffee","mode":"100644","content":"# TODO: These should mainly only be pull requests, but may have to be compatible\n# with issues created outside the system.\n@Issue = (I={}) ->\n  self = Model(I)\n\n  self.extend\n    optionText: ->\n      \"#{I.title}\"\n\n    fullDescription: ->\n      \"\"\"\n        #{self.optionText()}\n        #{I.html_url}\n        #{I.body}\n      \"\"\"\n\n    branchName: ->\n      I.head?.ref or \"issue-#{I.number}\"\n\n  return self\n","type":"blob"},"issue_selector.haml":{"path":"issue_selector.haml","mode":"100644","content":"%select\n  - on \"change\", @currentIssue\n  %option= \"- Default Branch -\"\n  - each @issues, ->\n    %option= @optionText()\n","type":"blob"},"issues.coffee":{"path":"issues.coffee","mode":"100644","content":"@Issues = (I={}) ->\n  Object.defaults I,\n    issues: []\n\n  self = Model(I)\n\n  self.attrModels \"issues\"\n  self.attrObservable \"currentIssue\"\n\n  self.extend\n    reset: (issueData) ->\n      self.currentIssue(undefined)\n      self.issues issueData.map(Issue)\n\n  return self\n","type":"blob"},"main.coffee":{"path":"main.coffee","mode":"100644","content":"# Get stuff from our env\n{source:files, distribution} = ENV\n\n# For debugging\nwindow.ENV = ENV\n\n# TODO: Move notifications stuff into its own class\nclassicError = (request) ->\n  notices []\n  \n  if request.responseJSON\n    message = JSON.stringify(request.responseJSON, null, 2)\n  else\n    message = \"Error\"\n\n  errors [message]\n\nnotify = (message) ->\n  notices [message]\n  errors []\n\n# TODO: Move to env utils\ncurrentNode = ->\n  target = document.documentElement\n\n  while (target.childNodes.length and target.lastChild.nodeType == 1)\n    target = target.lastChild\n\n  return target.parentNode\n\n# The root is the node that contains the script file.\n$root = $(currentNode())\n\n# Apply our styles\nif styleContent = distribution[\"style.css\"]?.content\n  $root.append $(\"<style>\",\n    html: styleContent\n  )\n\n# Init Github access token stuff\nGistquire.onload()\n  \n# TODO: Real branch and repo info, maybe from ENV\n{owner, repo, branch, full_name:fullName} = ENV.repository\n\nfullName ||= \"#{owner}/#{repo}\"\n\nrepository = Repository\n  url: \"repos/#{fullName}\"\n\nerrors = Observable([])\nnotices = Observable([\"Loaded!\"])\n\nbuilder = Builder\n  errors: errors\n  notices: notices\n\nrepositoryLoaded = (repository) ->\n  issues.repository = repository\n  repository.pullRequests().then issues.reset\n  \n  notices [\"Finished loading!\"]\n  \nconfirmUnsaved = ->\n  Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\")\n\nissues = Issues()\n\n# Repo metadata for env\nbuilder.addPostProcessor (data) ->\n  # TODO: Track commit SHA as well\n  data.repository =\n    full_name: fullName\n    branch: branch\n\n  data\n\nbuilder.addPostProcessor (data) ->\n  # TODO: Think about a robust way to get 'self' and set it as progenitor data\n  data.progenitor =\n    url: \"http://strd6.github.io/editor/\"\n\n  data\n\nactions =\n  save: ->\n    notices [\"Saving...\"]\n    \n    Actions.save\n      repository: repository\n      fileData: filetree.data()\n      builder: builder\n    .then ->\n      # TODO: This could get slightly out of sync if there were changes\n      # during the async call\n      # The correct solution will be to use git shas to determine changed status\n      # but that's a little heavy duty for right now.\n      filetree.markSaved()\n      notices [\"Saved and published!\"]\n\n  run: ->\n    Actions.run({builder, filetree})\n\n  new_file: ->\n    if name = prompt(\"File Name\", \"newfile.coffee\")\n      filetree.files.push File\n        filename: name\n        content: \"\"\n\n  load_repo: (skipPrompt) ->\n    confirmUnsaved()\n    .then ->\n      fullName = prompt(\"Github repo\", fullName) unless skipPrompt\n\n      if fullName\n        repository = Repository\n          url: \"repos/#{fullName}\"\n      else\n        errors [\"No repo given\"]\n  \n        return\n  \n      notices [\"Loading repo...\"]\n  \n      Actions.load\n        repository: repository\n        filetree: filetree\n      .then ->\n        repositoryLoaded(repository)\n      .fail ->\n        errors [\"Error loading #{repository.url()}\"]\n        \n  new_feature: ->\n    if title = prompt(\"Description\")\n      notices [\"Creating feature branch...\"]\n    \n      repository.createPullRequest\n        title: title\n      .then (data) ->\n        issue = Issue(data)\n        issues.issues.push issue\n\n        # TODO: Standardize this like backbone or something\n        # or think about using deferreds in some crazy way\n        issues.silent = true\n        issues.currentIssue issue\n        issues.silent = false\n\n        notices.push \"Created!\"\n      , classicError\n      \n  pull_master: ->\n    confirmUnsaved()\n    .then( ->\n      notify \"Merging in default branch...\"\n      repository.pullFromBranch()\n    , classicError\n    ).then ->\n      notices.push \"Merged!\"\n      \n      branchName = repository.branch()\n      notices.push \"\\nReloading branch #{branchName}...\"\n        \n      Actions.load\n        repository: repository\n        filetree: filetree\n      .then ->\n        notices.push \"Loaded!\"\n\nfiletree = Filetree()\nfiletree.load(files)\n\nfiletree.selectedFile.observe (file) ->\n  root = $root.children(\".main\")\n  root.find(\".editor-wrap\").hide()\n  \n  if file.editor\n    file.editor.trigger(\"show\")\n  else\n    root.append(HAMLjr.templates.editor())\n    file.editor = root.find(\".editor-wrap\").last()\n    \n    editor = TextEditor\n      text: file.content()\n      el: file.editor.find('.editor').get(0)\n      mode: file.mode()\n\n    file.editor.on \"show\", ->\n      file.editor.show()\n      editor.editor.focus()\n  \n    editor.text.observe (value) ->\n      file.content(value)\n      \n      # Autorun\n      # actions.run()\n\nrepositoryLoaded(repository)\n\nissues.currentIssue.observe (issue) ->\n  # TODO: Formalize this later\n  return if issues.silent\n  \n  changeBranch = (branchName) ->\n    previousBranch = repository.branch()\n\n    confirmUnsaved()\n    .then ->\n      # Switch to branch for working on the issue\n      repository.switchToBranch(branchName)\n      .then ->\n        notices.push \"\\nLoading branch #{branchName}...\"\n        \n        Actions.load\n          repository: repository\n          filetree: filetree\n        .then ->\n          notices.push \"Loaded!\"\n    , ->\n      # TODO: Issue will appear as being selected even though we cancelled\n      # To correctly handle this we may need to really beef up our observables.\n      # One possibility is to extend observables to full fledged deferreds\n      # which can be rejected by listeners added to the chain.\n      \n      repository.branch(previousBranch)\n\n      errors [\"Error switching to #{branchName}, still on #{previousBranch}\"]\n\n  if issue\n    notify issue.fullDescription()\n    \n    changeBranch issue.branchName()\n  else    \n    notify \"Default branch selected\"\n    \n    changeBranch repository.defaultBranch()\n\n$root\n  .append(HAMLjr.templates.main(\n    filetree: filetree\n    actions: actions\n    notices: notices\n    errors: errors\n    issues: issues\n  ))\n\nGistquire.api \"rate_limit\", \n  complete: (request, status) ->\n    $root.append HAMLjr.templates.github_status\n      request: request\n\nwindow.onbeforeunload = ->\n  if filetree.hasUnsavedChanges()\n    \"You have some unsaved changes, if you leave now you will lose your work.\"\n","type":"blob"},"main.haml":{"path":"main.haml","mode":"100644","content":".main\n  = HAMLjr.templates.actions actions: @actions, issues: @issues\n  = HAMLjr.templates.filetree @filetree\n  = HAMLjr.templates.errors this\n","type":"blob"},"pixie.json":{"path":"pixie.json","mode":"100644","content":"{\n  \"width\": 960,\n  \"height\": 800\n}\n","type":"blob"},"repository.coffee":{"path":"repository.coffee","mode":"100644","content":"@Repository = (I={}) ->\n  Object.defaults I,\n    branch: \"master\"\n    defaultBranch: \"master\"\n\n  self = Model(I).observeAll()\n  \n  # The currently active branch in the working copy\n  self.attrObservable \"branch\"\n  \n  # TODO: Extract all of these methods to an API generator\n  requestOptions = (type, data) ->\n    type: type\n    data: JSON.stringify(data)\n\n  api = (path, options) ->\n    if path.match /^http/\n      url = path\n    else\n      url = \"#{self.url()}/#{path}\"\n          \n    Gistquire.api url, options\n\n  get = (path, data) ->\n    api path, data: data\n\n  put = (path, data) ->\n    api(path, requestOptions(\"PUT\", data))\n    \n  post = (path, data) ->\n    api(path, requestOptions(\"POST\", data))\n    \n  patch = (path, data) ->\n    api path, requestOptions(\"PATCH\", data)\n\n  self.extend\n    pullRequests: ->\n      get \"pulls\"\n\n    createPullRequest: ({title}) ->\n      head = title.dasherize()\n\n      self.switchToBranch(head)\n      .then(self.commitEmpty)\n      .then ->\n        post \"pulls\",\n          base: I.defaultBranch\n          head: head\n          title: title\n\n    initPagesBranch: ->\n      branch = \"gh-pages\"\n    \n      # Post an empty tree to use for the base commit\n      # TODO: Learn how to post an empty tree\n      post \"git/trees\",\n        tree: [{\n          mode: \"1006444\"\n          path: \"tempest.txt\"\n          content: \"created by strd6.github.io/editor\"\n        }]\n      .then (data) ->\n        # Create the base commit for the branch\n        post \"git/commits\",\n          message: \"Initial gh-pages commit\"\n          tree: data.sha\n      .then (data) ->\n        # Create the branch based on the base commit\n        post \"git/refs\",\n          ref: \"refs/heads/#{branch}\"\n          sha: data.sha\n      \n    writeFile: (params) ->\n      {branch, path, content, message} = params\n\n      get \"contents/#{path}\",\n        ref: branch\n      .then (data) ->\n        # The file existed, so we update it using the existing sha\n        put \"contents/#{path}\",\n          content: content\n          sha: data.sha\n          message: message\n          branch: branch\n      , (request) ->\n        # If we fail because the gh-pages branch doesn't exist try creating it and retrying\n        if request.responseJSON?.message is \"No commit found for the ref gh-pages\"\n          self.initPagesBranch().then ->\n            # Trying again after creating the gh-pages branch\n            self.writeFile(params)\n        # The file didn't exist so we create a new one\n        else if request.status is 404\n          put \"contents/#{path}\",\n            content: content\n            message: message\n            branch: branch\n        else\n          Deferred().reject(arguments...)\n\n    latestTree: (branch=\"master\") ->\n      get(\"git/refs/heads/#{branch}\")\n      .then (data) ->\n        get data.object.url\n      .then (data) ->\n        get \"#{data.tree.url}?recursive=1\"\n\n    commitTree: ({message, tree}) ->\n      branch = self.branch()\n      message ?= \"Updated in browser at strd6.github.io/editor\"\n      \n      unless tree\n        throw Error(\"Must pass in a tree\")\n        \n      # TODO: Is there a cleaner way to pass this through promises?\n      latestCommitSha = null\n\n      get(\"git/refs/heads/#{branch}\")\n      .then (data) ->\n        latestCommitSha = data.object.sha\n        \n        post \"git/trees\",\n          tree: tree\n      .then (data) ->\n        # Create another commit\n        post \"git/commits\",\n          parents: [latestCommitSha]\n          message: message\n          tree: data.sha\n      .then (data) ->\n        # Update the branch head\n        patch \"git/refs/heads/#{branch}\",\n          sha: data.sha\n    \n    # TODO: this is currently a hack because we can't create a pull request\n    # if there are no different commits\n    commitEmpty: ->\n      branch = self.branch()\n      latestCommit = null\n      \n      get(\"git/refs/heads/#{branch}\")\n      .then (data) ->\n        get data.object.url\n      .then (data) ->\n        # Create another commit\n        post \"git/commits\",\n          parents: [data.sha]\n          message: \"This commit intentionally left blank\"\n          tree: data.tree.sha\n      .then (data) ->\n        # Update the branch head\n        patch \"git/refs/heads/#{branch}\",\n          sha: data.sha\n\n    switchToBranch: (branch) ->\n      ref = \"refs/heads/#{branch}\"\n      \n      setBranch = (data) ->\n        self.branch(branch)\n        \n        return data\n\n      get(\"git/#{ref}\")\n      .then setBranch # Success\n      , (request) -> # Failure\n        branchNotFound = (request.status is 404)\n\n        if branchNotFound\n          # Create branch if it doesn't exist\n          # Use our current branch as a base\n          # TODO: Should we always branch from the repo's default branch?\n          get(\"git/refs/heads/#{self.branch()}\")\n          .then (data) ->\n            post \"git/refs\",\n              ref: ref\n              sha: data.object.sha\n          .then(setBranch)\n        else\n          Deferred().reject(arguments...)\n\n    mergeInto: (branch=self.defaultBranch()) ->\n      # TODO: Use default branch rather than master\n      post \"merges\",\n        base: branch\n        head: self.branch()\n        \n    pullFromBranch: (branch=self.defaultBranch()) ->\n      post \"merges\",\n        base: self.branch()\n        head: branch\n\n  return self\n","type":"blob"},"sandbox.coffee":{"path":"sandbox.coffee","mode":"100644","content":"@Sandbox = ({name, width, height, methods}={}) ->\n  name ?= \"sandbox\" + new Date\n  width ?= 800\n  height ?= 600\n  methods ?= {}\n\n  sandbox = window.open(\n    \"\"\n    name\n    \"width=#{width},height=#{height}\"\n  )\n\n  # Pass functions to the running window\n  Object.extend sandbox, methods\n\n  sandbox\n","type":"blob"},"style.styl":{"path":"style.styl","mode":"100644","content":"html, body\n  margin: 0\n  height: 100%\n\n.main\n  position: relative\n  padding-top: 40px\n  padding-left: 200px\n  padding-bottom: 100px\n  box-sizing: border-box\n  height: 100%\n\n.editor-wrap\n  background-color: white\n  width: 100%\n  height: 100%\n  position: relative\n\n  & > div\n    position: absolute\n    top: 0\n    left: 0\n    right: 0\n    bottom: 0\n\n.filetree\n  margin: 0\n  padding: 0\n  width: 200px\n  position: absolute\n  left: 0\n  top: 40px\n  z-index: 2\n\n  li\n    list-style-type: none\n    padding-left: 1em\n    position: relative\n\n    .delete\n      display: none\n      position: absolute\n      right: 0\n\n    &:hover\n      background-color: lightyellow\n\n      .delete\n        display: inline-block\n\n.actions\n  position: absolute\n  top: 0\n  left: 200px\n\n.console-wrap\n  box-sizing: border-box\n  position: absolute\n  bottom: 0\n  left: 0\n  right: 0\n  padding-left: 200px\n  height: 100px\n  width: 100%\n  margin: 0\n  \n  .errors\n    box-sizing: border-box\n    border-top: 1px solid black\n    color: red\n\n.status\n  top: 0\n  right: 0\n  position: absolute\n","type":"blob"},"text_editor.coffee":{"path":"text_editor.coffee","mode":"100644","content":"@TextEditor = (I) ->\n  Object.reverseMerge I,\n    mode: \"coffee\"\n    text: \"\"\n\n  self = Model(I)\n\n  # We can't use ace on a div not in the DOM :(\n  el = I.el\n  # We can't serialize DOM elements\n  delete I.el\n\n  editor = ace.edit(el)\n  editor.setFontSize(\"16px\")\n  editor.setTheme(\"ace/theme/chrome\")\n  editor.getSession().setUseWorker(false)\n  editor.getSession().setMode(\"ace/mode/#{I.mode}\")\n  editor.getSession().setUseSoftTabs(true)\n  editor.getSession().setTabSize(2)\n\n  reset = (content=\"\") ->\n    editor.setValue(content)\n    editor.moveCursorTo(0, 0)\n    editor.session.selection.clearSelection()\n\n  reset(I.text)\n\n  self.attrObservable \"text\"\n\n  updating = false\n  editor.getSession().on 'change', ->\n    updating = true\n    self.text(editor.getValue())\n    updating = false\n\n  self.text.observe (newValue) ->\n    unless updating\n      reset(newValue)\n\n  self.extend\n    el: el\n    editor: editor\n    reset: reset\n\n  return self\n","type":"blob"}},"distribution":{"build.js":{"path":"build.js","content":"(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"actions\"] = function(data) {\n    return (function() {\n      var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"actions\");\n      actions = this.actions;\n      Object.keys(actions).each(function(name) {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, name.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return actions[name]();\n        });\n        return __pop();\n      });\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.issue_selector(this.issues));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"editor\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor\");\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"errors\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"console-wrap\");\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"errors\");\n      __each(this.errors, function(error) {\n        __element = document.createTextNode('');\n        __text(__element, error);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"notices\");\n      __each(this.notices, function(notice) {\n        __element = document.createTextNode('');\n        __text(__element, notice);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"filetree\"] = function(data) {\n    return (function() {\n      var files, selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"filetree\");\n      selectedFile = this.selectedFile;\n      files = this.files;\n      __each(files, function(file) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, file.displayName);\n        __push(__element);\n        __pop();\n        __on(\"click\", function(e) {\n          if ($(e.target).is('li')) {\n            return selectedFile(file);\n          }\n        });\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"delete\");\n        __on(\"click\", function() {\n          if (confirm(\"Delete \" + (file.path()) + \"?\")) {\n            return files.remove(file);\n          }\n        });\n        __element = document.createTextNode('');\n        __text(__element, \"X\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"gist_list\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"gists\");\n      __each(this.gists, function(gist) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, gist.id);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return alert(gist.id);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"github_status\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"status\");\n      if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n        __element = document.createTextNode('');\n        __text(__element, \"Authenticated Scopes:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n        __push(__element);\n        __pop();\n        __element = document.createElement(\"br\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \"Rate Limit Remaining:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \" / 5000\");\n        __push(__element);\n        __pop();\n      } else {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Auth\\n\");\n        __push(__element);\n        __pop();\n        __on(\"click\", Gistquire.auth);\n        __pop();\n      }\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"issue_selector\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"select\");\n      __push(__element);\n      __on(\"change\", this.currentIssue);\n      __element = document.createElement(\"option\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"- Default Branch -\");\n      __push(__element);\n      __pop();\n      __pop();\n      __each(this.issues, function() {\n        __element = document.createElement(\"option\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, this.optionText());\n        __push(__element);\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"main\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"main\");\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.actions({\n        actions: this.actions,\n        issues: this.issues\n      }));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.filetree(this.filetree));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.errors(this));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var commit, publish;\n\n  publish = function(_arg) {\n    var branch, builder, fileData, message, path, publishBranch, repository;\n    builder = _arg.builder, fileData = _arg.fileData, repository = _arg.repository;\n    branch = repository.branch();\n    message = \"Built \" + branch + \" in browser in strd6.github.io/tempest\";\n    if (branch === \"master\") {\n      path = \"index.html\";\n    } else {\n      path = \"\" + branch + \".html\";\n    }\n    publishBranch = \"gh-pages\";\n    return builder.build(fileData, function(build) {\n      return repository.writeFile({\n        path: path,\n        content: Base64.encode(builder.standAloneHtml(build)),\n        branch: publishBranch,\n        message: message\n      });\n    });\n  };\n\n  commit = function(_arg) {\n    var fileData, message, repository;\n    fileData = _arg.fileData, repository = _arg.repository, message = _arg.message;\n    return repository.commitTree({\n      tree: fileData,\n      message: message\n    });\n  };\n\n  this.Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    },\n    run: function(_arg) {\n      var builder, filetree;\n      builder = _arg.builder, filetree = _arg.filetree;\n      return builder.build(filetree.data(), function(build) {\n        var config, configData, sandbox, _base, _ref;\n        if (configData = (_ref = build.source[\"pixie.json\"]) != null ? _ref.content : void 0) {\n          config = JSON.parse(configData);\n        } else {\n          config = {};\n        }\n        sandbox = Sandbox({\n          width: config.width,\n          height: config.height\n        });\n        sandbox.document.open();\n        sandbox.document.write(builder.standAloneHtml(build));\n        sandbox.document.close();\n        return typeof (_base = builder.I).notices === \"function\" ? _base.notices([\"Running!\"]) : void 0;\n      });\n    },\n    load: function(_arg) {\n      var branch, filetree, processDirectory, repository;\n      filetree = _arg.filetree, repository = _arg.repository;\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      branch = repository.branch();\n      return repository.latestTree(branch).then(function(data) {\n        var deferred, treeFiles;\n        treeFiles = data.tree.select(function(file) {\n          return file.type === \"blob\";\n        });\n        async.map(treeFiles, function(datum, callback) {\n          return Gistquire.api(datum.url).then(function(data) {\n            return callback(null, Object.extend(datum, data));\n          }).fail(function(request, error, message) {\n            return callback(message);\n          });\n        }, function(error, results) {\n          var files;\n          if (error) {\n            deferred.reject(error);\n            return;\n          }\n          files = processDirectory(results);\n          filetree.load(files);\n          return deferred.resolve(treeFiles);\n        });\n        return deferred = $.Deferred();\n      });\n    }\n  };\n\n}).call(this);\n\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n;\n/**\n*\n*  Base64 encode / decode\n*  http://www.webtoolkit.info/\n*\n**/\n \nvar Base64 = {\n \n  // private property\n\t_keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n \n\t// public method for encoding\n\tencode : function (input) {\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = Base64._utf8_encode(input);\n \n\t\twhile (i < input.length) {\n \n\t\t\tchr1 = input.charCodeAt(i++);\n\t\t\tchr2 = input.charCodeAt(i++);\n\t\t\tchr3 = input.charCodeAt(i++);\n \n\t\t\tenc1 = chr1 >> 2;\n\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\tenc4 = chr3 & 63;\n \n\t\t\tif (isNaN(chr2)) {\n\t\t\t\tenc3 = enc4 = 64;\n\t\t\t} else if (isNaN(chr3)) {\n\t\t\t\tenc4 = 64;\n\t\t\t}\n \n\t\t\toutput = output +\n\t\t\tthis._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\n\t\t\tthis._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n \n\t\t}\n \n\t\treturn output;\n\t},\n \n\t// public method for decoding\n\tdecode : function (input) {\n\t\tvar output = \"\";\n\t\tvar chr1, chr2, chr3;\n\t\tvar enc1, enc2, enc3, enc4;\n\t\tvar i = 0;\n \n\t\tinput = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n \n\t\twhile (i < input.length) {\n \n\t\t\tenc1 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc2 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc3 = this._keyStr.indexOf(input.charAt(i++));\n\t\t\tenc4 = this._keyStr.indexOf(input.charAt(i++));\n \n\t\t\tchr1 = (enc1 << 2) | (enc2 >> 4);\n\t\t\tchr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n\t\t\tchr3 = ((enc3 & 3) << 6) | enc4;\n \n\t\t\toutput = output + String.fromCharCode(chr1);\n \n\t\t\tif (enc3 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr2);\n\t\t\t}\n\t\t\tif (enc4 != 64) {\n\t\t\t\toutput = output + String.fromCharCode(chr3);\n\t\t\t}\n \n\t\t}\n \n\t\toutput = Base64._utf8_decode(output);\n \n\t\treturn output;\n \n\t},\n \n\t// private method for UTF-8 encoding\n\t_utf8_encode : function (string) {\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\n\t\tvar utftext = \"\";\n \n\t\tfor (var n = 0; n < string.length; n++) {\n \n\t\t\tvar c = string.charCodeAt(n);\n \n\t\t\tif (c < 128) {\n\t\t\t\tutftext += String.fromCharCode(c);\n\t\t\t}\n\t\t\telse if((c > 127) && (c < 2048)) {\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n \n\t\t}\n \n\t\treturn utftext;\n\t},\n \n\t// private method for UTF-8 decoding\n\t_utf8_decode : function (utftext) {\n\t\tvar string = \"\";\n\t\tvar i = 0;\n\t\tvar c = c1 = c2 = 0;\n \n\t\twhile ( i < utftext.length ) {\n \n\t\t\tc = utftext.charCodeAt(i);\n \n\t\t\tif (c < 128) {\n\t\t\t\tstring += String.fromCharCode(c);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if((c > 191) && (c < 224)) {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tstring += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\n\t\t\t\tc3 = utftext.charCodeAt(i+2);\n\t\t\t\tstring += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t\ti += 3;\n\t\t\t}\n \n\t\t}\n \n\t\treturn string;\n\t}\n \n}\n;;\n(function() {\n  var arrayToHash, compileFile, compileStyl, compileTemplate, stripMarkdown;\n\n  arrayToHash = function(array) {\n    return array.eachWithObject({}, function(file, hash) {\n      return hash[file.path] = file;\n    });\n  };\n\n  stripMarkdown = function(content) {\n    return content.split(\"\\n\").map(function(line) {\n      var match;\n      if (match = /^([ ]{4}|\\t)/.exec(line)) {\n        return line.slice(match[0].length);\n      } else {\n        return \"\";\n      }\n    }).join(\"\\n\");\n  };\n\n  compileTemplate = function(source, name) {\n    var ast;\n    if (name == null) {\n      name = \"test\";\n    }\n    ast = HAMLjr.parser.parse(source);\n    return HAMLjr.compile(ast, {\n      name: name,\n      compiler: CoffeeScript\n    });\n  };\n\n  compileStyl = function(source) {\n    return styl(source, {\n      whitespace: true\n    }).toString();\n  };\n\n  compileFile = function(_arg) {\n    var content, extension, name, path, result, _ref;\n    path = _arg.path, content = _arg.content;\n    _ref = [path.withoutExtension(), path.extension()], name = _ref[0], extension = _ref[1];\n    result = (function() {\n      switch (extension) {\n        case \"js\":\n          return {\n            code: content\n          };\n        case \"coffee\":\n          return {\n            code: CoffeeScript.compile(content)\n          };\n        case \"haml\":\n          return {\n            code: compileTemplate(content, name)\n          };\n        case \"styl\":\n          return {\n            style: compileStyl(content)\n          };\n        case \"md\":\n          return compileFile({\n            path: name,\n            content: stripMarkdown(content)\n          });\n        default:\n          return {};\n      }\n    })();\n    Object.defaults(result, {\n      name: name,\n      extension: extension\n    });\n    return Object.extend(result, {\n      path: path\n    });\n  };\n\n  this.Builder = function(I) {\n    var build, postProcessors;\n    if (I == null) {\n      I = {};\n    }\n    compileTemplate = function(source, name) {\n      var ast;\n      if (name == null) {\n        name = \"test\";\n      }\n      ast = HAMLjr.parser.parse(source);\n      return HAMLjr.compile(ast, {\n        name: name,\n        compiler: CoffeeScript\n      });\n    };\n    build = function(fileData) {\n      return fileData.map(function(_arg) {\n        var content, location, message, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          return compileFile({\n            path: path,\n            content: content\n          });\n        } catch (_error) {\n          location = _error.location, message = _error.message;\n          if (location != null) {\n            message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n          }\n          return {\n            error: \"\" + path + \" - \" + message\n          };\n        }\n      });\n    };\n    postProcessors = [];\n    return {\n      I: I,\n      addPostProcessor: function(fn) {\n        return postProcessors.push(fn);\n      },\n      build: function(fileData, callback) {\n        var builtItems, dist, distCode, distStyle, errors, results, _ref;\n        I.notices.push(\"Building...\");\n        _ref = build(fileData).partition(function(result) {\n          return result.error;\n        }), errors = _ref[0], builtItems = _ref[1];\n        if (errors.length) {\n          I.errors(errors);\n          return;\n        }\n        results = {\n          code: [],\n          style: [],\n          main: []\n        };\n        builtItems.eachWithObject(results, function(item, hash) {\n          var code, style;\n          if (code = item.code) {\n            if (item.name === \"main\" && (item.extension === \"js\" || item.extension === \"coffee\")) {\n              return hash.main.push(code);\n            } else {\n              return hash.code.push(code);\n            }\n          } else if (style = item.style) {\n            return hash.style.push(style);\n          } else {\n\n          }\n        });\n        distCode = results.code.concat(results.main).join(';').trim();\n        distStyle = results.style.join('').trim();\n        dist = [];\n        if (!distCode.blank()) {\n          dist.push({\n            path: \"build.js\",\n            content: distCode,\n            type: \"blob\"\n          });\n        }\n        if (!distStyle.blank()) {\n          dist.push({\n            path: \"style.css\",\n            content: distStyle,\n            type: \"blob\"\n          });\n        }\n        return callback(postProcessors.pipeline({\n          source: arrayToHash(fileData),\n          distribution: arrayToHash(dist)\n        }));\n      },\n      standAloneHtml: function(build) {\n        var content, distribution, entryPoint, program, source;\n        source = build.source, distribution = build.distribution;\n        content = [];\n        content.push(\"<!doctype html>\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        content = content.concat($('script.env').map(function() {\n          return this.outerHTML;\n        }).get());\n        entryPoint = \"build.js\";\n        program = distribution[entryPoint].content;\n        content.push(\"</head><body><script>\\n  Function(\\\"ENV\\\", \" + (JSON.stringify(program)) + \")(\" + (JSON.stringify(build)) + \");\\n<\\/script>\");\n        return content.join(\"\\n\");\n      }\n    };\n  };\n\n}).call(this);\n\n(function() {\n  var withDeferrence;\n\n  this.Deferred = $.Deferred;\n\n  withDeferrence = function(fn) {\n    var deferred, e;\n    deferred = Deferred();\n    try {\n      fn.defer(deferred);\n    } catch (_error) {\n      e = _error;\n      deferred.reject(e);\n    }\n    return deferred.promise();\n  };\n\n  Deferred.Confirm = function(message) {\n    return withDeferrence(function(deferred) {\n      if (window.confirm(message)) {\n        return deferred.resolve();\n      } else {\n        return deferred.reject();\n      }\n    });\n  };\n\n  Deferred.ConfirmIf = function(flag, message) {\n    if (flag) {\n      return Deferred.Confirm(message);\n    } else {\n      return withDeferrence(function(deferred) {\n        return deferred.resolve();\n      });\n    }\n  };\n\n  Deferred.ExecuteIf = function(flag, callback) {\n    return withDeferrence(function(deferred) {\n      if (flag) {\n        return callback().then(deferred.resolve);\n      } else {\n        return deferred.resolve();\n      }\n    });\n  };\n\n}).call(this);\n\n(function() {\n  String.prototype.dasherize = function() {\n    return this.trim().replace(/\\s+/g, \"-\").toLowerCase();\n  };\n\n}).call(this);\n\n(function() {\n  this.File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          case \"\":\n            return \"text\";\n          default:\n            return extension;\n        }\n      },\n      modified: Observable(false),\n      displayName: Observable(self.path())\n    });\n    self.content.observe(function() {\n      return self.modified(true);\n    });\n    self.modified.observe(function(modified) {\n      if (modified) {\n        return self.displayName(\"*\" + (self.path()));\n      } else {\n        return self.displayName(self.path());\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        if (Array.isArray(fileData)) {\n          files = fileData.sort(function(a, b) {\n            if (a.path < b.path) {\n              return -1;\n            } else if (b.path < a.path) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).map(File);\n        } else {\n          files = Object.keys(fileData).sort().map(function(name) {\n            return File(fileData[name]);\n          });\n        }\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.filename(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      },\n      hasUnsavedChanges: function() {\n        return self.files().select(function(file) {\n          return file.modified();\n        }).length;\n      },\n      markSaved: function() {\n        return self.files().each(function(file) {\n          return file.modified(false);\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    }\n  };\n\n}).call(this);\n\n(function() {\n  this.Issue = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    self = Model(I);\n    self.extend({\n      optionText: function() {\n        return \"\" + I.title;\n      },\n      fullDescription: function() {\n        return \"\" + (self.optionText()) + \"\\n\" + I.html_url + \"\\n\" + I.body;\n      },\n      branchName: function() {\n        var _ref;\n        return ((_ref = I.head) != null ? _ref.ref : void 0) || (\"issue-\" + I.number);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Issues = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      issues: []\n    });\n    self = Model(I);\n    self.attrModels(\"issues\");\n    self.attrObservable(\"currentIssue\");\n    self.extend({\n      reset: function(issueData) {\n        self.currentIssue(void 0);\n        return self.issues(issueData.map(Issue));\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Repository = function(I) {\n    var api, get, patch, post, put, requestOptions, self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      branch: \"master\",\n      defaultBranch: \"master\"\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"branch\");\n    requestOptions = function(type, data) {\n      return {\n        type: type,\n        data: JSON.stringify(data)\n      };\n    };\n    api = function(path, options) {\n      var url;\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"\" + (self.url()) + \"/\" + path;\n      }\n      return Gistquire.api(url, options);\n    };\n    get = function(path, data) {\n      return api(path, {\n        data: data\n      });\n    };\n    put = function(path, data) {\n      return api(path, requestOptions(\"PUT\", data));\n    };\n    post = function(path, data) {\n      return api(path, requestOptions(\"POST\", data));\n    };\n    patch = function(path, data) {\n      return api(path, requestOptions(\"PATCH\", data));\n    };\n    self.extend({\n      pullRequests: function() {\n        return get(\"pulls\");\n      },\n      createPullRequest: function(_arg) {\n        var head, title;\n        title = _arg.title;\n        head = title.dasherize();\n        return self.switchToBranch(head).then(self.commitEmpty).then(function() {\n          return post(\"pulls\", {\n            base: I.defaultBranch,\n            head: head,\n            title: title\n          });\n        });\n      },\n      initPagesBranch: function() {\n        var branch;\n        branch = \"gh-pages\";\n        return post(\"git/trees\", {\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/editor\"\n            }\n          ]\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            message: \"Initial gh-pages commit\",\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return post(\"git/refs\", {\n            ref: \"refs/heads/\" + branch,\n            sha: data.sha\n          });\n        });\n      },\n      writeFile: function(params) {\n        var branch, content, message, path;\n        branch = params.branch, path = params.path, content = params.content, message = params.message;\n        return get(\"contents/\" + path, {\n          ref: branch\n        }).then(function(data) {\n          return put(\"contents/\" + path, {\n            content: content,\n            sha: data.sha,\n            message: message,\n            branch: branch\n          });\n        }, function(request) {\n          var _ref, _ref1;\n          if (((_ref = request.responseJSON) != null ? _ref.message : void 0) === \"No commit found for the ref gh-pages\") {\n            return self.initPagesBranch().then(function() {\n              return self.writeFile(params);\n            });\n          } else if (request.status === 404) {\n            return put(\"contents/\" + path, {\n              content: content,\n              message: message,\n              branch: branch\n            });\n          } else {\n            return (_ref1 = Deferred()).reject.apply(_ref1, arguments);\n          }\n        });\n      },\n      latestTree: function(branch) {\n        if (branch == null) {\n          branch = \"master\";\n        }\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return get(\"\" + data.tree.url + \"?recursive=1\");\n        });\n      },\n      commitTree: function(_arg) {\n        var branch, latestCommitSha, message, tree;\n        message = _arg.message, tree = _arg.tree;\n        branch = self.branch();\n        if (message == null) {\n          message = \"Updated in browser at strd6.github.io/editor\";\n        }\n        if (!tree) {\n          throw Error(\"Must pass in a tree\");\n        }\n        latestCommitSha = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          latestCommitSha = data.object.sha;\n          return post(\"git/trees\", {\n            tree: tree\n          });\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [latestCommitSha],\n            message: message,\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      commitEmpty: function() {\n        var branch, latestCommit;\n        branch = self.branch();\n        latestCommit = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [data.sha],\n            message: \"This commit intentionally left blank\",\n            tree: data.tree.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      switchToBranch: function(branch) {\n        var ref, setBranch;\n        ref = \"refs/heads/\" + branch;\n        setBranch = function(data) {\n          self.branch(branch);\n          return data;\n        };\n        return get(\"git/\" + ref).then(setBranch, function(request) {\n          var branchNotFound, _ref;\n          branchNotFound = request.status === 404;\n          if (branchNotFound) {\n            return get(\"git/refs/heads/\" + (self.branch())).then(function(data) {\n              return post(\"git/refs\", {\n                ref: ref,\n                sha: data.object.sha\n              });\n            }).then(setBranch);\n          } else {\n            return (_ref = Deferred()).reject.apply(_ref, arguments);\n          }\n        });\n      },\n      mergeInto: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: branch,\n          head: self.branch()\n        });\n      },\n      pullFromBranch: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: self.branch(),\n          head: branch\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Sandbox = function(_arg) {\n    var height, methods, name, sandbox, width, _ref;\n    _ref = _arg != null ? _arg : {}, name = _ref.name, width = _ref.width, height = _ref.height, methods = _ref.methods;\n    if (name == null) {\n      name = \"sandbox\" + new Date;\n    }\n    if (width == null) {\n      width = 800;\n    }\n    if (height == null) {\n      height = 600;\n    }\n    if (methods == null) {\n      methods = {};\n    }\n    sandbox = window.open(\"\", name, \"width=\" + width + \",height=\" + height);\n    Object.extend(sandbox, methods);\n    return sandbox;\n  };\n\n}).call(this);\n\n(function() {\n  this.TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var $root, actions, branch, builder, classicError, confirmUnsaved, currentNode, distribution, errors, files, filetree, fullName, issues, notices, notify, owner, repo, repository, repositoryLoaded, styleContent, _ref, _ref1;\n\n  files = ENV.source, distribution = ENV.distribution;\n\n  window.ENV = ENV;\n\n  classicError = function(request) {\n    var message;\n    notices([]);\n    if (request.responseJSON) {\n      message = JSON.stringify(request.responseJSON, null, 2);\n    } else {\n      message = \"Error\";\n    }\n    return errors([message]);\n  };\n\n  notify = function(message) {\n    notices([message]);\n    return errors([]);\n  };\n\n  currentNode = function() {\n    var target;\n    target = document.documentElement;\n    while (target.childNodes.length && target.lastChild.nodeType === 1) {\n      target = target.lastChild;\n    }\n    return target.parentNode;\n  };\n\n  $root = $(currentNode());\n\n  if (styleContent = (_ref = distribution[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  Gistquire.onload();\n\n  _ref1 = ENV.repository, owner = _ref1.owner, repo = _ref1.repo, branch = _ref1.branch, fullName = _ref1.full_name;\n\n  fullName || (fullName = \"\" + owner + \"/\" + repo);\n\n  repository = Repository({\n    url: \"repos/\" + fullName\n  });\n\n  errors = Observable([]);\n\n  notices = Observable([\"Loaded!\"]);\n\n  builder = Builder({\n    errors: errors,\n    notices: notices\n  });\n\n  repositoryLoaded = function(repository) {\n    issues.repository = repository;\n    repository.pullRequests().then(issues.reset);\n    return notices([\"Finished loading!\"]);\n  };\n\n  confirmUnsaved = function() {\n    return Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\");\n  };\n\n  issues = Issues();\n\n  builder.addPostProcessor(function(data) {\n    data.repository = {\n      full_name: fullName,\n      branch: branch\n    };\n    return data;\n  });\n\n  builder.addPostProcessor(function(data) {\n    data.progenitor = {\n      url: \"http://strd6.github.io/editor/\"\n    };\n    return data;\n  });\n\n  actions = {\n    save: function() {\n      notices([\"Saving...\"]);\n      return Actions.save({\n        repository: repository,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        filetree.markSaved();\n        return notices([\"Saved and published!\"]);\n      });\n    },\n    run: function() {\n      return Actions.run({\n        builder: builder,\n        filetree: filetree\n      });\n    },\n    new_file: function() {\n      var name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        return filetree.files.push(File({\n          filename: name,\n          content: \"\"\n        }));\n      }\n    },\n    load_repo: function(skipPrompt) {\n      return confirmUnsaved().then(function() {\n        if (!skipPrompt) {\n          fullName = prompt(\"Github repo\", fullName);\n        }\n        if (fullName) {\n          repository = Repository({\n            url: \"repos/\" + fullName\n          });\n        } else {\n          errors([\"No repo given\"]);\n          return;\n        }\n        notices([\"Loading repo...\"]);\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return repositoryLoaded(repository);\n        }).fail(function() {\n          return errors([\"Error loading \" + (repository.url())]);\n        });\n      });\n    },\n    new_feature: function() {\n      var title;\n      if (title = prompt(\"Description\")) {\n        notices([\"Creating feature branch...\"]);\n        return repository.createPullRequest({\n          title: title\n        }).then(function(data) {\n          var issue;\n          issue = Issue(data);\n          issues.issues.push(issue);\n          issues.silent = true;\n          issues.currentIssue(issue);\n          issues.silent = false;\n          return notices.push(\"Created!\");\n        }, classicError);\n      }\n    },\n    pull_master: function() {\n      return confirmUnsaved().then(function() {\n        notify(\"Merging in default branch...\");\n        return repository.pullFromBranch();\n      }, classicError).then(function() {\n        var branchName;\n        notices.push(\"Merged!\");\n        branchName = repository.branch();\n        notices.push(\"\\nReloading branch \" + branchName + \"...\");\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return notices.push(\"Loaded!\");\n        });\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.templates.editor());\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        return file.content(value);\n      });\n    }\n  });\n\n  repositoryLoaded(repository);\n\n  issues.currentIssue.observe(function(issue) {\n    var changeBranch;\n    if (issues.silent) {\n      return;\n    }\n    changeBranch = function(branchName) {\n      var previousBranch;\n      previousBranch = repository.branch();\n      return confirmUnsaved().then(function() {\n        return repository.switchToBranch(branchName).then(function() {\n          notices.push(\"\\nLoading branch \" + branchName + \"...\");\n          return Actions.load({\n            repository: repository,\n            filetree: filetree\n          }).then(function() {\n            return notices.push(\"Loaded!\");\n          });\n        });\n      }, function() {\n        repository.branch(previousBranch);\n        return errors([\"Error switching to \" + branchName + \", still on \" + previousBranch]);\n      });\n    };\n    if (issue) {\n      notify(issue.fullDescription());\n      return changeBranch(issue.branchName());\n    } else {\n      notify(\"Default branch selected\");\n      return changeBranch(repository.defaultBranch());\n    }\n  });\n\n  $root.append(HAMLjr.templates.main({\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors,\n    issues: issues\n  }));\n\n  Gistquire.api(\"rate_limit\", {\n    complete: function(request, status) {\n      return $root.append(HAMLjr.templates.github_status({\n        request: request\n      }));\n    }\n  });\n\n  window.onbeforeunload = function() {\n    if (filetree.hasUnsavedChanges()) {\n      return \"You have some unsaved changes, if you leave now you will lose your work.\";\n    }\n  };\n\n}).call(this);\n","type":"blob"},"style.css":{"path":"style.css","content":"html,\nbody {\n  margin: 0;\n  height: 100%;\n}\n\n.main {\n  position: relative;\n  padding-top: 40px;\n  padding-left: 200px;\n  padding-bottom: 100px;\n  height: 100%;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.editor-wrap {\n  background-color: white;\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n.editor-wrap > div {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.filetree {\n  margin: 0;\n  padding: 0;\n  width: 200px;\n  position: absolute;\n  left: 0;\n  top: 40px;\n  z-index: 2;\n}\n\n.filetree li .delete {\n  display: none;\n  position: absolute;\n  right: 0;\n}\n\n.filetree li:hover .delete {\n  display: inline-block;\n}\n\n.filetree li:hover {\n  background-color: lightyellow;\n}\n\n.filetree li {\n  list-style-type: none;\n  padding-left: 1em;\n  position: relative;\n}\n\n.actions {\n  position: absolute;\n  top: 0;\n  left: 200px;\n}\n\n.console-wrap {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  padding-left: 200px;\n  height: 100px;\n  width: 100%;\n  margin: 0;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.console-wrap .errors {\n  border-top: 1px solid black;\n  color: red;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.status {\n  top: 0;\n  right: 0;\n  position: absolute;\n}","type":"blob"}},"repository":{"full_name":"STRd6/editor","branch":"master"},"progenitor":{"url":"http://strd6.github.io/editor/"}});
</script>