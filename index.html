<script class="env" src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script>
<script class="env" src="//code.jquery.com/jquery-1.10.1.min.js"></script>
<script class="env" src="//d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js"></script>
<script class="env" src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.1/underscore-min.js"></script>
<script class="env" src="http://strd6.github.io/tempest/javascripts/envweb.js"></script>
<body><script>
  Function("ENV", "(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"actions\"] = function(data) {\n    return (function() {\n      var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"actions\");\n      actions = this;\n      Object.keys(actions).each(function(name) {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, name.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", actions[name]);\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"editor\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor\");\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"errors\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"console-wrap\");\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"errors\");\n      __each(this.errors, function(error) {\n        __element = document.createTextNode('');\n        __text(__element, error);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"notices\");\n      __each(this.notices, function(notice) {\n        __element = document.createTextNode('');\n        __text(__element, notice);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"filetree\"] = function(data) {\n    return (function() {\n      var selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"filetree\");\n      selectedFile = this.selectedFile;\n      __each(this.files, function(file) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, file.path);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return selectedFile(file);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"gist_list\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"gists\");\n      __each(this.gists, function(gist) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, gist.id);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return alert(gist.id);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"github_status\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"status\");\n      if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n        __element = document.createTextNode('');\n        __text(__element, \"Authenticated Scopes:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n        __push(__element);\n        __pop();\n        __element = document.createElement(\"br\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \"Rate Limit Remaining:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \" / 5000\");\n        __push(__element);\n        __pop();\n      } else {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Auth\\n\");\n        __push(__element);\n        __pop();\n        __on(\"click\", Gistquire.auth);\n        __pop();\n      }\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"main\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"main\");\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.actions(this.actions));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.filetree(this.filetree));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.errors(this));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n(function() {\n  // Lookup arrays for base64 conversions\n  var enc64List, dec64List;\n  // Load the lookup arrays once\n  (function() {\n      enc64List = new Array();\n      dec64List = new Array();\n      var i;\n      for (i = 0; i < 26; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(65 + i);\n      }\n      for (i = 0; i < 26; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(97 + i);\n      }\n      for (i = 0; i < 10; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(48 + i);\n      }\n      enc64List[enc64List.length] = \"+\";\n      enc64List[enc64List.length] = \"/\";\n      for (i = 0; i < 128; i++) {\n          dec64List[dec64List.length] = -1;\n      }\n      for (i = 0; i < 64; i++) {\n          dec64List[enc64List[i].charCodeAt(0)] = i;\n      }\n  })();\n\n  window.Base64 = {\n    encode: function(str) {\n        var c, d, e, end = 0;\n        var u, v, w, x;\n        var ptr = -1;\n        var input = str.split(\"\");\n        var output = \"\";\n        while(end == 0) {\n            c = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end = 1) ? 0 : 0);\n            d = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end += 1) ? 0 : 0);\n            e = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end += 1) ? 0 : 0);\n            u = enc64List[c >> 2];\n            v = enc64List[(0x00000003 & c) << 4 | d >> 4];\n            w = enc64List[(0x0000000F & d) << 2 | e >> 6];\n            x = enc64List[e & 0x0000003F];\n\n            // handle padding to even out unevenly divisible string lengths\n            if (end >= 1) {x = \"=\";}\n            if (end == 2) {w = \"=\";}\n\n            if (end < 3) {output += u + v + w + x;}\n        }\n        return output;\n    },\n\n    decode: function(str) {\n        var c=0, d=0, e=0, f=0, i=0, n=0;\n        var input = str.split(\"\");\n        var output = \"\";\n        var ptr = 0;\n        do {\n            f = input[ptr++].charCodeAt(0);\n            i = dec64List[f];\n            if ( f >= 0 && f < 128 && i != -1 ) {\n                if ( n % 4 == 0 ) {\n                    c = i << 2;\n                } else if ( n % 4 == 1 ) {\n                    c = c | ( i >> 4 );\n                    d = ( i & 0x0000000F ) << 4;\n                } else if ( n % 4 == 2 ) {\n                    d = d | ( i >> 2 );\n                    e = ( i & 0x00000003 ) << 6;\n                } else {\n                    e = e | i;\n                }\n                n++;\n                if ( n % 4 == 0 ) {\n                    output += String.fromCharCode(c) +\n                              String.fromCharCode(d) +\n                              String.fromCharCode(e);\n                }\n            }\n        }\n        while (typeof input[ptr] != \"undefined\");\n        output += (n % 4 == 3) ? String.fromCharCode(c) + String.fromCharCode(d) :\n                  ((n % 4 == 2) ? String.fromCharCode(c) : \"\");\n        return output;\n    }\n  };\n}());\n\n(function() {\n  this.Builder = function(I) {\n    var build, buildStyle, compileTemplate;\n    if (I == null) {\n      I = {};\n    }\n    compileTemplate = function(source, name) {\n      var ast;\n      if (name == null) {\n        name = \"test\";\n      }\n      ast = HAMLjr.parser.parse(source);\n      return HAMLjr.compile(ast, {\n        name: name,\n        compiler: CoffeeScript\n      });\n    };\n    build = function(fileData) {\n      var errors, main, models, templates;\n      templates = [];\n      models = [];\n      main = \"\";\n      errors = [];\n      fileData.each(function(_arg) {\n        var content, error, name, path, source;\n        path = _arg.path, content = _arg.content;\n        name = path.split('/').last();\n        source = content;\n        try {\n          if (name.extension() === \"haml\") {\n            return templates.push(compileTemplate(source, name.withoutExtension()));\n          } else if (name.extension() === \"js\") {\n            if (name === \"main.js\") {\n              return main = source;\n            } else if (name === \"build.js\") {\n\n            } else {\n              return models.push(source);\n            }\n          } else if (name.extension() === \"coffee\") {\n            if (name === \"main.coffee\") {\n              return main = CoffeeScript.compile(source);\n            } else {\n              return models.push(CoffeeScript.compile(source));\n            }\n          }\n        } catch (_error) {\n          error = _error;\n          return errors.push(error.stack);\n        }\n      });\n      return {\n        errors: errors,\n        result: \"\" + (templates.join(\"\\n\")) + \"\\n\" + (models.join(\"\\n\")) + \"\\n\" + main\n      };\n    };\n    buildStyle = function(fileData) {\n      var errors, styles;\n      styles = [];\n      errors = [];\n      fileData.each(function(_arg) {\n        var content, error, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          if (path.extension() === \"styl\") {\n            return styles.push(styl(content, {\n              whitespace: true\n            }).toString());\n          }\n        } catch (_error) {\n          error = _error;\n          return errors.push(error.stack);\n        }\n      });\n      return {\n        errors: errors,\n        result: styles.join(\"\\n\")\n      };\n    };\n    return {\n      build: function(fileData, callback) {\n        var collectedErrors, compileResult, errors, fileMap, result, _ref, _ref1;\n        I.notices.push(\"Building...\");\n        _ref = build(fileData), collectedErrors = _ref.errors, compileResult = _ref.result;\n        _ref1 = buildStyle(fileData), errors = _ref1.errors, result = _ref1.result;\n        collectedErrors = collectedErrors.concat(errors);\n        if (compileResult.trim() !== \"\") {\n          fileData.push({\n            path: \"build.js\",\n            content: compileResult,\n            type: \"blob\"\n          });\n        }\n        if (result !== \"\") {\n          fileData.push({\n            path: \"style.css\",\n            content: result,\n            type: \"blob\"\n          });\n        }\n        if (collectedErrors.length) {\n          return typeof I.errors === \"function\" ? I.errors(collectedErrors) : void 0;\n        } else {\n          fileMap = fileData.eachWithObject({}, function(file, hash) {\n            return hash[file.path] = file;\n          });\n          return callback(fileMap);\n        }\n      },\n      standAloneHtml: function(fileMap) {\n        var content, entryPoint, program;\n        content = $('script.env').map(function() {\n          return this.outerHTML;\n        }).get();\n        entryPoint = \"build.js\";\n        program = fileMap[entryPoint].content;\n        content.push(\"<body><script>\\n  Function(\\\"ENV\\\", \" + (JSON.stringify(program)) + \")({\\n    files: \" + (JSON.stringify(fileMap)) + \"\\n  });\\n<\\/script>\");\n        return content.join(\"\\n\");\n      }\n    };\n  };\n\n}).call(this);\n\n(function() {\n  this.File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          default:\n            return extension;\n        }\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        files = Object.keys(fileData).sort().map(function(name) {\n          return File(fileData[name]);\n        });\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.filename(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    update: function(id, _arg) {\n      var data, error, success, url;\n      data = _arg.data, success = _arg.success, error = _arg.error;\n      url = \"https://api.github.com/gists/\" + id;\n      if (this.accessToken) {\n        url += \"?access_token=\" + this.accessToken;\n      }\n      return $.ajax({\n        url: url,\n        type: \"PATCH\",\n        dataType: 'json',\n        data: JSON.stringify(data),\n        success: success,\n        error: error\n      });\n    },\n    create: function(data, callback) {\n      var url;\n      url = \"https://api.github.com/gists\";\n      if (this.accessToken) {\n        url += \"?access_token=\" + this.accessToken;\n      }\n      return $.ajax({\n        url: url,\n        type: \"POST\",\n        dataType: 'json',\n        data: JSON.stringify(data),\n        success: callback\n      });\n    },\n    get: function(id, callback) {\n      return this.api(\"gists/\" + id, {\n        success: callback\n      });\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    },\n    initPagesBranch: function(_arg) {\n      var branch, error, owner, repo, success;\n      owner = _arg.owner, repo = _arg.repo, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      branch = \"gh-pages\";\n      if (!(owner && repo)) {\n        throw Error(\"Must pass in an owner and a repo\");\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/trees\", {\n        type: \"POST\",\n        data: JSON.stringify({\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/tempest\"\n            }\n          ]\n        }),\n        success: function(data) {\n          return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/commits\", {\n            type: \"POST\",\n            data: JSON.stringify({\n              message: \"Initial gh-pages commit\",\n              tree: data.sha\n            }),\n            success: function(data) {\n              return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs\", {\n                type: \"POST\",\n                data: JSON.stringify({\n                  ref: \"refs/heads/\" + branch,\n                  sha: data.sha\n                }),\n                success: success,\n                error: error\n              });\n            },\n            error: error\n          });\n        },\n        error: error\n      });\n    },\n    writeFile: function(_arg) {\n      var branch, content, error, message, owner, path, repo, success;\n      owner = _arg.owner, repo = _arg.repo, branch = _arg.branch, path = _arg.path, content = _arg.content, message = _arg.message, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/contents/\" + path, {\n        data: {\n          ref: branch\n        },\n        success: function(data) {\n          return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/contents/\" + path, {\n            type: \"PUT\",\n            data: JSON.stringify({\n              content: content,\n              sha: data.sha,\n              message: message,\n              branch: branch\n            }),\n            success: success,\n            error: error\n          });\n        },\n        error: function(request) {\n          if (request.status === 404) {\n            return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/contents/\" + path, {\n              type: \"PUT\",\n              data: JSON.stringify({\n                content: content,\n                message: message,\n                branch: branch\n              }),\n              success: success,\n              error: error\n            });\n          } else {\n            return error.apply(null, arguments);\n          }\n        }\n      });\n    },\n    commitTree: function(_arg) {\n      var branch, error, message, owner, repo, success, tree;\n      owner = _arg.owner, repo = _arg.repo, branch = _arg.branch, message = _arg.message, tree = _arg.tree, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      if (branch == null) {\n        branch = \"master\";\n      }\n      if (message == null) {\n        message = \"Updated in browser at strd6.github.io/editor\";\n      }\n      if (!(owner && repo && tree)) {\n        throw Error(\"Must pass in an owner, a tree, and a repo\");\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs/heads/\" + branch, {\n        success: function(data) {\n          var latestCommitSha;\n          latestCommitSha = data.object.sha;\n          return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/trees\", {\n            type: \"POST\",\n            data: JSON.stringify({\n              tree: tree\n            }),\n            success: function(data) {\n              return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/commits\", {\n                type: \"POST\",\n                data: JSON.stringify({\n                  parents: [latestCommitSha],\n                  message: message,\n                  tree: data.sha\n                }),\n                success: function(data) {\n                  return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs/heads/\" + branch, {\n                    type: \"PATCH\",\n                    data: JSON.stringify({\n                      sha: data.sha\n                    }),\n                    success: success,\n                    error: error\n                  });\n                },\n                error: error\n              });\n            },\n            error: error\n          });\n        },\n        error: error\n      });\n    },\n    latestTree: function(_arg) {\n      var branch, error, owner, repo, success;\n      owner = _arg.owner, repo = _arg.repo, branch = _arg.branch, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      if (branch == null) {\n        branch = \"master\";\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs/heads/\" + branch, {\n        success: function(data) {\n          return Gistquire.api(data.object.url, {\n            success: function(data) {\n              return Gistquire.api(\"\" + data.tree.url + \"?recursive=1\", {\n                success: success,\n                error: error\n              });\n            },\n            error: error\n          });\n        },\n        error: error\n      });\n    }\n  };\n\n}).call(this);\n\n// Github.js 0.8.0\n// (c) 2013 Michael Aufreiter, Development Seed\n// Github.js is freely distributable under the MIT license.\n// For all details and documentation:\n// http://substance.io/michael/github\n\n(function() {\n\n  // Initial Setup\n  // -------------\n\n  var XMLHttpRequest, Base64, _;\n  if (typeof exports !== 'undefined') {\n      XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n      _ = require('underscore');\n      Base64 = require('./lib/base64.js');\n  }else{\n      _ = window._;\n      Base64 = window.Base64;\n  }\n  //prefer native XMLHttpRequest always\n  if (typeof window !== 'undefined' && typeof window.XMLHttpRequest !== 'undefined'){\n      XMLHttpRequest = window.XMLHttpRequest;\n  }\n\n\n  var API_URL = 'https://api.github.com';\n\n  var Github = function(options) {\n\n    // HTTP Request Abstraction\n    // =======\n    //\n    // I'm not proud of this and neither should you be if you were responsible for the XMLHttpRequest spec.\n\n    function _request(method, path, data, cb, raw) {\n      function getURL() {\n        var url = path.indexOf('//') >= 0 ? path : API_URL + path;\n        return url + ((/\\?/).test(url) ? \"&\" : \"?\") + (new Date()).getTime();\n      }\n\n      var xhr = new XMLHttpRequest();\n      if (!raw) {xhr.dataType = \"json\";}\n\n      xhr.open(method, getURL());\n      xhr.onreadystatechange = function () {\n        if (this.readyState == 4) {\n          if (this.status >= 200 && this.status < 300 || this.status === 304) {\n            cb(null, raw ? this.responseText : this.responseText ? JSON.parse(this.responseText) : true, this);\n          } else {\n            cb({path: path, request: this, error: this.status});\n          }\n        }\n      };\n      xhr.setRequestHeader('Accept','application/json');\n      xhr.setRequestHeader('Content-Type','application/json');\n      if ( (options.token) || (options.username && options.password)) {\n           xhr.setRequestHeader('Authorization', options.token\n             ? 'token '+ options.token\n             : 'Basic ' + Base64.encode(options.username + ':' + options.password)\n           );\n         }\n      data ? xhr.send(JSON.stringify(data)) : xhr.send();\n    }\n\n    function _requestAllPages(path, cb) {\n      var results = [];\n      (function iterate() {\n        _request(\"GET\", path, null, function(err, res, xhr) {\n          if (err) {\n            return cb(err);\n          }\n\n          results.push.apply(results, res);\n\n          var links = (xhr.getResponseHeader('link') || '').split(/\\s*,\\s*/g),\n              next = _.find(links, function(link) { return /rel=\"next\"/.test(link); });\n\n          if (next) {\n            next = (/<(.*)>/.exec(next) || [])[1];\n          }\n\n          if (!next) {\n            cb(err, results);\n          } else {\n            path = next;\n            iterate();\n          }\n        });\n      })();\n    }\n\n\n\n    // User API\n    // =======\n\n    Github.User = function() {\n      this.repos = function(cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/user/repos?type=all&per_page=1000&sort=updated\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List user organizations\n      // -------\n\n      this.orgs = function(cb) {\n        _request(\"GET\", \"/user/orgs\", null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List authenticated user's gists\n      // -------\n\n      this.gists = function(cb) {\n        _request(\"GET\", \"/gists\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // List authenticated user's unread notifications\n      // -------\n\n      this.notifications = function(cb) {\n        _request(\"GET\", \"/notifications\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // Show user information\n      // -------\n\n      this.show = function(username, cb) {\n        var command = username ? \"/users/\"+username : \"/user\";\n\n        _request(\"GET\", command, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List user repositories\n      // -------\n\n      this.userRepos = function(username, cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/users/\"+username+\"/repos?type=all&per_page=1000&sort=updated\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List a user's gists\n      // -------\n\n      this.userGists = function(username, cb) {\n        _request(\"GET\", \"/users/\"+username+\"/gists\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // List organization repositories\n      // -------\n\n      this.orgRepos = function(orgname, cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/orgs/\"+orgname+\"/repos?type=all&&page_num=1000&sort=updated&direction=desc\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Follow user\n      // -------\n\n      this.follow = function(username, cb) {\n        _request(\"PUT\", \"/user/following/\"+username, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Unfollow user\n      // -------\n\n      this.unfollow = function(username, cb) {\n        _request(\"DELETE\", \"/user/following/\"+username, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Create a repo\n      // -------\n      this.createRepo = function(options, cb) {\n        _request(\"POST\", \"/user/repos\", options, cb);\n      };\n\n\n\n\n\n    };\n\n\n    // Repository API\n    // =======\n\n    Github.Repository = function(options) {\n      var repo = options.name;\n      var user = options.user;\n\n      var that = this;\n      var repoPath = \"/repos/\" + user + \"/\" + repo;\n\n      var currentTree = {\n        \"branch\": null,\n        \"sha\": null\n      };\n\n\n      // Delete a repo\n      // --------\n\n      this.deleteRepo = function(cb) {\n        _request(\"DELETE\", repoPath, options, cb);\n      };\n\n      // Uses the cache if branch has not been changed\n      // -------\n\n      function updateTree(branch, cb) {\n        if (branch === currentTree.branch && currentTree.sha) return cb(null, currentTree.sha);\n        that.getRef(\"heads/\"+branch, function(err, sha) {\n          currentTree.branch = branch;\n          currentTree.sha = sha;\n          cb(err, sha);\n        });\n      }\n\n      // Get a particular reference\n      // -------\n\n      this.getRef = function(ref, cb) {\n        _request(\"GET\", repoPath + \"/git/refs/\" + ref, null, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.object.sha);\n        });\n      };\n\n      // Create a new reference\n      // --------\n      //\n      // {\n      //   \"ref\": \"refs/heads/my-new-branch-name\",\n      //   \"sha\": \"827efc6d56897b048c772eb4087f854f46256132\"\n      // }\n\n      this.createRef = function(options, cb) {\n        _request(\"POST\", repoPath + \"/git/refs\", options, cb);\n      };\n\n      // Delete a reference\n      // --------\n      //\n      // repo.deleteRef('heads/gh-pages')\n      // repo.deleteRef('tags/v1.0')\n\n      this.deleteRef = function(ref, cb) {\n        _request(\"DELETE\", repoPath + \"/git/refs/\"+ref, options, cb);\n      };\n\n      // List all branches of a repository\n      // -------\n\n      this.listBranches = function(cb) {\n        _request(\"GET\", repoPath + \"/git/refs/heads\", null, function(err, heads) {\n          if (err) return cb(err);\n          cb(null, _.map(heads, function(head) { return _.last(head.ref.split('/')); }));\n        });\n      };\n\n      // List all tags of a repository\n      // -------\n\n      this.listTags = function(cb) {\n        _request(\"GET\", repoPath + \"/tags\", null, function(err, tags) {\n          if (err) return cb(err);\n          cb(null, tags);\n        });\n      };\n\n      // List all pull requests of a respository\n      // -------\n\n      this.listPulls = function(state, cb) {\n        if (_.isFunction(state)) {\n          cb = state;\n          state = undefined;\n        }\n\n        _request(\"GET\", repoPath + \"/pulls\" + (state ? '?state=' + state : ''), null, function(err, pulls) {\n          if (err) return cb(err);\n          cb(null, pulls);\n        });\n      };\n\n      // Gets details for a specific pull request\n      // -------\n\n      this.getPull = function(number, cb) {\n        _request(\"GET\", repoPath + \"/pulls/\" + number, null, function(err, pull) {\n          if (err) return cb(err);\n          cb(null, pull);\n        });\n      };\n\n      // List all issues of a respository\n      // -------\n\n      this.listIssues = function(options, cb) {\n        if (_.isFunction(options)) {\n          cb = options;\n          options = undefined;\n        }\n\n        var params = _.map(options, function(value, key) {\n          return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n        }).join('&');\n\n        _request(\"GET\", repoPath + \"/issues\" + (params ? \"?\" + params : \"\"), null, function(err, issues) {\n          if (err) return cb(err);\n          cb(null, issues);\n        });\n      },\n\n\n      // Retrieve the changes made between base and head\n      // -------\n\n      this.compare = function(base, head, cb) {\n        _request(\"GET\", repoPath + \"/compare/\" + base + \"...\" + head, null, function(err, diff) {\n          if (err) return cb(err);\n          cb(null, diff);\n        });\n      };\n\n      // Retrieve the contents of a blob\n      // -------\n\n      this.getBlob = function(sha, cb) {\n        _request(\"GET\", repoPath + \"/git/blobs/\" + sha, null, cb, 'raw');\n      };\n\n      // For a given file path, get the corresponding sha (blob for files, tree for dirs)\n      // -------\n\n      this.getSha = function(branch, path, cb) {\n        if (!path || path === \"\") return that.getRef(\"heads/\"+branch, cb);\n        _request(\"GET\", repoPath + \"/contents/\"+path, {ref: branch}, function(err, pathContent) {\n          if (err) return cb(err);\n          cb(null, pathContent.sha);\n        });\n      };\n\n      // Retrieve the tree a commit points to\n      // -------\n\n      this.getTree = function(tree, cb) {\n        _request(\"GET\", repoPath + \"/git/trees/\"+tree, null, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.tree);\n        });\n      };\n\n      // Post a new blob object, getting a blob SHA back\n      // -------\n\n      this.postBlob = function(content, cb) {\n        if (typeof(content) === \"string\") {\n          content = {\n            \"content\": content,\n            \"encoding\": \"utf-8\"\n          };\n        }\n\n        _request(\"POST\", repoPath + \"/git/blobs\", content, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Update an existing tree adding a new blob object getting a tree SHA back\n      // -------\n\n      this.updateTree = function(baseTree, path, blob, cb) {\n        var data = {\n          \"base_tree\": baseTree,\n          \"tree\": [\n            {\n              \"path\": path,\n              \"mode\": \"100644\",\n              \"type\": \"blob\",\n              \"sha\": blob\n            }\n          ]\n        };\n        _request(\"POST\", repoPath + \"/git/trees\", data, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Post a new tree object having a file path pointer replaced\n      // with a new blob SHA getting a tree SHA back\n      // -------\n\n      this.postTree = function(tree, cb) {\n        _request(\"POST\", repoPath + \"/git/trees\", { \"tree\": tree }, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Create a new commit object with the current commit SHA as the parent\n      // and the new tree SHA, getting a commit SHA back\n      // -------\n\n      this.commit = function(parent, tree, message, cb) {\n        var data = {\n          \"message\": message,\n          \"author\": {\n            \"name\": options.username\n          },\n          \"parents\": [\n            parent\n          ],\n          \"tree\": tree\n        };\n\n        _request(\"POST\", repoPath + \"/git/commits\", data, function(err, res) {\n          currentTree.sha = res.sha; // update latest commit\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Update the reference of your head to point to the new commit SHA\n      // -------\n\n      this.updateHead = function(head, commit, cb) {\n        _request(\"PATCH\", repoPath + \"/git/refs/heads/\" + head, { \"sha\": commit }, function(err, res) {\n          cb(err);\n        });\n      };\n\n      // Show repository information\n      // -------\n\n      this.show = function(cb) {\n        _request(\"GET\", repoPath, null, cb);\n      };\n\n      // Get contents\n      // --------\n\n      this.contents = function(ref, path, cb) {\n        _request(\"GET\", repoPath + \"/contents/\"+path, { ref: ref }, cb);\n      };\n\n      // Fork repository\n      // -------\n\n      this.fork = function(cb) {\n        _request(\"POST\", repoPath + \"/forks\", null, cb);\n      };\n\n      // Create pull request\n      // --------\n\n      this.createPullRequest = function(options, cb) {\n        _request(\"POST\", repoPath + \"/pulls\", options, cb);\n      };\n\n      // List hooks\n      // --------\n\n      this.listHooks = function(cb) {\n        _request(\"GET\", repoPath + \"/hooks\", null, cb);\n      };\n\n      // Get a hook\n      // --------\n\n      this.getHook = function(id, cb) {\n        _request(\"GET\", repoPath + \"/hooks/\" + id, null, cb);\n      };\n\n      // Create a hook\n      // --------\n\n      this.createHook = function(options, cb) {\n        _request(\"POST\", repoPath + \"/hooks\", options, cb);\n      };\n\n      // Edit a hook\n      // --------\n\n      this.editHook = function(id, options, cb) {\n        _request(\"PATCH\", repoPath + \"/hooks/\" + id, options, cb);\n      };\n\n      // Delete a hook\n      // --------\n\n      this.deleteHook = function(id, cb) {\n        _request(\"DELETE\", repoPath + \"/hooks/\" + id, null, cb);\n      };\n\n      // Read file at given path\n      // -------\n\n      this.read = function(branch, path, cb) {\n        _request(\"GET\", repoPath + \"/contents/\"+path, {ref: branch}, function(err, obj) {\n          if (err && err.error === 404) return cb(\"not found\", null, null);\n\n          if (err) return cb(err);\n          var sha = obj.sha\n            , content = Base64.decode(obj.content);\n\n          cb(null, content, sha);\n        });\n      };\n\n\n      // Remove a file\n      // -------\n\n      this.remove = function(branch, path, cb) {\n        that.getSha(branch, path, function(err, sha) {\n          if (err) return cb(err);\n          _request(\"DELETE\", repoPath + \"/contents/\" + path, {\n            message: path + \" is removed\",\n            sha: sha,\n            branch: branch\n          }, cb);\n        });\n      };\n\n      // Move a file to a new location\n      // -------\n\n      this.move = function(branch, path, newPath, cb) {\n        updateTree(branch, function(err, latestCommit) {\n          that.getTree(latestCommit+\"?recursive=true\", function(err, tree) {\n            // Update Tree\n            _.each(tree, function(ref) {\n              if (ref.path === path) ref.path = newPath;\n              if (ref.type === \"tree\") delete ref.sha;\n            });\n\n            that.postTree(tree, function(err, rootTree) {\n              that.commit(latestCommit, rootTree, 'Deleted '+path , function(err, commit) {\n                that.updateHead(branch, commit, function(err) {\n                  cb(err);\n                });\n              });\n            });\n          });\n        });\n      };\n\n      // Write file contents to a given branch and path\n      // -------\n\n      this.write = function(branch, path, content, message, cb) {\n        that.getSha(branch, path, function(err, sha) {\n          if (err && err.error!=404) return cb(err);\n          _request(\"PUT\", repoPath + \"/contents/\" + path, {\n            message: message,\n            content: Base64.encode(content),\n            branch: branch,\n            sha: sha\n          }, cb);\n        });\n      };\n\n    };\n\n    // Gists API\n    // =======\n\n    Github.Gist = function(options) {\n      var id = options.id;\n      var gistPath = \"/gists/\"+id;\n\n      // Read the gist\n      // --------\n\n      this.read = function(cb) {\n        _request(\"GET\", gistPath, null, function(err, gist) {\n          cb(err, gist);\n        });\n      };\n\n      // Create the gist\n      // --------\n      // {\n      //  \"description\": \"the description for this gist\",\n      //    \"public\": true,\n      //    \"files\": {\n      //      \"file1.txt\": {\n      //        \"content\": \"String file contents\"\n      //      }\n      //    }\n      // }\n\n      this.create = function(options, cb){\n        _request(\"POST\",\"/gists\", options, cb);\n      };\n\n      // Delete the gist\n      // --------\n\n      this.delete = function(cb) {\n        _request(\"DELETE\", gistPath, null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Fork a gist\n      // --------\n\n      this.fork = function(cb) {\n        _request(\"POST\", gistPath+\"/fork\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Update a gist with the new stuff\n      // --------\n\n      this.update = function(options, cb) {\n        _request(\"PATCH\", gistPath, options, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Star a gist\n      // --------\n\n      this.star = function(cb) {\n        _request(\"PUT\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Untar a gist\n      // --------\n\n      this.unstar = function(cb) {\n        _request(\"DELETE\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Check if a gist is starred\n      // --------\n\n      this.isStarred = function(cb) {\n        _request(\"GET\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n    };\n\n    // Top Level API\n    // -------\n\n    this.getRepo = function(user, repo) {\n      return new Github.Repository({user: user, name: repo});\n    };\n\n    this.getUser = function() {\n      return new Github.User();\n    };\n\n    this.getGist = function(id) {\n      return new Github.Gist({id: id});\n    };\n  };\n\n\n  if (typeof exports !== 'undefined') {\n    // Github = exports;\n    module.exports = Github;\n  } else {\n    window.Github = Github;\n  }\n}).call(this);\n\n(function() {\n  this.Sandbox = function(_arg) {\n    var height, methods, name, sandbox, width, _ref;\n    _ref = _arg != null ? _arg : {}, name = _ref.name, width = _ref.width, height = _ref.height, methods = _ref.methods;\n    if (name == null) {\n      name = \"sandbox\" + new Date;\n    }\n    if (width == null) {\n      width = 800;\n    }\n    if (height == null) {\n      height = 600;\n    }\n    if (methods == null) {\n      methods = {};\n    }\n    sandbox = window.open(\"\", name, \"width=\" + width + \",height=\" + height);\n    Object.extend(sandbox, methods);\n    return sandbox;\n  };\n\n}).call(this);\n\n(function() {\n  this.TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var commit, publish;\n\n  publish = function(_arg) {\n    var branch, builder, fileData, message, owner, path, publishBranch, repo;\n    builder = _arg.builder, fileData = _arg.fileData, repo = _arg.repo, owner = _arg.owner, branch = _arg.branch;\n    if (branch == null) {\n      branch = \"master\";\n    }\n    message = \"Built \" + branch + \" in browser in strd6.github.io/tempest\";\n    if (branch === \"master\") {\n      path = \"index.html\";\n    } else {\n      path = \"\" + branch + \".html\";\n    }\n    publishBranch = \"gh-pages\";\n    return builder.build(fileData, function(fileMap) {\n      return Gistquire.writeFile({\n        repo: repo,\n        owner: owner,\n        path: path,\n        content: Base64.encode(builder.standAloneHtml(fileMap)),\n        branch: publishBranch,\n        message: message\n      });\n    });\n  };\n\n  commit = function(_arg) {\n    var branch, fileData, message, owner, repo;\n    fileData = _arg.fileData, repo = _arg.repo, owner = _arg.owner, branch = _arg.branch, message = _arg.message;\n    return Gistquire.commitTree({\n      owner: owner,\n      repo: repo,\n      tree: fileData,\n      message: message\n    });\n  };\n\n  this.Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    }\n  };\n\n}).call(this);\n\n(function() {\n  var $root, actions, branch, builder, errors, files, filetree, github, loadId, notices, repo, repoName, styleContent, userName, _ref, _ref1;\n\n  files = ENV.files;\n\n  window.ENV = ENV;\n\n  $root = $('body');\n\n  if (styleContent = (_ref = files[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  Gistquire.onload();\n\n  github = new Github({\n    auth: \"oauth\",\n    token: localStorage.authToken\n  });\n\n  branch = \"master\";\n\n  userName = \"STRd6\";\n\n  repoName = \"editor\";\n\n  repo = null;\n\n  errors = Observable([]);\n\n  notices = Observable([\"Loaded!\"]);\n\n  builder = Builder({\n    errors: errors,\n    notices: notices\n  });\n\n  actions = {\n    save: function() {\n      notices([\"Saving...\"]);\n      return Actions.save({\n        owner: userName,\n        repo: repoName,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        return notices([\"Saved and published!\"]);\n      });\n    },\n    \"new\": function() {\n      var name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        return filetree.files.push(File({\n          filename: name,\n          content: \"\"\n        }));\n      }\n    },\n    run: (function() {\n      notices([\"Building...\"]);\n      return builder.build(filetree.data(), function(fileMap) {\n        var config, sandbox;\n        if (fileMap[\"pixie.json\"]) {\n          config = JSON.parse(fileMap[\"pixie.json\"].content);\n        } else {\n          config = {};\n        }\n        sandbox = Sandbox({\n          width: config.width,\n          height: config.height\n        });\n        sandbox.document.open();\n        sandbox.document.write(builder.standAloneHtml(fileMap));\n        sandbox.document.close();\n        notices([\"Runnnig!\"]);\n        errors([]);\n        return {\n          error: errors\n        };\n      });\n    }).debounce(250),\n    load_repo: function() {\n      var processDirectory, _ref1;\n      repoName = prompt(\"Github repo\", \"STRd6/matrix.js\");\n      if (repoName) {\n        _ref1 = repoName.split(\"/\"), userName = _ref1[0], repoName = _ref1[1];\n      } else {\n        errors([\"No repo given\"]);\n        return;\n      }\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      return Gistquire.latestTree({\n        branch: \"master\",\n        repo: repoName,\n        owner: userName,\n        success: function(data) {\n          var treeFiles;\n          notices([]);\n          treeFiles = data.tree.select(function(file) {\n            return file.type === \"blob\";\n          });\n          return async.map(treeFiles, function(datum, callback) {\n            return Gistquire.api(datum.url, {\n              success: function(data) {\n                return callback(null, Object.extend(datum, data));\n              },\n              error: function(error) {\n                return callback(error);\n              }\n            });\n          }, function(error, results) {\n            notices([\"Radical!\"]);\n            if (error) {\n              errors([error]);\n              return;\n            }\n            files = processDirectory(results);\n            notices([files].map(function(item) {\n              return JSON.stringify(item, null, 2);\n            }));\n            return filetree.load(files);\n          });\n        },\n        error: function(error) {\n          return errors([error]);\n        }\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.templates.editor());\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        return file.content(value);\n      });\n    }\n  });\n\n  $root.append(HAMLjr.templates.main({\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors\n  }));\n\n  Gistquire.api(\"rate_limit\", {\n    complete: function(request, status) {\n      return $root.append(HAMLjr.templates.github_status({\n        request: request\n      }));\n    }\n  });\n\n  if (loadId = (_ref1 = window.location.href.match(/loadId=(\\d+)/)) != null ? _ref1[1] : void 0) {\n    actions.load(null, loadId);\n  }\n\n}).call(this);\n")({
    files: {"TODO":{"path":"TODO","mode":"100644","content":"TODO\n----\nFirst auth doesn't display in bar\nAuth redirects to /tempest rather than /editor\n\nCombine commit/publish step\n- master branch should publish to index.html\n- other branches should publish to <branch>.html\n- Published branch is always latest\n\nOrganize File tree by type\nFile icons\n\nSaving UTF8 Characters gets messed up\n\nIntegrate with Github Issues\n\nDisplay Diffs\n\nLive Update Demo\n- Display Demo Runtime Errors in console\n\nOpen published page in editor and run live demo with same state as when editor was opened\n- Pass git repo/branch metadata to published page for use in editor\n\nPersist state across demo reloads\n\n.haml and .styl file type support\n- Build our own ace cdn\n\nTests\n\nDelete Files\n\nCache Git trees and files in some form of local storage\n\nEditor plugins\n- static analysis\n- find in files\n\nDONE\n----\nDon't pass directories to filetree\n\nSaving repos with folders\n\nLoad file data better\n- Handle folders in repos\n\nHandle file types per extension\n\nSave back to repo from gh-pages demo build\n\nUse editor repo as the default rather than the gist\n- Boot from built gh-pages html files.\n\nDeploy a packaged app to gh-pages\n- html page named for branch/sha and with source included\n\nLoad from actual git repos\nSave changes back to real git repos\n\nVisualize Rate Limit Remaining\n\nMake errors like notices\nDisplay Auth Scopes\nDo not compile build.js if no js files\n\nMove Gistquire to editor\nMaintain editor state across open files\nError Log styles\nTell ace not to use worker becaues it fails to load cross domain","type":"blob"},"actions.haml":{"path":"actions.haml","mode":"100644","content":".actions\n  - actions = this\n  - Object.keys(actions).each (name) ->\n    %button\n      = name.titleize()\n      - on \"click\", actions[name]\n","type":"blob"},"async.js":{"path":"async.js","mode":"100644","content":"/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","type":"blob"},"base64.js":{"path":"base64.js","mode":"100644","content":"(function() {\n  // Lookup arrays for base64 conversions\n  var enc64List, dec64List;\n  // Load the lookup arrays once\n  (function() {\n      enc64List = new Array();\n      dec64List = new Array();\n      var i;\n      for (i = 0; i < 26; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(65 + i);\n      }\n      for (i = 0; i < 26; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(97 + i);\n      }\n      for (i = 0; i < 10; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(48 + i);\n      }\n      enc64List[enc64List.length] = \"+\";\n      enc64List[enc64List.length] = \"/\";\n      for (i = 0; i < 128; i++) {\n          dec64List[dec64List.length] = -1;\n      }\n      for (i = 0; i < 64; i++) {\n          dec64List[enc64List[i].charCodeAt(0)] = i;\n      }\n  })();\n\n  window.Base64 = {\n    encode: function(str) {\n        var c, d, e, end = 0;\n        var u, v, w, x;\n        var ptr = -1;\n        var input = str.split(\"\");\n        var output = \"\";\n        while(end == 0) {\n            c = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end = 1) ? 0 : 0);\n            d = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end += 1) ? 0 : 0);\n            e = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end += 1) ? 0 : 0);\n            u = enc64List[c >> 2];\n            v = enc64List[(0x00000003 & c) << 4 | d >> 4];\n            w = enc64List[(0x0000000F & d) << 2 | e >> 6];\n            x = enc64List[e & 0x0000003F];\n\n            // handle padding to even out unevenly divisible string lengths\n            if (end >= 1) {x = \"=\";}\n            if (end == 2) {w = \"=\";}\n\n            if (end < 3) {output += u + v + w + x;}\n        }\n        return output;\n    },\n\n    decode: function(str) {\n        var c=0, d=0, e=0, f=0, i=0, n=0;\n        var input = str.split(\"\");\n        var output = \"\";\n        var ptr = 0;\n        do {\n            f = input[ptr++].charCodeAt(0);\n            i = dec64List[f];\n            if ( f >= 0 && f < 128 && i != -1 ) {\n                if ( n % 4 == 0 ) {\n                    c = i << 2;\n                } else if ( n % 4 == 1 ) {\n                    c = c | ( i >> 4 );\n                    d = ( i & 0x0000000F ) << 4;\n                } else if ( n % 4 == 2 ) {\n                    d = d | ( i >> 2 );\n                    e = ( i & 0x00000003 ) << 6;\n                } else {\n                    e = e | i;\n                }\n                n++;\n                if ( n % 4 == 0 ) {\n                    output += String.fromCharCode(c) +\n                              String.fromCharCode(d) +\n                              String.fromCharCode(e);\n                }\n            }\n        }\n        while (typeof input[ptr] != \"undefined\");\n        output += (n % 4 == 3) ? String.fromCharCode(c) + String.fromCharCode(d) :\n                  ((n % 4 == 2) ? String.fromCharCode(c) : \"\");\n        return output;\n    }\n  };\n}());\n","type":"blob"},"builder.coffee":{"path":"builder.coffee","mode":"100644","content":"@Builder = (I={}) ->\n  compileTemplate = (source, name=\"test\") ->\n    ast = HAMLjr.parser.parse(source)\n    \n    HAMLjr.compile ast, \n      name: name\n      compiler: CoffeeScript\n  \n  build = (fileData) ->\n    templates = []\n    models = []\n    main = \"\"\n    errors = []\n  \n    fileData.each ({path, content}) ->\n      name = path.split('/').last()\n      source = content\n\n      try\n        if name.extension() is \"haml\"\n          templates.push compileTemplate(source, name.withoutExtension())\n        else if name.extension() is \"js\"\n          if name is \"main.js\"\n            main = source\n          else if name is \"build.js\"\n            # Do nothing\n          else\n            models.push source\n        else if name.extension() is \"coffee\"\n          if name is \"main.coffee\"\n            main = CoffeeScript.compile(source)\n          else\n            models.push CoffeeScript.compile(source)\n      catch error\n        errors.push error.stack\n  \n    errors: errors\n    result: \"\"\"\n        #{templates.join(\"\\n\")}\n        #{models.join(\"\\n\")}\n        #{main}\n      \"\"\"\n  \n  buildStyle = (fileData) ->\n    styles = []\n    errors = []\n    \n    fileData.each ({path, content}) ->\n      try\n        if path.extension() is \"styl\"\n          styles.push styl(content, whitespace: true).toString()\n      catch error\n        errors.push error.stack\n  \n    errors: errors\n    result: styles.join(\"\\n\")\n    \n  build: (fileData, callback) ->\n    I.notices.push \"Building...\"\n    \n    {errors:collectedErrors, result:compileResult} = build(fileData)\n\n    {errors, result} = buildStyle(fileData)\n    collectedErrors = collectedErrors.concat(errors)\n\n    if compileResult.trim() != \"\"\n      fileData.push\n        path: \"build.js\"\n        content: compileResult\n        type: \"blob\"\n\n    if result != \"\"\n      fileData.push\n        path: \"style.css\"\n        content: result\n        type: \"blob\"\n\n    if collectedErrors.length\n      I.errors?(collectedErrors)\n    else\n      fileMap = fileData.eachWithObject {}, (file, hash) ->\n        hash[file.path] = file\n\n      callback(fileMap)\n\n  standAloneHtml: (fileMap) ->\n    # TODO: Get these from a more robust method than just script tags with classes\n    content = $('script.env').map ->\n      @outerHTML\n    .get()\n  \n    entryPoint = \"build.js\"\n    program = fileMap[entryPoint].content\n  \n    # TODO: Think about nesting, components\n    # TODO?: Exclude build.js from files\n    content.push \"\"\"<body><script>\n      Function(\"ENV\", #{JSON.stringify(program)})({\n        files: #{JSON.stringify(fileMap)}\n      });\n    <\\/script>\"\"\"\n    \n    content.join \"\\n\"\n","type":"blob"},"editor.haml":{"path":"editor.haml","mode":"100644","content":".editor-wrap\n  .editor\n","type":"blob"},"errors.haml":{"path":"errors.haml","mode":"100644","content":".console-wrap\n  %pre.errors\n    - each @errors, (error) ->\n      = error\n  %pre.notices\n    - each @notices, (notice) ->\n      = notice\n","type":"blob"},"file.coffee":{"path":"file.coffee","mode":"100644","content":"@File = (I={}) ->\n  I.path ?= I.filename\n  I.filename ?= I.path.split(\"/\").last()\n\n  self = Model(I).observeAll()\n\n  self.extend\n    extension: ->\n      self.filename().extension()\n\n    mode: ->\n      switch extension = self.extension()\n        when \"js\"\n          \"javascript\"\n        else\n          extension\n\n  return self\n","type":"blob"},"filetree.coffee":{"path":"filetree.coffee","mode":"100644","content":"@Filetree = (I={}) ->\n  Object.defaults I,\n    files: []\n\n  self = Model(I).observeAll()\n\n  self.attrObservable \"selectedFile\"\n\n  self.extend\n    load: (fileData) ->\n      files = Object.keys(fileData).sort().map (name) ->\n        File fileData[name]\n\n      self.files(files)\n\n    data: ->\n      self.files.map (file) ->\n        path: file.filename()\n        mode: \"100644\"\n        content: file.content()\n        type: \"blob\"\n\n  return self\n","type":"blob"},"filetree.haml":{"path":"filetree.haml","mode":"100644","content":"%ul.filetree\n  - selectedFile = @selectedFile\n  - each @files, (file) ->\n    %li= file.path\n      - on \"click\", -> selectedFile(file)\n","type":"blob"},"gist_list.haml":{"path":"gist_list.haml","mode":"100644","content":"%ul.gists\n  - each @gists, (gist) ->\n    %li= gist.id\n      - on \"click\", ->\n        - alert gist.id\n","type":"blob"},"gistquire.coffee":{"path":"gistquire.coffee","mode":"100644","content":"@Gistquire =\n  accessToken: null\n\n  # Calling auth will redirect to github for authentication\n  auth: ->\n    scope = \"gist,repo,user:email\"\n    url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=#{scope}\"\n\n    window.location = url\n\n  # Call onload to check for the code returned from github authentication\n  # and to get our access token from our authorization app.\n  onload: ->\n    # TODO: Namespace local storage key\n\n    if code = window.location.href.match(/\\?code=(.*)/)?[1]\n      $.getJSON \"https://hamljr-auth.herokuapp.com/authenticate/#{code}\", (data) =>\n        if token = data.token\n          @accessToken = token\n          localStorage.authToken = token\n\n    if localStorage.authToken\n      @accessToken = localStorage.authToken\n\n  update: (id, {data, success, error}) ->\n    url = \"https://api.github.com/gists/#{id}\"\n\n    if @accessToken\n      url += \"?access_token=#{@accessToken}\"\n\n    $.ajax\n      url: url\n      type: \"PATCH\"\n      dataType: 'json'\n      data: JSON.stringify(data)\n      success: success\n      error: error\n\n  create: (data, callback) ->\n    url = \"https://api.github.com/gists\"\n\n    if @accessToken\n      url += \"?access_token=#{@accessToken}\"\n\n    $.ajax\n      url: url\n      type: \"POST\"\n      dataType: 'json'\n      data: JSON.stringify(data)\n      success: callback\n\n  get: (id, callback) ->\n    @api \"gists/#{id}\",\n      success: callback\n\n  api: (path, options={}) ->\n    if path.match /^http/\n      url = path\n    else\n      url = \"https://api.github.com/#{path}\"\n    \n    options.headers ||= {}\n    \n    if @accessToken\n      options.headers[\"Authorization\"] = \"token #{@accessToken}\"\n\n    options = Object.extend\n      url: url\n      type: \"GET\"\n      dataType: 'json'\n    , options\n\n    $.ajax options\n\n  initPagesBranch: ({owner, repo, success, error}) ->\n    success ?= ->\n    error ?= ->\n    branch = \"gh-pages\"\n  \n    unless owner and repo\n      throw Error(\"Must pass in an owner and a repo\")\n  \n    # Post an empty tree to use for the base commit\n    # TODO: Learn how to post an empty tree\n    Gistquire.api \"repos/#{owner}/#{repo}/git/trees\",\n      type: \"POST\"\n      data: JSON.stringify\n        tree: [{\n          mode: \"1006444\"\n          path: \"tempest.txt\"\n          content: \"created by strd6.github.io/tempest\"\n        }]\n      success: (data) ->\n        # Create the base commit for the branch\n        Gistquire.api \"repos/#{owner}/#{repo}/git/commits\",\n          type: \"POST\"\n          data: JSON.stringify\n            message: \"Initial gh-pages commit\"\n            tree: data.sha\n          success: (data) ->\n            # Create the branch based on the base commit\n            Gistquire.api \"repos/#{owner}/#{repo}/git/refs\",\n              type: \"POST\"\n              data: JSON.stringify\n                ref: \"refs/heads/#{branch}\"\n                sha: data.sha\n              success: success\n              error: error\n          error: error\n      error: error\n\n  writeFile: ({owner, repo, branch, path, content, message, success, error}) ->\n    success ?= ->\n    error ?= ->\n    \n    Gistquire.api \"repos/#{owner}/#{repo}/contents/#{path}\",\n      data:\n        ref: branch\n      success: (data) ->\n        Gistquire.api \"repos/#{owner}/#{repo}/contents/#{path}\",\n          type: \"PUT\"\n          data: JSON.stringify\n            content: content\n            sha: data.sha\n            message: message\n            branch: branch\n          success: success\n          error: error\n      error: (request) ->\n        if request.status is 404\n          Gistquire.api \"repos/#{owner}/#{repo}/contents/#{path}\",\n            type: \"PUT\"\n            data: JSON.stringify\n              content: content\n              message: message\n              branch: branch\n            success: success\n            error: error\n        else\n          error(arguments...)\n\n  commitTree: ({owner, repo, branch, message, tree, success, error}) ->\n    success ?= ->\n    error ?= ->\n    branch ?= \"master\"\n    message ?= \"Updated in browser at strd6.github.io/editor\"\n    \n    unless owner and repo and tree\n      throw Error(\"Must pass in an owner, a tree, and a repo\")\n      \n    Gistquire.api \"repos/#{owner}/#{repo}/git/refs/heads/#{branch}\",\n      success: (data) ->\n        latestCommitSha = data.object.sha\n        \n        Gistquire.api \"repos/#{owner}/#{repo}/git/trees\",\n          type: \"POST\"\n          data: JSON.stringify\n            tree: tree\n          success: (data) ->\n            # Create another commit\n            Gistquire.api \"repos/#{owner}/#{repo}/git/commits\",\n              type: \"POST\"\n              data: JSON.stringify\n                parents: [latestCommitSha]\n                message: message\n                tree: data.sha\n              success: (data) ->\n                # Update the branch head\n                Gistquire.api \"repos/#{owner}/#{repo}/git/refs/heads/#{branch}\",\n                  type: \"PATCH\"\n                  data: JSON.stringify\n                    sha: data.sha\n                  success: success\n                  error: error\n              error: error\n          error: error\n      error: error\n  \n  latestTree: ({owner, repo, branch, success, error}) ->\n    success ?= ->\n    error ?= ->\n    branch ?= \"master\"\n    \n    Gistquire.api \"repos/#{owner}/#{repo}/git/refs/heads/#{branch}\",\n      success: (data) ->        \n        Gistquire.api data.object.url,\n          success: (data) ->\n            Gistquire.api \"#{data.tree.url}?recursive=1\",\n              success: success\n              error: error\n          error: error\n      error: error\n","type":"blob"},"github.js":{"path":"github.js","mode":"100644","content":"// Github.js 0.8.0\n// (c) 2013 Michael Aufreiter, Development Seed\n// Github.js is freely distributable under the MIT license.\n// For all details and documentation:\n// http://substance.io/michael/github\n\n(function() {\n\n  // Initial Setup\n  // -------------\n\n  var XMLHttpRequest, Base64, _;\n  if (typeof exports !== 'undefined') {\n      XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n      _ = require('underscore');\n      Base64 = require('./lib/base64.js');\n  }else{\n      _ = window._;\n      Base64 = window.Base64;\n  }\n  //prefer native XMLHttpRequest always\n  if (typeof window !== 'undefined' && typeof window.XMLHttpRequest !== 'undefined'){\n      XMLHttpRequest = window.XMLHttpRequest;\n  }\n\n\n  var API_URL = 'https://api.github.com';\n\n  var Github = function(options) {\n\n    // HTTP Request Abstraction\n    // =======\n    //\n    // I'm not proud of this and neither should you be if you were responsible for the XMLHttpRequest spec.\n\n    function _request(method, path, data, cb, raw) {\n      function getURL() {\n        var url = path.indexOf('//') >= 0 ? path : API_URL + path;\n        return url + ((/\\?/).test(url) ? \"&\" : \"?\") + (new Date()).getTime();\n      }\n\n      var xhr = new XMLHttpRequest();\n      if (!raw) {xhr.dataType = \"json\";}\n\n      xhr.open(method, getURL());\n      xhr.onreadystatechange = function () {\n        if (this.readyState == 4) {\n          if (this.status >= 200 && this.status < 300 || this.status === 304) {\n            cb(null, raw ? this.responseText : this.responseText ? JSON.parse(this.responseText) : true, this);\n          } else {\n            cb({path: path, request: this, error: this.status});\n          }\n        }\n      };\n      xhr.setRequestHeader('Accept','application/json');\n      xhr.setRequestHeader('Content-Type','application/json');\n      if ( (options.token) || (options.username && options.password)) {\n           xhr.setRequestHeader('Authorization', options.token\n             ? 'token '+ options.token\n             : 'Basic ' + Base64.encode(options.username + ':' + options.password)\n           );\n         }\n      data ? xhr.send(JSON.stringify(data)) : xhr.send();\n    }\n\n    function _requestAllPages(path, cb) {\n      var results = [];\n      (function iterate() {\n        _request(\"GET\", path, null, function(err, res, xhr) {\n          if (err) {\n            return cb(err);\n          }\n\n          results.push.apply(results, res);\n\n          var links = (xhr.getResponseHeader('link') || '').split(/\\s*,\\s*/g),\n              next = _.find(links, function(link) { return /rel=\"next\"/.test(link); });\n\n          if (next) {\n            next = (/<(.*)>/.exec(next) || [])[1];\n          }\n\n          if (!next) {\n            cb(err, results);\n          } else {\n            path = next;\n            iterate();\n          }\n        });\n      })();\n    }\n\n\n\n    // User API\n    // =======\n\n    Github.User = function() {\n      this.repos = function(cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/user/repos?type=all&per_page=1000&sort=updated\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List user organizations\n      // -------\n\n      this.orgs = function(cb) {\n        _request(\"GET\", \"/user/orgs\", null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List authenticated user's gists\n      // -------\n\n      this.gists = function(cb) {\n        _request(\"GET\", \"/gists\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // List authenticated user's unread notifications\n      // -------\n\n      this.notifications = function(cb) {\n        _request(\"GET\", \"/notifications\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // Show user information\n      // -------\n\n      this.show = function(username, cb) {\n        var command = username ? \"/users/\"+username : \"/user\";\n\n        _request(\"GET\", command, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List user repositories\n      // -------\n\n      this.userRepos = function(username, cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/users/\"+username+\"/repos?type=all&per_page=1000&sort=updated\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List a user's gists\n      // -------\n\n      this.userGists = function(username, cb) {\n        _request(\"GET\", \"/users/\"+username+\"/gists\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // List organization repositories\n      // -------\n\n      this.orgRepos = function(orgname, cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/orgs/\"+orgname+\"/repos?type=all&&page_num=1000&sort=updated&direction=desc\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Follow user\n      // -------\n\n      this.follow = function(username, cb) {\n        _request(\"PUT\", \"/user/following/\"+username, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Unfollow user\n      // -------\n\n      this.unfollow = function(username, cb) {\n        _request(\"DELETE\", \"/user/following/\"+username, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Create a repo\n      // -------\n      this.createRepo = function(options, cb) {\n        _request(\"POST\", \"/user/repos\", options, cb);\n      };\n\n\n\n\n\n    };\n\n\n    // Repository API\n    // =======\n\n    Github.Repository = function(options) {\n      var repo = options.name;\n      var user = options.user;\n\n      var that = this;\n      var repoPath = \"/repos/\" + user + \"/\" + repo;\n\n      var currentTree = {\n        \"branch\": null,\n        \"sha\": null\n      };\n\n\n      // Delete a repo\n      // --------\n\n      this.deleteRepo = function(cb) {\n        _request(\"DELETE\", repoPath, options, cb);\n      };\n\n      // Uses the cache if branch has not been changed\n      // -------\n\n      function updateTree(branch, cb) {\n        if (branch === currentTree.branch && currentTree.sha) return cb(null, currentTree.sha);\n        that.getRef(\"heads/\"+branch, function(err, sha) {\n          currentTree.branch = branch;\n          currentTree.sha = sha;\n          cb(err, sha);\n        });\n      }\n\n      // Get a particular reference\n      // -------\n\n      this.getRef = function(ref, cb) {\n        _request(\"GET\", repoPath + \"/git/refs/\" + ref, null, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.object.sha);\n        });\n      };\n\n      // Create a new reference\n      // --------\n      //\n      // {\n      //   \"ref\": \"refs/heads/my-new-branch-name\",\n      //   \"sha\": \"827efc6d56897b048c772eb4087f854f46256132\"\n      // }\n\n      this.createRef = function(options, cb) {\n        _request(\"POST\", repoPath + \"/git/refs\", options, cb);\n      };\n\n      // Delete a reference\n      // --------\n      //\n      // repo.deleteRef('heads/gh-pages')\n      // repo.deleteRef('tags/v1.0')\n\n      this.deleteRef = function(ref, cb) {\n        _request(\"DELETE\", repoPath + \"/git/refs/\"+ref, options, cb);\n      };\n\n      // List all branches of a repository\n      // -------\n\n      this.listBranches = function(cb) {\n        _request(\"GET\", repoPath + \"/git/refs/heads\", null, function(err, heads) {\n          if (err) return cb(err);\n          cb(null, _.map(heads, function(head) { return _.last(head.ref.split('/')); }));\n        });\n      };\n\n      // List all tags of a repository\n      // -------\n\n      this.listTags = function(cb) {\n        _request(\"GET\", repoPath + \"/tags\", null, function(err, tags) {\n          if (err) return cb(err);\n          cb(null, tags);\n        });\n      };\n\n      // List all pull requests of a respository\n      // -------\n\n      this.listPulls = function(state, cb) {\n        if (_.isFunction(state)) {\n          cb = state;\n          state = undefined;\n        }\n\n        _request(\"GET\", repoPath + \"/pulls\" + (state ? '?state=' + state : ''), null, function(err, pulls) {\n          if (err) return cb(err);\n          cb(null, pulls);\n        });\n      };\n\n      // Gets details for a specific pull request\n      // -------\n\n      this.getPull = function(number, cb) {\n        _request(\"GET\", repoPath + \"/pulls/\" + number, null, function(err, pull) {\n          if (err) return cb(err);\n          cb(null, pull);\n        });\n      };\n\n      // List all issues of a respository\n      // -------\n\n      this.listIssues = function(options, cb) {\n        if (_.isFunction(options)) {\n          cb = options;\n          options = undefined;\n        }\n\n        var params = _.map(options, function(value, key) {\n          return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n        }).join('&');\n\n        _request(\"GET\", repoPath + \"/issues\" + (params ? \"?\" + params : \"\"), null, function(err, issues) {\n          if (err) return cb(err);\n          cb(null, issues);\n        });\n      },\n\n\n      // Retrieve the changes made between base and head\n      // -------\n\n      this.compare = function(base, head, cb) {\n        _request(\"GET\", repoPath + \"/compare/\" + base + \"...\" + head, null, function(err, diff) {\n          if (err) return cb(err);\n          cb(null, diff);\n        });\n      };\n\n      // Retrieve the contents of a blob\n      // -------\n\n      this.getBlob = function(sha, cb) {\n        _request(\"GET\", repoPath + \"/git/blobs/\" + sha, null, cb, 'raw');\n      };\n\n      // For a given file path, get the corresponding sha (blob for files, tree for dirs)\n      // -------\n\n      this.getSha = function(branch, path, cb) {\n        if (!path || path === \"\") return that.getRef(\"heads/\"+branch, cb);\n        _request(\"GET\", repoPath + \"/contents/\"+path, {ref: branch}, function(err, pathContent) {\n          if (err) return cb(err);\n          cb(null, pathContent.sha);\n        });\n      };\n\n      // Retrieve the tree a commit points to\n      // -------\n\n      this.getTree = function(tree, cb) {\n        _request(\"GET\", repoPath + \"/git/trees/\"+tree, null, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.tree);\n        });\n      };\n\n      // Post a new blob object, getting a blob SHA back\n      // -------\n\n      this.postBlob = function(content, cb) {\n        if (typeof(content) === \"string\") {\n          content = {\n            \"content\": content,\n            \"encoding\": \"utf-8\"\n          };\n        }\n\n        _request(\"POST\", repoPath + \"/git/blobs\", content, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Update an existing tree adding a new blob object getting a tree SHA back\n      // -------\n\n      this.updateTree = function(baseTree, path, blob, cb) {\n        var data = {\n          \"base_tree\": baseTree,\n          \"tree\": [\n            {\n              \"path\": path,\n              \"mode\": \"100644\",\n              \"type\": \"blob\",\n              \"sha\": blob\n            }\n          ]\n        };\n        _request(\"POST\", repoPath + \"/git/trees\", data, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Post a new tree object having a file path pointer replaced\n      // with a new blob SHA getting a tree SHA back\n      // -------\n\n      this.postTree = function(tree, cb) {\n        _request(\"POST\", repoPath + \"/git/trees\", { \"tree\": tree }, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Create a new commit object with the current commit SHA as the parent\n      // and the new tree SHA, getting a commit SHA back\n      // -------\n\n      this.commit = function(parent, tree, message, cb) {\n        var data = {\n          \"message\": message,\n          \"author\": {\n            \"name\": options.username\n          },\n          \"parents\": [\n            parent\n          ],\n          \"tree\": tree\n        };\n\n        _request(\"POST\", repoPath + \"/git/commits\", data, function(err, res) {\n          currentTree.sha = res.sha; // update latest commit\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Update the reference of your head to point to the new commit SHA\n      // -------\n\n      this.updateHead = function(head, commit, cb) {\n        _request(\"PATCH\", repoPath + \"/git/refs/heads/\" + head, { \"sha\": commit }, function(err, res) {\n          cb(err);\n        });\n      };\n\n      // Show repository information\n      // -------\n\n      this.show = function(cb) {\n        _request(\"GET\", repoPath, null, cb);\n      };\n\n      // Get contents\n      // --------\n\n      this.contents = function(ref, path, cb) {\n        _request(\"GET\", repoPath + \"/contents/\"+path, { ref: ref }, cb);\n      };\n\n      // Fork repository\n      // -------\n\n      this.fork = function(cb) {\n        _request(\"POST\", repoPath + \"/forks\", null, cb);\n      };\n\n      // Create pull request\n      // --------\n\n      this.createPullRequest = function(options, cb) {\n        _request(\"POST\", repoPath + \"/pulls\", options, cb);\n      };\n\n      // List hooks\n      // --------\n\n      this.listHooks = function(cb) {\n        _request(\"GET\", repoPath + \"/hooks\", null, cb);\n      };\n\n      // Get a hook\n      // --------\n\n      this.getHook = function(id, cb) {\n        _request(\"GET\", repoPath + \"/hooks/\" + id, null, cb);\n      };\n\n      // Create a hook\n      // --------\n\n      this.createHook = function(options, cb) {\n        _request(\"POST\", repoPath + \"/hooks\", options, cb);\n      };\n\n      // Edit a hook\n      // --------\n\n      this.editHook = function(id, options, cb) {\n        _request(\"PATCH\", repoPath + \"/hooks/\" + id, options, cb);\n      };\n\n      // Delete a hook\n      // --------\n\n      this.deleteHook = function(id, cb) {\n        _request(\"DELETE\", repoPath + \"/hooks/\" + id, null, cb);\n      };\n\n      // Read file at given path\n      // -------\n\n      this.read = function(branch, path, cb) {\n        _request(\"GET\", repoPath + \"/contents/\"+path, {ref: branch}, function(err, obj) {\n          if (err && err.error === 404) return cb(\"not found\", null, null);\n\n          if (err) return cb(err);\n          var sha = obj.sha\n            , content = Base64.decode(obj.content);\n\n          cb(null, content, sha);\n        });\n      };\n\n\n      // Remove a file\n      // -------\n\n      this.remove = function(branch, path, cb) {\n        that.getSha(branch, path, function(err, sha) {\n          if (err) return cb(err);\n          _request(\"DELETE\", repoPath + \"/contents/\" + path, {\n            message: path + \" is removed\",\n            sha: sha,\n            branch: branch\n          }, cb);\n        });\n      };\n\n      // Move a file to a new location\n      // -------\n\n      this.move = function(branch, path, newPath, cb) {\n        updateTree(branch, function(err, latestCommit) {\n          that.getTree(latestCommit+\"?recursive=true\", function(err, tree) {\n            // Update Tree\n            _.each(tree, function(ref) {\n              if (ref.path === path) ref.path = newPath;\n              if (ref.type === \"tree\") delete ref.sha;\n            });\n\n            that.postTree(tree, function(err, rootTree) {\n              that.commit(latestCommit, rootTree, 'Deleted '+path , function(err, commit) {\n                that.updateHead(branch, commit, function(err) {\n                  cb(err);\n                });\n              });\n            });\n          });\n        });\n      };\n\n      // Write file contents to a given branch and path\n      // -------\n\n      this.write = function(branch, path, content, message, cb) {\n        that.getSha(branch, path, function(err, sha) {\n          if (err && err.error!=404) return cb(err);\n          _request(\"PUT\", repoPath + \"/contents/\" + path, {\n            message: message,\n            content: Base64.encode(content),\n            branch: branch,\n            sha: sha\n          }, cb);\n        });\n      };\n\n    };\n\n    // Gists API\n    // =======\n\n    Github.Gist = function(options) {\n      var id = options.id;\n      var gistPath = \"/gists/\"+id;\n\n      // Read the gist\n      // --------\n\n      this.read = function(cb) {\n        _request(\"GET\", gistPath, null, function(err, gist) {\n          cb(err, gist);\n        });\n      };\n\n      // Create the gist\n      // --------\n      // {\n      //  \"description\": \"the description for this gist\",\n      //    \"public\": true,\n      //    \"files\": {\n      //      \"file1.txt\": {\n      //        \"content\": \"String file contents\"\n      //      }\n      //    }\n      // }\n\n      this.create = function(options, cb){\n        _request(\"POST\",\"/gists\", options, cb);\n      };\n\n      // Delete the gist\n      // --------\n\n      this.delete = function(cb) {\n        _request(\"DELETE\", gistPath, null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Fork a gist\n      // --------\n\n      this.fork = function(cb) {\n        _request(\"POST\", gistPath+\"/fork\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Update a gist with the new stuff\n      // --------\n\n      this.update = function(options, cb) {\n        _request(\"PATCH\", gistPath, options, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Star a gist\n      // --------\n\n      this.star = function(cb) {\n        _request(\"PUT\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Untar a gist\n      // --------\n\n      this.unstar = function(cb) {\n        _request(\"DELETE\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Check if a gist is starred\n      // --------\n\n      this.isStarred = function(cb) {\n        _request(\"GET\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n    };\n\n    // Top Level API\n    // -------\n\n    this.getRepo = function(user, repo) {\n      return new Github.Repository({user: user, name: repo});\n    };\n\n    this.getUser = function() {\n      return new Github.User();\n    };\n\n    this.getGist = function(id) {\n      return new Github.Gist({id: id});\n    };\n  };\n\n\n  if (typeof exports !== 'undefined') {\n    // Github = exports;\n    module.exports = Github;\n  } else {\n    window.Github = Github;\n  }\n}).call(this);\n","type":"blob"},"github_status.haml":{"path":"github_status.haml","mode":"100644","content":".status\n  - if @request and @request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)\n    Authenticated Scopes:\n    = @request.getResponseHeader(\"X-OAuth-Scopes\")\n    %br\n    Rate Limit Remaining:\n    = @request.getResponseHeader(\"X-RateLimit-Remaining\")\n    = \" / 5000\"\n  - else\n    %button Auth\n      - on \"click\", Gistquire.auth\n","type":"blob"},"main.coffee":{"path":"main.coffee","mode":"100644","content":"# Get stuff from our env\n{files} = ENV\n\nwindow.ENV = ENV\n\n# TODO: Consider passing root from env for components\n$root = $('body')\n\n# Apply our styles\nif styleContent = files[\"style.css\"]?.content\n  $root.append $(\"<style>\",\n    html: styleContent\n  )\n\n# Init Github access token stuff\nGistquire.onload()\n\n# Github api\ngithub = new Github\n  auth: \"oauth\"\n  token: localStorage.authToken\n  \n# TODO: Real branch and repo info, maybe from ENV\nbranch = \"master\"\nuserName = \"STRd6\"\nrepoName = \"editor\"\nrepo = null\n\nerrors = Observable([])\nnotices = Observable([\"Loaded!\"])\n\nbuilder = Builder\n  errors: errors\n  notices: notices\n\nactions =\n  save: ->\n    notices [\"Saving...\"]\n    \n    Actions.save\n      owner: userName\n      repo: repoName\n      fileData: filetree.data()\n      builder: builder\n    .then ->\n      notices [\"Saved and published!\"]\n\n  new: ->\n    if name = prompt(\"File Name\", \"newfile.coffee\")\n      filetree.files.push File\n        filename: name\n        content: \"\"\n\n  run: (->    \n    notices [\"Building...\"]\n    \n    builder.build filetree.data(), (fileMap) ->\n      if fileMap[\"pixie.json\"]\n        config = JSON.parse(fileMap[\"pixie.json\"].content)\n      else\n        config = {}\n      \n      sandbox = Sandbox\n        width: config.width\n        height: config.height\n      \n      sandbox.document.open()\n      sandbox.document.write(builder.standAloneHtml(fileMap))\n\n      sandbox.document.close()\n\n      # TODO: Display this notice when we receive confirmation from child window\n      notices([\"Runnnig!\"])\n      # TODO: Catch and display runtime errors\n      errors([])\n\n      error: errors\n    ).debounce(250)\n\n  load_repo: ->\n    repoName = prompt(\"Github repo\", \"STRd6/matrix.js\")\n    \n    if repoName\n      [userName, repoName] = repoName.split(\"/\")\n    else\n      errors [\"No repo given\"]\n\n      return\n    \n    # Decode all content in place\n    processDirectory = (items) ->\n      items.each (item) ->\n        return item unless item.content\n        \n        item.content = Base64.decode(item.content)\n        item.encoding = \"raw\"\n    \n    Gistquire.latestTree\n      branch: \"master\"\n      repo: repoName\n      owner: userName\n      success: (data) ->\n        notices []\n        \n        treeFiles = data.tree.select (file) ->\n          file.type is \"blob\"\n        \n        # Gather the data for each file\n        async.map treeFiles, (datum, callback) ->\n          Gistquire.api datum.url,\n            success: (data) ->\n              callback(null, Object.extend(datum, data))\n            error: (error) ->\n              callback(error)\n\n        , (error, results) ->\n          notices [\"Radical!\"] \n          if error\n            errors [error]\n            return\n\n          files = processDirectory results\n          \n          notices [\n            files\n          ].map (item) ->\n            JSON.stringify(item, null, 2)\n            \n          filetree.load files\n      error: (error) ->\n        errors [error]\n\nfiletree = Filetree()\nfiletree.load(files)\n\nfiletree.selectedFile.observe (file) ->\n  root = $root.children(\".main\")\n  root.find(\".editor-wrap\").hide()\n  \n  if file.editor\n    file.editor.trigger(\"show\")\n  else\n    root.append(HAMLjr.templates.editor())\n    file.editor = root.find(\".editor-wrap\").last()\n    \n    editor = TextEditor\n      text: file.content()\n      el: file.editor.find('.editor').get(0)\n      mode: file.mode()\n\n    file.editor.on \"show\", ->\n      file.editor.show()\n      editor.editor.focus()\n  \n    editor.text.observe (value) ->\n      file.content(value)\n      \n      # Autorun\n      # actions.run()\n\n$root\n  .append(HAMLjr.templates.main(\n    filetree: filetree\n    actions: actions\n    notices: notices\n    errors: errors\n  ))\n\nGistquire.api \"rate_limit\", \n  complete: (request, status) ->\n    $root.append HAMLjr.templates.github_status\n      request: request\n\nif loadId = window.location.href.match(/loadId=(\\d+)/)?[1]\n  actions.load(null, loadId)\n","type":"blob"},"main.haml":{"path":"main.haml","mode":"100644","content":".main\n  = HAMLjr.templates.actions @actions\n  = HAMLjr.templates.filetree @filetree\n  = HAMLjr.templates.errors this\n","type":"blob"},"pixie.json":{"path":"pixie.json","mode":"100644","content":"{\n  \"width\": 960,\n  \"height\": 800\n}\n","type":"blob"},"sandbox.coffee":{"path":"sandbox.coffee","mode":"100644","content":"@Sandbox = ({name, width, height, methods}={}) ->\n  name ?= \"sandbox\" + new Date\n  width ?= 800\n  height ?= 600\n  methods ?= {}\n\n  sandbox = window.open(\n    \"\"\n    name\n    \"width=#{width},height=#{height}\"\n  )\n\n  # Pass functions to the running window\n  Object.extend sandbox, methods\n\n  sandbox\n","type":"blob"},"style.styl":{"path":"style.styl","mode":"100644","content":"html, body\n  margin: 0\n  height: 100%\n\n.main\n  position: relative\n  padding-top: 40px\n  padding-left: 200px\n  padding-bottom: 100px\n  box-sizing: border-box\n  height: 100%\n\n.editor-wrap\n  background-color: white\n  width: 100%\n  height: 100%\n  position: relative\n\n  & > div\n    position: absolute\n    top: 0\n    left: 0\n    right: 0\n    bottom: 0\n\n.filetree\n  margin: 0\n  padding: 0\n  width: 200px\n  position: absolute\n  left: 0\n  top: 40px\n  z-index: 2\n\n  li\n    list-style-type: none\n    padding-left: 1em\n\n.actions\n  position: absolute\n  top: 0\n  left: 200px\n\n.console-wrap\n  box-sizing: border-box\n  position: absolute\n  bottom: 0\n  left: 0\n  right: 0\n  padding-left: 200px\n  height: 100px\n  width: 100%\n  margin: 0\n  \n  .errors\n    box-sizing: border-box\n    border-top: 1px solid black\n    color: red\n\n.status\n  top: 0\n  right: 0\n  position: absolute\n","type":"blob"},"text_editor.coffee":{"path":"text_editor.coffee","mode":"100644","content":"@TextEditor = (I) ->\n  Object.reverseMerge I,\n    mode: \"coffee\"\n    text: \"\"\n\n  self = Model(I)\n\n  # We can't use ace on a div not in the DOM :(\n  el = I.el\n  # We can't serialize DOM elements\n  delete I.el\n\n  editor = ace.edit(el)\n  editor.setFontSize(\"16px\")\n  editor.setTheme(\"ace/theme/chrome\")\n  editor.getSession().setUseWorker(false)\n  editor.getSession().setMode(\"ace/mode/#{I.mode}\")\n  editor.getSession().setUseSoftTabs(true)\n  editor.getSession().setTabSize(2)\n\n  reset = (content=\"\") ->\n    editor.setValue(content)\n    editor.moveCursorTo(0, 0)\n    editor.session.selection.clearSelection()\n\n  reset(I.text)\n\n  self.attrObservable \"text\"\n\n  updating = false\n  editor.getSession().on 'change', ->\n    updating = true\n    self.text(editor.getValue())\n    updating = false\n\n  self.text.observe (newValue) ->\n    unless updating\n      reset(newValue)\n\n  self.extend\n    el: el\n    editor: editor\n    reset: reset\n\n  return self\n","type":"blob"},"actions.coffee":{"path":"actions.coffee","mode":"100644","content":"publish = ({builder, fileData, repo, owner, branch}) ->\n  branch ?= \"master\"\n  message = \"Built #{branch} in browser in strd6.github.io/tempest\"\n\n  if branch is \"master\"\n    path = \"index.html\"\n  else\n    path = \"#{branch}.html\"\n\n  # Assuming git repo with gh-pages branch\n  publishBranch = \"gh-pages\"\n  \n  builder.build fileData, (fileMap) ->\n    # create <ref>.html in gh-pages branch\n    Gistquire.writeFile\n      repo: repo\n      owner: owner\n      path: path\n      content: Base64.encode(builder.standAloneHtml(fileMap))\n      branch: publishBranch\n      message: message\n\ncommit = ({fileData, repo, owner, branch, message}) ->\n  Gistquire.commitTree\n    owner: owner\n    repo: repo\n    tree: fileData\n    message: message\n\n@Actions =\n  save: (params) ->\n    commit(params)\n      .then ->\n        publish(params)\n","type":"blob"},"build.js":{"path":"build.js","content":"(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"actions\"] = function(data) {\n    return (function() {\n      var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"actions\");\n      actions = this;\n      Object.keys(actions).each(function(name) {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, name.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", actions[name]);\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"editor\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor\");\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"errors\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"console-wrap\");\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"errors\");\n      __each(this.errors, function(error) {\n        __element = document.createTextNode('');\n        __text(__element, error);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"notices\");\n      __each(this.notices, function(notice) {\n        __element = document.createTextNode('');\n        __text(__element, notice);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"filetree\"] = function(data) {\n    return (function() {\n      var selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"filetree\");\n      selectedFile = this.selectedFile;\n      __each(this.files, function(file) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, file.path);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return selectedFile(file);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"gist_list\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"gists\");\n      __each(this.gists, function(gist) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, gist.id);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return alert(gist.id);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"github_status\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"status\");\n      if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n        __element = document.createTextNode('');\n        __text(__element, \"Authenticated Scopes:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n        __push(__element);\n        __pop();\n        __element = document.createElement(\"br\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \"Rate Limit Remaining:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \" / 5000\");\n        __push(__element);\n        __pop();\n      } else {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Auth\\n\");\n        __push(__element);\n        __pop();\n        __on(\"click\", Gistquire.auth);\n        __pop();\n      }\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"main\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"main\");\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.actions(this.actions));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.filetree(this.filetree));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.errors(this));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = setImmediate;\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n(function() {\n  // Lookup arrays for base64 conversions\n  var enc64List, dec64List;\n  // Load the lookup arrays once\n  (function() {\n      enc64List = new Array();\n      dec64List = new Array();\n      var i;\n      for (i = 0; i < 26; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(65 + i);\n      }\n      for (i = 0; i < 26; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(97 + i);\n      }\n      for (i = 0; i < 10; i++) {\n          enc64List[enc64List.length] = String.fromCharCode(48 + i);\n      }\n      enc64List[enc64List.length] = \"+\";\n      enc64List[enc64List.length] = \"/\";\n      for (i = 0; i < 128; i++) {\n          dec64List[dec64List.length] = -1;\n      }\n      for (i = 0; i < 64; i++) {\n          dec64List[enc64List[i].charCodeAt(0)] = i;\n      }\n  })();\n\n  window.Base64 = {\n    encode: function(str) {\n        var c, d, e, end = 0;\n        var u, v, w, x;\n        var ptr = -1;\n        var input = str.split(\"\");\n        var output = \"\";\n        while(end == 0) {\n            c = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end = 1) ? 0 : 0);\n            d = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end += 1) ? 0 : 0);\n            e = (typeof input[++ptr] != \"undefined\") ? input[ptr].charCodeAt(0) :\n                ((end += 1) ? 0 : 0);\n            u = enc64List[c >> 2];\n            v = enc64List[(0x00000003 & c) << 4 | d >> 4];\n            w = enc64List[(0x0000000F & d) << 2 | e >> 6];\n            x = enc64List[e & 0x0000003F];\n\n            // handle padding to even out unevenly divisible string lengths\n            if (end >= 1) {x = \"=\";}\n            if (end == 2) {w = \"=\";}\n\n            if (end < 3) {output += u + v + w + x;}\n        }\n        return output;\n    },\n\n    decode: function(str) {\n        var c=0, d=0, e=0, f=0, i=0, n=0;\n        var input = str.split(\"\");\n        var output = \"\";\n        var ptr = 0;\n        do {\n            f = input[ptr++].charCodeAt(0);\n            i = dec64List[f];\n            if ( f >= 0 && f < 128 && i != -1 ) {\n                if ( n % 4 == 0 ) {\n                    c = i << 2;\n                } else if ( n % 4 == 1 ) {\n                    c = c | ( i >> 4 );\n                    d = ( i & 0x0000000F ) << 4;\n                } else if ( n % 4 == 2 ) {\n                    d = d | ( i >> 2 );\n                    e = ( i & 0x00000003 ) << 6;\n                } else {\n                    e = e | i;\n                }\n                n++;\n                if ( n % 4 == 0 ) {\n                    output += String.fromCharCode(c) +\n                              String.fromCharCode(d) +\n                              String.fromCharCode(e);\n                }\n            }\n        }\n        while (typeof input[ptr] != \"undefined\");\n        output += (n % 4 == 3) ? String.fromCharCode(c) + String.fromCharCode(d) :\n                  ((n % 4 == 2) ? String.fromCharCode(c) : \"\");\n        return output;\n    }\n  };\n}());\n\n(function() {\n  this.Builder = function(I) {\n    var build, buildStyle, compileTemplate;\n    if (I == null) {\n      I = {};\n    }\n    compileTemplate = function(source, name) {\n      var ast;\n      if (name == null) {\n        name = \"test\";\n      }\n      ast = HAMLjr.parser.parse(source);\n      return HAMLjr.compile(ast, {\n        name: name,\n        compiler: CoffeeScript\n      });\n    };\n    build = function(fileData) {\n      var errors, main, models, templates;\n      templates = [];\n      models = [];\n      main = \"\";\n      errors = [];\n      fileData.each(function(_arg) {\n        var content, error, name, path, source;\n        path = _arg.path, content = _arg.content;\n        name = path.split('/').last();\n        source = content;\n        try {\n          if (name.extension() === \"haml\") {\n            return templates.push(compileTemplate(source, name.withoutExtension()));\n          } else if (name.extension() === \"js\") {\n            if (name === \"main.js\") {\n              return main = source;\n            } else if (name === \"build.js\") {\n\n            } else {\n              return models.push(source);\n            }\n          } else if (name.extension() === \"coffee\") {\n            if (name === \"main.coffee\") {\n              return main = CoffeeScript.compile(source);\n            } else {\n              return models.push(CoffeeScript.compile(source));\n            }\n          }\n        } catch (_error) {\n          error = _error;\n          return errors.push(error.stack);\n        }\n      });\n      return {\n        errors: errors,\n        result: \"\" + (templates.join(\"\\n\")) + \"\\n\" + (models.join(\"\\n\")) + \"\\n\" + main\n      };\n    };\n    buildStyle = function(fileData) {\n      var errors, styles;\n      styles = [];\n      errors = [];\n      fileData.each(function(_arg) {\n        var content, error, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          if (path.extension() === \"styl\") {\n            return styles.push(styl(content, {\n              whitespace: true\n            }).toString());\n          }\n        } catch (_error) {\n          error = _error;\n          return errors.push(error.stack);\n        }\n      });\n      return {\n        errors: errors,\n        result: styles.join(\"\\n\")\n      };\n    };\n    return {\n      build: function(fileData, callback) {\n        var collectedErrors, compileResult, errors, fileMap, result, _ref, _ref1;\n        I.notices.push(\"Building...\");\n        _ref = build(fileData), collectedErrors = _ref.errors, compileResult = _ref.result;\n        _ref1 = buildStyle(fileData), errors = _ref1.errors, result = _ref1.result;\n        collectedErrors = collectedErrors.concat(errors);\n        if (compileResult.trim() !== \"\") {\n          fileData.push({\n            path: \"build.js\",\n            content: compileResult,\n            type: \"blob\"\n          });\n        }\n        if (result !== \"\") {\n          fileData.push({\n            path: \"style.css\",\n            content: result,\n            type: \"blob\"\n          });\n        }\n        if (collectedErrors.length) {\n          return typeof I.errors === \"function\" ? I.errors(collectedErrors) : void 0;\n        } else {\n          fileMap = fileData.eachWithObject({}, function(file, hash) {\n            return hash[file.path] = file;\n          });\n          return callback(fileMap);\n        }\n      },\n      standAloneHtml: function(fileMap) {\n        var content, entryPoint, program;\n        content = $('script.env').map(function() {\n          return this.outerHTML;\n        }).get();\n        entryPoint = \"build.js\";\n        program = fileMap[entryPoint].content;\n        content.push(\"<body><script>\\n  Function(\\\"ENV\\\", \" + (JSON.stringify(program)) + \")({\\n    files: \" + (JSON.stringify(fileMap)) + \"\\n  });\\n<\\/script>\");\n        return content.join(\"\\n\");\n      }\n    };\n  };\n\n}).call(this);\n\n(function() {\n  this.File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          default:\n            return extension;\n        }\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        files = Object.keys(fileData).sort().map(function(name) {\n          return File(fileData[name]);\n        });\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.filename(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    update: function(id, _arg) {\n      var data, error, success, url;\n      data = _arg.data, success = _arg.success, error = _arg.error;\n      url = \"https://api.github.com/gists/\" + id;\n      if (this.accessToken) {\n        url += \"?access_token=\" + this.accessToken;\n      }\n      return $.ajax({\n        url: url,\n        type: \"PATCH\",\n        dataType: 'json',\n        data: JSON.stringify(data),\n        success: success,\n        error: error\n      });\n    },\n    create: function(data, callback) {\n      var url;\n      url = \"https://api.github.com/gists\";\n      if (this.accessToken) {\n        url += \"?access_token=\" + this.accessToken;\n      }\n      return $.ajax({\n        url: url,\n        type: \"POST\",\n        dataType: 'json',\n        data: JSON.stringify(data),\n        success: callback\n      });\n    },\n    get: function(id, callback) {\n      return this.api(\"gists/\" + id, {\n        success: callback\n      });\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    },\n    initPagesBranch: function(_arg) {\n      var branch, error, owner, repo, success;\n      owner = _arg.owner, repo = _arg.repo, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      branch = \"gh-pages\";\n      if (!(owner && repo)) {\n        throw Error(\"Must pass in an owner and a repo\");\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/trees\", {\n        type: \"POST\",\n        data: JSON.stringify({\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/tempest\"\n            }\n          ]\n        }),\n        success: function(data) {\n          return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/commits\", {\n            type: \"POST\",\n            data: JSON.stringify({\n              message: \"Initial gh-pages commit\",\n              tree: data.sha\n            }),\n            success: function(data) {\n              return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs\", {\n                type: \"POST\",\n                data: JSON.stringify({\n                  ref: \"refs/heads/\" + branch,\n                  sha: data.sha\n                }),\n                success: success,\n                error: error\n              });\n            },\n            error: error\n          });\n        },\n        error: error\n      });\n    },\n    writeFile: function(_arg) {\n      var branch, content, error, message, owner, path, repo, success;\n      owner = _arg.owner, repo = _arg.repo, branch = _arg.branch, path = _arg.path, content = _arg.content, message = _arg.message, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/contents/\" + path, {\n        data: {\n          ref: branch\n        },\n        success: function(data) {\n          return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/contents/\" + path, {\n            type: \"PUT\",\n            data: JSON.stringify({\n              content: content,\n              sha: data.sha,\n              message: message,\n              branch: branch\n            }),\n            success: success,\n            error: error\n          });\n        },\n        error: function(request) {\n          if (request.status === 404) {\n            return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/contents/\" + path, {\n              type: \"PUT\",\n              data: JSON.stringify({\n                content: content,\n                message: message,\n                branch: branch\n              }),\n              success: success,\n              error: error\n            });\n          } else {\n            return error.apply(null, arguments);\n          }\n        }\n      });\n    },\n    commitTree: function(_arg) {\n      var branch, error, message, owner, repo, success, tree;\n      owner = _arg.owner, repo = _arg.repo, branch = _arg.branch, message = _arg.message, tree = _arg.tree, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      if (branch == null) {\n        branch = \"master\";\n      }\n      if (message == null) {\n        message = \"Updated in browser at strd6.github.io/editor\";\n      }\n      if (!(owner && repo && tree)) {\n        throw Error(\"Must pass in an owner, a tree, and a repo\");\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs/heads/\" + branch, {\n        success: function(data) {\n          var latestCommitSha;\n          latestCommitSha = data.object.sha;\n          return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/trees\", {\n            type: \"POST\",\n            data: JSON.stringify({\n              tree: tree\n            }),\n            success: function(data) {\n              return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/commits\", {\n                type: \"POST\",\n                data: JSON.stringify({\n                  parents: [latestCommitSha],\n                  message: message,\n                  tree: data.sha\n                }),\n                success: function(data) {\n                  return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs/heads/\" + branch, {\n                    type: \"PATCH\",\n                    data: JSON.stringify({\n                      sha: data.sha\n                    }),\n                    success: success,\n                    error: error\n                  });\n                },\n                error: error\n              });\n            },\n            error: error\n          });\n        },\n        error: error\n      });\n    },\n    latestTree: function(_arg) {\n      var branch, error, owner, repo, success;\n      owner = _arg.owner, repo = _arg.repo, branch = _arg.branch, success = _arg.success, error = _arg.error;\n      if (success == null) {\n        success = function() {};\n      }\n      if (error == null) {\n        error = function() {};\n      }\n      if (branch == null) {\n        branch = \"master\";\n      }\n      return Gistquire.api(\"repos/\" + owner + \"/\" + repo + \"/git/refs/heads/\" + branch, {\n        success: function(data) {\n          return Gistquire.api(data.object.url, {\n            success: function(data) {\n              return Gistquire.api(\"\" + data.tree.url + \"?recursive=1\", {\n                success: success,\n                error: error\n              });\n            },\n            error: error\n          });\n        },\n        error: error\n      });\n    }\n  };\n\n}).call(this);\n\n// Github.js 0.8.0\n// (c) 2013 Michael Aufreiter, Development Seed\n// Github.js is freely distributable under the MIT license.\n// For all details and documentation:\n// http://substance.io/michael/github\n\n(function() {\n\n  // Initial Setup\n  // -------------\n\n  var XMLHttpRequest, Base64, _;\n  if (typeof exports !== 'undefined') {\n      XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n      _ = require('underscore');\n      Base64 = require('./lib/base64.js');\n  }else{\n      _ = window._;\n      Base64 = window.Base64;\n  }\n  //prefer native XMLHttpRequest always\n  if (typeof window !== 'undefined' && typeof window.XMLHttpRequest !== 'undefined'){\n      XMLHttpRequest = window.XMLHttpRequest;\n  }\n\n\n  var API_URL = 'https://api.github.com';\n\n  var Github = function(options) {\n\n    // HTTP Request Abstraction\n    // =======\n    //\n    // I'm not proud of this and neither should you be if you were responsible for the XMLHttpRequest spec.\n\n    function _request(method, path, data, cb, raw) {\n      function getURL() {\n        var url = path.indexOf('//') >= 0 ? path : API_URL + path;\n        return url + ((/\\?/).test(url) ? \"&\" : \"?\") + (new Date()).getTime();\n      }\n\n      var xhr = new XMLHttpRequest();\n      if (!raw) {xhr.dataType = \"json\";}\n\n      xhr.open(method, getURL());\n      xhr.onreadystatechange = function () {\n        if (this.readyState == 4) {\n          if (this.status >= 200 && this.status < 300 || this.status === 304) {\n            cb(null, raw ? this.responseText : this.responseText ? JSON.parse(this.responseText) : true, this);\n          } else {\n            cb({path: path, request: this, error: this.status});\n          }\n        }\n      };\n      xhr.setRequestHeader('Accept','application/json');\n      xhr.setRequestHeader('Content-Type','application/json');\n      if ( (options.token) || (options.username && options.password)) {\n           xhr.setRequestHeader('Authorization', options.token\n             ? 'token '+ options.token\n             : 'Basic ' + Base64.encode(options.username + ':' + options.password)\n           );\n         }\n      data ? xhr.send(JSON.stringify(data)) : xhr.send();\n    }\n\n    function _requestAllPages(path, cb) {\n      var results = [];\n      (function iterate() {\n        _request(\"GET\", path, null, function(err, res, xhr) {\n          if (err) {\n            return cb(err);\n          }\n\n          results.push.apply(results, res);\n\n          var links = (xhr.getResponseHeader('link') || '').split(/\\s*,\\s*/g),\n              next = _.find(links, function(link) { return /rel=\"next\"/.test(link); });\n\n          if (next) {\n            next = (/<(.*)>/.exec(next) || [])[1];\n          }\n\n          if (!next) {\n            cb(err, results);\n          } else {\n            path = next;\n            iterate();\n          }\n        });\n      })();\n    }\n\n\n\n    // User API\n    // =======\n\n    Github.User = function() {\n      this.repos = function(cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/user/repos?type=all&per_page=1000&sort=updated\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List user organizations\n      // -------\n\n      this.orgs = function(cb) {\n        _request(\"GET\", \"/user/orgs\", null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List authenticated user's gists\n      // -------\n\n      this.gists = function(cb) {\n        _request(\"GET\", \"/gists\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // List authenticated user's unread notifications\n      // -------\n\n      this.notifications = function(cb) {\n        _request(\"GET\", \"/notifications\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // Show user information\n      // -------\n\n      this.show = function(username, cb) {\n        var command = username ? \"/users/\"+username : \"/user\";\n\n        _request(\"GET\", command, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List user repositories\n      // -------\n\n      this.userRepos = function(username, cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/users/\"+username+\"/repos?type=all&per_page=1000&sort=updated\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // List a user's gists\n      // -------\n\n      this.userGists = function(username, cb) {\n        _request(\"GET\", \"/users/\"+username+\"/gists\", null, function(err, res) {\n          cb(err,res);\n        });\n      };\n\n      // List organization repositories\n      // -------\n\n      this.orgRepos = function(orgname, cb) {\n        // Github does not always honor the 1000 limit so we want to iterate over the data set.\n        _requestAllPages(\"/orgs/\"+orgname+\"/repos?type=all&&page_num=1000&sort=updated&direction=desc\", function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Follow user\n      // -------\n\n      this.follow = function(username, cb) {\n        _request(\"PUT\", \"/user/following/\"+username, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Unfollow user\n      // -------\n\n      this.unfollow = function(username, cb) {\n        _request(\"DELETE\", \"/user/following/\"+username, null, function(err, res) {\n          cb(err, res);\n        });\n      };\n\n      // Create a repo\n      // -------\n      this.createRepo = function(options, cb) {\n        _request(\"POST\", \"/user/repos\", options, cb);\n      };\n\n\n\n\n\n    };\n\n\n    // Repository API\n    // =======\n\n    Github.Repository = function(options) {\n      var repo = options.name;\n      var user = options.user;\n\n      var that = this;\n      var repoPath = \"/repos/\" + user + \"/\" + repo;\n\n      var currentTree = {\n        \"branch\": null,\n        \"sha\": null\n      };\n\n\n      // Delete a repo\n      // --------\n\n      this.deleteRepo = function(cb) {\n        _request(\"DELETE\", repoPath, options, cb);\n      };\n\n      // Uses the cache if branch has not been changed\n      // -------\n\n      function updateTree(branch, cb) {\n        if (branch === currentTree.branch && currentTree.sha) return cb(null, currentTree.sha);\n        that.getRef(\"heads/\"+branch, function(err, sha) {\n          currentTree.branch = branch;\n          currentTree.sha = sha;\n          cb(err, sha);\n        });\n      }\n\n      // Get a particular reference\n      // -------\n\n      this.getRef = function(ref, cb) {\n        _request(\"GET\", repoPath + \"/git/refs/\" + ref, null, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.object.sha);\n        });\n      };\n\n      // Create a new reference\n      // --------\n      //\n      // {\n      //   \"ref\": \"refs/heads/my-new-branch-name\",\n      //   \"sha\": \"827efc6d56897b048c772eb4087f854f46256132\"\n      // }\n\n      this.createRef = function(options, cb) {\n        _request(\"POST\", repoPath + \"/git/refs\", options, cb);\n      };\n\n      // Delete a reference\n      // --------\n      //\n      // repo.deleteRef('heads/gh-pages')\n      // repo.deleteRef('tags/v1.0')\n\n      this.deleteRef = function(ref, cb) {\n        _request(\"DELETE\", repoPath + \"/git/refs/\"+ref, options, cb);\n      };\n\n      // List all branches of a repository\n      // -------\n\n      this.listBranches = function(cb) {\n        _request(\"GET\", repoPath + \"/git/refs/heads\", null, function(err, heads) {\n          if (err) return cb(err);\n          cb(null, _.map(heads, function(head) { return _.last(head.ref.split('/')); }));\n        });\n      };\n\n      // List all tags of a repository\n      // -------\n\n      this.listTags = function(cb) {\n        _request(\"GET\", repoPath + \"/tags\", null, function(err, tags) {\n          if (err) return cb(err);\n          cb(null, tags);\n        });\n      };\n\n      // List all pull requests of a respository\n      // -------\n\n      this.listPulls = function(state, cb) {\n        if (_.isFunction(state)) {\n          cb = state;\n          state = undefined;\n        }\n\n        _request(\"GET\", repoPath + \"/pulls\" + (state ? '?state=' + state : ''), null, function(err, pulls) {\n          if (err) return cb(err);\n          cb(null, pulls);\n        });\n      };\n\n      // Gets details for a specific pull request\n      // -------\n\n      this.getPull = function(number, cb) {\n        _request(\"GET\", repoPath + \"/pulls/\" + number, null, function(err, pull) {\n          if (err) return cb(err);\n          cb(null, pull);\n        });\n      };\n\n      // List all issues of a respository\n      // -------\n\n      this.listIssues = function(options, cb) {\n        if (_.isFunction(options)) {\n          cb = options;\n          options = undefined;\n        }\n\n        var params = _.map(options, function(value, key) {\n          return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n        }).join('&');\n\n        _request(\"GET\", repoPath + \"/issues\" + (params ? \"?\" + params : \"\"), null, function(err, issues) {\n          if (err) return cb(err);\n          cb(null, issues);\n        });\n      },\n\n\n      // Retrieve the changes made between base and head\n      // -------\n\n      this.compare = function(base, head, cb) {\n        _request(\"GET\", repoPath + \"/compare/\" + base + \"...\" + head, null, function(err, diff) {\n          if (err) return cb(err);\n          cb(null, diff);\n        });\n      };\n\n      // Retrieve the contents of a blob\n      // -------\n\n      this.getBlob = function(sha, cb) {\n        _request(\"GET\", repoPath + \"/git/blobs/\" + sha, null, cb, 'raw');\n      };\n\n      // For a given file path, get the corresponding sha (blob for files, tree for dirs)\n      // -------\n\n      this.getSha = function(branch, path, cb) {\n        if (!path || path === \"\") return that.getRef(\"heads/\"+branch, cb);\n        _request(\"GET\", repoPath + \"/contents/\"+path, {ref: branch}, function(err, pathContent) {\n          if (err) return cb(err);\n          cb(null, pathContent.sha);\n        });\n      };\n\n      // Retrieve the tree a commit points to\n      // -------\n\n      this.getTree = function(tree, cb) {\n        _request(\"GET\", repoPath + \"/git/trees/\"+tree, null, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.tree);\n        });\n      };\n\n      // Post a new blob object, getting a blob SHA back\n      // -------\n\n      this.postBlob = function(content, cb) {\n        if (typeof(content) === \"string\") {\n          content = {\n            \"content\": content,\n            \"encoding\": \"utf-8\"\n          };\n        }\n\n        _request(\"POST\", repoPath + \"/git/blobs\", content, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Update an existing tree adding a new blob object getting a tree SHA back\n      // -------\n\n      this.updateTree = function(baseTree, path, blob, cb) {\n        var data = {\n          \"base_tree\": baseTree,\n          \"tree\": [\n            {\n              \"path\": path,\n              \"mode\": \"100644\",\n              \"type\": \"blob\",\n              \"sha\": blob\n            }\n          ]\n        };\n        _request(\"POST\", repoPath + \"/git/trees\", data, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Post a new tree object having a file path pointer replaced\n      // with a new blob SHA getting a tree SHA back\n      // -------\n\n      this.postTree = function(tree, cb) {\n        _request(\"POST\", repoPath + \"/git/trees\", { \"tree\": tree }, function(err, res) {\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Create a new commit object with the current commit SHA as the parent\n      // and the new tree SHA, getting a commit SHA back\n      // -------\n\n      this.commit = function(parent, tree, message, cb) {\n        var data = {\n          \"message\": message,\n          \"author\": {\n            \"name\": options.username\n          },\n          \"parents\": [\n            parent\n          ],\n          \"tree\": tree\n        };\n\n        _request(\"POST\", repoPath + \"/git/commits\", data, function(err, res) {\n          currentTree.sha = res.sha; // update latest commit\n          if (err) return cb(err);\n          cb(null, res.sha);\n        });\n      };\n\n      // Update the reference of your head to point to the new commit SHA\n      // -------\n\n      this.updateHead = function(head, commit, cb) {\n        _request(\"PATCH\", repoPath + \"/git/refs/heads/\" + head, { \"sha\": commit }, function(err, res) {\n          cb(err);\n        });\n      };\n\n      // Show repository information\n      // -------\n\n      this.show = function(cb) {\n        _request(\"GET\", repoPath, null, cb);\n      };\n\n      // Get contents\n      // --------\n\n      this.contents = function(ref, path, cb) {\n        _request(\"GET\", repoPath + \"/contents/\"+path, { ref: ref }, cb);\n      };\n\n      // Fork repository\n      // -------\n\n      this.fork = function(cb) {\n        _request(\"POST\", repoPath + \"/forks\", null, cb);\n      };\n\n      // Create pull request\n      // --------\n\n      this.createPullRequest = function(options, cb) {\n        _request(\"POST\", repoPath + \"/pulls\", options, cb);\n      };\n\n      // List hooks\n      // --------\n\n      this.listHooks = function(cb) {\n        _request(\"GET\", repoPath + \"/hooks\", null, cb);\n      };\n\n      // Get a hook\n      // --------\n\n      this.getHook = function(id, cb) {\n        _request(\"GET\", repoPath + \"/hooks/\" + id, null, cb);\n      };\n\n      // Create a hook\n      // --------\n\n      this.createHook = function(options, cb) {\n        _request(\"POST\", repoPath + \"/hooks\", options, cb);\n      };\n\n      // Edit a hook\n      // --------\n\n      this.editHook = function(id, options, cb) {\n        _request(\"PATCH\", repoPath + \"/hooks/\" + id, options, cb);\n      };\n\n      // Delete a hook\n      // --------\n\n      this.deleteHook = function(id, cb) {\n        _request(\"DELETE\", repoPath + \"/hooks/\" + id, null, cb);\n      };\n\n      // Read file at given path\n      // -------\n\n      this.read = function(branch, path, cb) {\n        _request(\"GET\", repoPath + \"/contents/\"+path, {ref: branch}, function(err, obj) {\n          if (err && err.error === 404) return cb(\"not found\", null, null);\n\n          if (err) return cb(err);\n          var sha = obj.sha\n            , content = Base64.decode(obj.content);\n\n          cb(null, content, sha);\n        });\n      };\n\n\n      // Remove a file\n      // -------\n\n      this.remove = function(branch, path, cb) {\n        that.getSha(branch, path, function(err, sha) {\n          if (err) return cb(err);\n          _request(\"DELETE\", repoPath + \"/contents/\" + path, {\n            message: path + \" is removed\",\n            sha: sha,\n            branch: branch\n          }, cb);\n        });\n      };\n\n      // Move a file to a new location\n      // -------\n\n      this.move = function(branch, path, newPath, cb) {\n        updateTree(branch, function(err, latestCommit) {\n          that.getTree(latestCommit+\"?recursive=true\", function(err, tree) {\n            // Update Tree\n            _.each(tree, function(ref) {\n              if (ref.path === path) ref.path = newPath;\n              if (ref.type === \"tree\") delete ref.sha;\n            });\n\n            that.postTree(tree, function(err, rootTree) {\n              that.commit(latestCommit, rootTree, 'Deleted '+path , function(err, commit) {\n                that.updateHead(branch, commit, function(err) {\n                  cb(err);\n                });\n              });\n            });\n          });\n        });\n      };\n\n      // Write file contents to a given branch and path\n      // -------\n\n      this.write = function(branch, path, content, message, cb) {\n        that.getSha(branch, path, function(err, sha) {\n          if (err && err.error!=404) return cb(err);\n          _request(\"PUT\", repoPath + \"/contents/\" + path, {\n            message: message,\n            content: Base64.encode(content),\n            branch: branch,\n            sha: sha\n          }, cb);\n        });\n      };\n\n    };\n\n    // Gists API\n    // =======\n\n    Github.Gist = function(options) {\n      var id = options.id;\n      var gistPath = \"/gists/\"+id;\n\n      // Read the gist\n      // --------\n\n      this.read = function(cb) {\n        _request(\"GET\", gistPath, null, function(err, gist) {\n          cb(err, gist);\n        });\n      };\n\n      // Create the gist\n      // --------\n      // {\n      //  \"description\": \"the description for this gist\",\n      //    \"public\": true,\n      //    \"files\": {\n      //      \"file1.txt\": {\n      //        \"content\": \"String file contents\"\n      //      }\n      //    }\n      // }\n\n      this.create = function(options, cb){\n        _request(\"POST\",\"/gists\", options, cb);\n      };\n\n      // Delete the gist\n      // --------\n\n      this.delete = function(cb) {\n        _request(\"DELETE\", gistPath, null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Fork a gist\n      // --------\n\n      this.fork = function(cb) {\n        _request(\"POST\", gistPath+\"/fork\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Update a gist with the new stuff\n      // --------\n\n      this.update = function(options, cb) {\n        _request(\"PATCH\", gistPath, options, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Star a gist\n      // --------\n\n      this.star = function(cb) {\n        _request(\"PUT\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Untar a gist\n      // --------\n\n      this.unstar = function(cb) {\n        _request(\"DELETE\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n\n      // Check if a gist is starred\n      // --------\n\n      this.isStarred = function(cb) {\n        _request(\"GET\", gistPath+\"/star\", null, function(err,res) {\n          cb(err,res);\n        });\n      };\n    };\n\n    // Top Level API\n    // -------\n\n    this.getRepo = function(user, repo) {\n      return new Github.Repository({user: user, name: repo});\n    };\n\n    this.getUser = function() {\n      return new Github.User();\n    };\n\n    this.getGist = function(id) {\n      return new Github.Gist({id: id});\n    };\n  };\n\n\n  if (typeof exports !== 'undefined') {\n    // Github = exports;\n    module.exports = Github;\n  } else {\n    window.Github = Github;\n  }\n}).call(this);\n\n(function() {\n  this.Sandbox = function(_arg) {\n    var height, methods, name, sandbox, width, _ref;\n    _ref = _arg != null ? _arg : {}, name = _ref.name, width = _ref.width, height = _ref.height, methods = _ref.methods;\n    if (name == null) {\n      name = \"sandbox\" + new Date;\n    }\n    if (width == null) {\n      width = 800;\n    }\n    if (height == null) {\n      height = 600;\n    }\n    if (methods == null) {\n      methods = {};\n    }\n    sandbox = window.open(\"\", name, \"width=\" + width + \",height=\" + height);\n    Object.extend(sandbox, methods);\n    return sandbox;\n  };\n\n}).call(this);\n\n(function() {\n  this.TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var commit, publish;\n\n  publish = function(_arg) {\n    var branch, builder, fileData, message, owner, path, publishBranch, repo;\n    builder = _arg.builder, fileData = _arg.fileData, repo = _arg.repo, owner = _arg.owner, branch = _arg.branch;\n    if (branch == null) {\n      branch = \"master\";\n    }\n    message = \"Built \" + branch + \" in browser in strd6.github.io/tempest\";\n    if (branch === \"master\") {\n      path = \"index.html\";\n    } else {\n      path = \"\" + branch + \".html\";\n    }\n    publishBranch = \"gh-pages\";\n    return builder.build(fileData, function(fileMap) {\n      return Gistquire.writeFile({\n        repo: repo,\n        owner: owner,\n        path: path,\n        content: Base64.encode(builder.standAloneHtml(fileMap)),\n        branch: publishBranch,\n        message: message\n      });\n    });\n  };\n\n  commit = function(_arg) {\n    var branch, fileData, message, owner, repo;\n    fileData = _arg.fileData, repo = _arg.repo, owner = _arg.owner, branch = _arg.branch, message = _arg.message;\n    return Gistquire.commitTree({\n      owner: owner,\n      repo: repo,\n      tree: fileData,\n      message: message\n    });\n  };\n\n  this.Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    }\n  };\n\n}).call(this);\n\n(function() {\n  var $root, actions, branch, builder, errors, files, filetree, github, loadId, notices, repo, repoName, styleContent, userName, _ref, _ref1;\n\n  files = ENV.files;\n\n  window.ENV = ENV;\n\n  $root = $('body');\n\n  if (styleContent = (_ref = files[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  Gistquire.onload();\n\n  github = new Github({\n    auth: \"oauth\",\n    token: localStorage.authToken\n  });\n\n  branch = \"master\";\n\n  userName = \"STRd6\";\n\n  repoName = \"editor\";\n\n  repo = null;\n\n  errors = Observable([]);\n\n  notices = Observable([\"Loaded!\"]);\n\n  builder = Builder({\n    errors: errors,\n    notices: notices\n  });\n\n  actions = {\n    save: function() {\n      notices([\"Saving...\"]);\n      return Actions.save({\n        owner: userName,\n        repo: repoName,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        return notices([\"Saved and published!\"]);\n      });\n    },\n    \"new\": function() {\n      var name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        return filetree.files.push(File({\n          filename: name,\n          content: \"\"\n        }));\n      }\n    },\n    run: (function() {\n      notices([\"Building...\"]);\n      return builder.build(filetree.data(), function(fileMap) {\n        var config, sandbox;\n        if (fileMap[\"pixie.json\"]) {\n          config = JSON.parse(fileMap[\"pixie.json\"].content);\n        } else {\n          config = {};\n        }\n        sandbox = Sandbox({\n          width: config.width,\n          height: config.height\n        });\n        sandbox.document.open();\n        sandbox.document.write(builder.standAloneHtml(fileMap));\n        sandbox.document.close();\n        notices([\"Runnnig!\"]);\n        errors([]);\n        return {\n          error: errors\n        };\n      });\n    }).debounce(250),\n    load_repo: function() {\n      var processDirectory, _ref1;\n      repoName = prompt(\"Github repo\", \"STRd6/matrix.js\");\n      if (repoName) {\n        _ref1 = repoName.split(\"/\"), userName = _ref1[0], repoName = _ref1[1];\n      } else {\n        errors([\"No repo given\"]);\n        return;\n      }\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      return Gistquire.latestTree({\n        branch: \"master\",\n        repo: repoName,\n        owner: userName,\n        success: function(data) {\n          var treeFiles;\n          notices([]);\n          treeFiles = data.tree.select(function(file) {\n            return file.type === \"blob\";\n          });\n          return async.map(treeFiles, function(datum, callback) {\n            return Gistquire.api(datum.url, {\n              success: function(data) {\n                return callback(null, Object.extend(datum, data));\n              },\n              error: function(error) {\n                return callback(error);\n              }\n            });\n          }, function(error, results) {\n            notices([\"Radical!\"]);\n            if (error) {\n              errors([error]);\n              return;\n            }\n            files = processDirectory(results);\n            notices([files].map(function(item) {\n              return JSON.stringify(item, null, 2);\n            }));\n            return filetree.load(files);\n          });\n        },\n        error: function(error) {\n          return errors([error]);\n        }\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.templates.editor());\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        return file.content(value);\n      });\n    }\n  });\n\n  $root.append(HAMLjr.templates.main({\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors\n  }));\n\n  Gistquire.api(\"rate_limit\", {\n    complete: function(request, status) {\n      return $root.append(HAMLjr.templates.github_status({\n        request: request\n      }));\n    }\n  });\n\n  if (loadId = (_ref1 = window.location.href.match(/loadId=(\\d+)/)) != null ? _ref1[1] : void 0) {\n    actions.load(null, loadId);\n  }\n\n}).call(this);\n","type":"blob"},"style.css":{"path":"style.css","content":"html,\nbody {\n  margin: 0;\n  height: 100%;\n}\n\n.main {\n  position: relative;\n  padding-top: 40px;\n  padding-left: 200px;\n  padding-bottom: 100px;\n  height: 100%;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.editor-wrap {\n  background-color: white;\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n.editor-wrap > div {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.filetree {\n  margin: 0;\n  padding: 0;\n  width: 200px;\n  position: absolute;\n  left: 0;\n  top: 40px;\n  z-index: 2;\n}\n\n.filetree li {\n  list-style-type: none;\n  padding-left: 1em;\n}\n\n.actions {\n  position: absolute;\n  top: 0;\n  left: 200px;\n}\n\n.console-wrap {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  padding-left: 200px;\n  height: 100px;\n  width: 100%;\n  margin: 0;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.console-wrap .errors {\n  border-top: 1px solid black;\n  color: red;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.status {\n  top: 0;\n  right: 0;\n  position: absolute;\n}","type":"blob"}}
  });
</script>