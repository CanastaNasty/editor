Function("ENV", "(function() {\n  var commit, publish;\n\n  publish = function(_arg) {\n    var builder, fileData, repository;\n    builder = _arg.builder, fileData = _arg.fileData, repository = _arg.repository;\n    return builder.build(fileData).then(function(build) {\n      var branch;\n      branch = repository.branch();\n      return repository.publish(builder.standAlone(build, branch));\n    });\n  };\n\n  commit = function(_arg) {\n    var fileData, message, repository;\n    fileData = _arg.fileData, repository = _arg.repository, message = _arg.message;\n    return repository.commitTree({\n      tree: fileData,\n      message: message\n    });\n  };\n\n  this.Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    },\n    run: function(_arg) {\n      var builder, filetree;\n      builder = _arg.builder, filetree = _arg.filetree;\n      return builder.build(filetree.data()).then(function(build) {\n        var config, html, sandbox, _base;\n        config = Builder.readConfig(build);\n        html = builder.standAlone(build).html;\n        sandbox = Sandbox({\n          width: config.width,\n          height: config.height\n        });\n        sandbox.document.open();\n        sandbox.document.write(html);\n        sandbox.document.close();\n        return typeof (_base = builder.I).notices === \"function\" ? _base.notices([\"Running!\"]) : void 0;\n      });\n    },\n    load: function(_arg) {\n      var filetree, processDirectory, repository;\n      filetree = _arg.filetree, repository = _arg.repository;\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      return repository.latestTree().then(function(results) {\n        var files;\n        files = processDirectory(results);\n        return filetree.load(files);\n      });\n    }\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"actions\"] = function(data) {\n    return (function() {\n      var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"actions\");\n      actions = this.actions;\n      Object.keys(actions).each(function(name) {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, name.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return actions[name]();\n        });\n        return __pop();\n      });\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.issue_selector(this.issues));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var arrayToHash, compileFile, compileStyl, compileTemplate, documentFile, readConfig, stripMarkdown;\n\n  arrayToHash = function(array) {\n    return array.eachWithObject({}, function(file, hash) {\n      return hash[file.path] = file;\n    });\n  };\n\n  stripMarkdown = function(content) {\n    return content.split(\"\\n\").map(function(line) {\n      var match;\n      if (match = /^([ ]{4}|\\t)/.exec(line)) {\n        return line.slice(match[0].length);\n      } else {\n        return \"\";\n      }\n    }).join(\"\\n\");\n  };\n\n  compileTemplate = function(source, name) {\n    var ast;\n    if (name == null) {\n      name = \"test\";\n    }\n    ast = HAMLjr.parser.parse(source);\n    return HAMLjr.compile(ast, {\n      name: name,\n      compiler: CoffeeScript\n    });\n  };\n\n  compileStyl = function(source) {\n    return styl(source, {\n      whitespace: true\n    }).toString();\n  };\n\n  compileFile = function(_arg) {\n    var content, extension, name, path, result, _ref;\n    path = _arg.path, content = _arg.content;\n    _ref = [path.withoutExtension(), path.extension()], name = _ref[0], extension = _ref[1];\n    result = (function() {\n      switch (extension) {\n        case \"js\":\n          return {\n            code: content\n          };\n        case \"coffee\":\n          return {\n            code: CoffeeScript.compile(content)\n          };\n        case \"haml\":\n          return {\n            code: compileTemplate(content, name)\n          };\n        case \"styl\":\n          return {\n            style: compileStyl(content)\n          };\n        case \"md\":\n          return compileFile({\n            path: name,\n            content: stripMarkdown(content)\n          });\n        default:\n          return {};\n      }\n    })();\n    Object.defaults(result, {\n      name: name,\n      extension: extension\n    });\n    return Object.extend(result, {\n      path: path\n    });\n  };\n\n  documentFile = function(content, path) {\n    if (path.extension() === \"md\") {\n      return marked(content);\n    } else {\n      return \"\";\n    }\n  };\n\n  this.Builder = function(I) {\n    var build, postProcessors;\n    if (I == null) {\n      I = {};\n    }\n    compileTemplate = function(source, name) {\n      var ast;\n      if (name == null) {\n        name = \"test\";\n      }\n      ast = HAMLjr.parser.parse(source);\n      return HAMLjr.compile(ast, {\n        name: name,\n        compiler: CoffeeScript\n      });\n    };\n    build = function(fileData) {\n      var data, errors, results, _ref;\n      results = fileData.map(function(_arg) {\n        var content, location, message, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          return compileFile({\n            path: path,\n            content: content\n          });\n        } catch (_error) {\n          location = _error.location, message = _error.message;\n          if (location != null) {\n            message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n          }\n          return {\n            error: \"\" + path + \" - \" + message\n          };\n        }\n      });\n      _ref = results.partition(function(result) {\n        return result.error;\n      }), errors = _ref[0], data = _ref[1];\n      if (errors.length) {\n        return Deferred().reject(errors.map(function(e) {\n          return e.error;\n        }));\n      } else {\n        return Deferred().resolve(data);\n      }\n    };\n    postProcessors = [];\n    return {\n      I: I,\n      addPostProcessor: function(fn) {\n        return postProcessors.push(fn);\n      },\n      buildDocs: function(fileData) {\n        return fileData.map(function(_arg) {\n          var content, location, message, path;\n          path = _arg.path, content = _arg.content;\n          try {\n            return {\n              path: path,\n              documentation: documentFile(content, path)\n            };\n          } catch (_error) {\n            location = _error.location, message = _error.message;\n            if (location != null) {\n              message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n            }\n            return {\n              error: \"\" + path + \" - \" + message\n            };\n          }\n        });\n      },\n      build: function(fileData) {\n        I.notices.push(\"Building...\");\n        return build(fileData).then(function(items) {\n          var dist, distCode, distStyle, results;\n          results = {\n            code: [],\n            style: [],\n            main: []\n          };\n          items.eachWithObject(results, function(item, hash) {\n            var code, style;\n            if (code = item.code) {\n              if (item.name === \"main\" && (item.extension === \"js\" || item.extension === \"coffee\")) {\n                return hash.main.push(code);\n              } else {\n                return hash.code.push(code);\n              }\n            } else if (style = item.style) {\n              return hash.style.push(style);\n            } else {\n\n            }\n          });\n          distCode = results.code.concat(results.main).join(';').trim();\n          distStyle = results.style.join('').trim();\n          dist = [];\n          if (!distCode.blank()) {\n            dist.push({\n              path: \"build.js\",\n              content: distCode,\n              type: \"blob\"\n            });\n          }\n          if (!distStyle.blank()) {\n            dist.push({\n              path: \"style.css\",\n              content: distStyle,\n              type: \"blob\"\n            });\n          }\n          return Deferred().resolve(postProcessors.pipeline({\n            source: arrayToHash(fileData),\n            distribution: arrayToHash(dist)\n          }));\n        });\n      },\n      program: function(build) {\n        var distribution, entryPoint, program;\n        distribution = build.distribution;\n        entryPoint = \"build.js\";\n        program = distribution[entryPoint].content;\n        return \"Function(\\\"ENV\\\", \" + (JSON.stringify(program)) + \")(\" + (JSON.stringify(build)) + \");\";\n      },\n      standAlone: function(build, ref) {\n        var content, dependencyScripts, distribution, makeScript, program, remoteDependencies, scriptTag, source;\n        source = build.source, distribution = build.distribution;\n        makeScript = function(attrs) {\n          return $(\"<script>\", attrs).prop('outerHTML');\n        };\n        content = [];\n        content.push(\"<!doctype html>\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        remoteDependencies = readConfig(build).remoteDependencies;\n        dependencyScripts = remoteDependencies ? remoteDependencies.map(function(src) {\n          return makeScript({\n            \"class\": \"env\",\n            src: src\n          });\n        }) : $('script.env').map(function() {\n          return this.outerHTML;\n        }).get();\n        content = content.concat(dependencyScripts);\n        program = this.program(build);\n        scriptTag = ref ? makeScript({\n          src: \"\" + ref + \".js\"\n        }) : \"<script>\\n\" + program + \"\\n<\\/script>\";\n        content.push(\"</head>\\n<body>\\n\" + scriptTag + \"\\n</body>\\n</html>\");\n        return {\n          html: content.join(\"\\n\"),\n          script: program\n        };\n      }\n    };\n  };\n\n  readConfig = function(build) {\n    var configData, _ref, _ref1;\n    if (configData = (_ref = build.source[\"pixie.cson\"]) != null ? _ref.content : void 0) {\n      return CSON.parse(configData);\n    } else if (configData = (_ref1 = build.source[\"pixie.json\"]) != null ? _ref1.content : void 0) {\n      return JSON.parse(configData);\n    } else {\n      return {};\n    }\n  };\n\n  Builder.readConfig = readConfig;\n\n}).call(this);\n;(function() {\n  var withDeferrence;\n\n  this.Deferred = $.Deferred;\n\n  withDeferrence = function(fn) {\n    var deferred, e;\n    deferred = Deferred();\n    try {\n      fn.defer(deferred);\n    } catch (_error) {\n      e = _error;\n      deferred.reject(e);\n    }\n    return deferred.promise();\n  };\n\n  Deferred.Confirm = function(message) {\n    return withDeferrence(function(deferred) {\n      if (window.confirm(message)) {\n        return deferred.resolve();\n      } else {\n        return deferred.reject();\n      }\n    });\n  };\n\n  Deferred.ConfirmIf = function(flag, message) {\n    if (flag) {\n      return Deferred.Confirm(message);\n    } else {\n      return withDeferrence(function(deferred) {\n        return deferred.resolve();\n      });\n    }\n  };\n\n  Deferred.ExecuteIf = function(flag, callback) {\n    return withDeferrence(function(deferred) {\n      if (flag) {\n        return callback().then(deferred.resolve);\n      } else {\n        return deferred.resolve();\n      }\n    });\n  };\n\n}).call(this);\n;(function() {\n  String.prototype.dasherize = function() {\n    return this.trim().replace(/\\s+/g, \"-\").toLowerCase();\n  };\n\n  this.Base64 = {\n    encode: function(s) {\n      return btoa(unescape(encodeURIComponent(s)));\n    },\n    decode: function(s) {\n      return decodeURIComponent(escape(atob(s.replace(/\\s/g, ''))));\n    }\n  };\n\n  this.CSON = {\n    parse: function(source) {\n      return Function(\"return \" + (CoffeeScript.compile(source, {\n        bare: true\n      })))();\n    },\n    stringify: function(object) {\n      var representation;\n      representation = JSON.parse(JSON.stringify(obj));\n      return Object.keys(representation).map(function(key) {\n        var value;\n        value = representation[key];\n        return \"\" + key + \": \" + (JSON.stringify(value));\n      }).join(\"\\n\");\n    }\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"editor\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor\");\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"errors\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"console-wrap\");\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"errors\");\n      __each(this.errors, function(error) {\n        __element = document.createTextNode('');\n        __text(__element, error);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"notices\");\n      __each(this.notices, function(notice) {\n        __element = document.createTextNode('');\n        __text(__element, notice);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          case \"md\":\n            return \"markdown\";\n          case \"\":\n            return \"text\";\n          default:\n            return extension;\n        }\n      },\n      modified: Observable(false),\n      displayName: Observable(self.path())\n    });\n    self.content.observe(function() {\n      return self.modified(true);\n    });\n    self.modified.observe(function(modified) {\n      if (modified) {\n        return self.displayName(\"*\" + (self.path()));\n      } else {\n        return self.displayName(self.path());\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  this.Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        if (Array.isArray(fileData)) {\n          files = fileData.sort(function(a, b) {\n            if (a.path < b.path) {\n              return -1;\n            } else if (b.path < a.path) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).map(File);\n        } else {\n          files = Object.keys(fileData).sort().map(function(name) {\n            return File(fileData[name]);\n          });\n        }\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.filename(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      },\n      hasUnsavedChanges: function() {\n        return self.files().select(function(file) {\n          return file.modified();\n        }).length;\n      },\n      markSaved: function() {\n        return self.files().each(function(file) {\n          return file.modified(false);\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"filetree\"] = function(data) {\n    return (function() {\n      var files, selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"filetree\");\n      selectedFile = this.selectedFile;\n      files = this.files;\n      __each(files, function(file) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, file.displayName);\n        __push(__element);\n        __pop();\n        __on(\"click\", function(e) {\n          if ($(e.target).is('li')) {\n            return selectedFile(file);\n          }\n        });\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"delete\");\n        __on(\"click\", function() {\n          if (confirm(\"Delete \" + (file.path()) + \"?\")) {\n            return files.remove(file);\n          }\n        });\n        __element = document.createTextNode('');\n        __text(__element, \"X\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"gist_list\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"gists\");\n      __each(this.gists, function(gist) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, gist.id);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return alert(gist.id);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    }\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"github_status\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"status\");\n      if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n        __element = document.createTextNode('');\n        __text(__element, \"Authenticated Scopes:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n        __push(__element);\n        __pop();\n        __element = document.createElement(\"br\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \"Rate Limit Remaining:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \" / 5000\");\n        __push(__element);\n        __pop();\n      } else {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Auth\\n\");\n        __push(__element);\n        __pop();\n        __on(\"click\", Gistquire.auth);\n        __pop();\n      }\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.Issue = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    self = Model(I);\n    self.extend({\n      optionText: function() {\n        return \"\" + I.title;\n      },\n      fullDescription: function() {\n        return \"\" + (self.optionText()) + \"\\n\" + I.html_url + \"\\n\" + I.body;\n      },\n      branchName: function() {\n        var _ref;\n        return ((_ref = I.head) != null ? _ref.ref : void 0) || (\"issue-\" + I.number);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"issue_selector\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"select\");\n      __push(__element);\n      __on(\"change\", this.currentIssue);\n      __element = document.createElement(\"option\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"- Default Branch -\");\n      __push(__element);\n      __pop();\n      __pop();\n      __each(this.issues, function() {\n        __element = document.createElement(\"option\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, this.optionText());\n        __push(__element);\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.Issues = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      issues: []\n    });\n    self = Model(I);\n    self.attrModels(\"issues\");\n    self.attrObservable(\"currentIssue\");\n    self.extend({\n      reset: function(issueData) {\n        self.currentIssue(void 0);\n        return self.issues(issueData.map(Issue));\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"main\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"main\");\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.actions({\n        actions: this.actions,\n        issues: this.issues\n      }));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.filetree(this.filetree));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.errors(this));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var __slice = [].slice;\n\n  this.Repository = function(I) {\n    var api, get, patch, post, put, requestOptions, self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      branch: \"master\",\n      defaultBranch: \"master\"\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"branch\");\n    requestOptions = function(type, data) {\n      return {\n        type: type,\n        data: JSON.stringify(data)\n      };\n    };\n    api = function(path, options) {\n      var url;\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"\" + (self.url()) + \"/\" + path;\n      }\n      return Gistquire.api(url, options);\n    };\n    get = function(path, data) {\n      return api(path, {\n        data: data\n      });\n    };\n    put = function(path, data) {\n      return api(path, requestOptions(\"PUT\", data));\n    };\n    post = function(path, data) {\n      return api(path, requestOptions(\"POST\", data));\n    };\n    patch = function(path, data) {\n      return api(path, requestOptions(\"PATCH\", data));\n    };\n    self.extend({\n      pullRequests: function() {\n        return get(\"pulls\");\n      },\n      createPullRequest: function(_arg) {\n        var head, title;\n        title = _arg.title;\n        head = title.dasherize();\n        return self.switchToBranch(head).then(self.commitEmpty).then(function() {\n          return post(\"pulls\", {\n            base: I.defaultBranch,\n            head: head,\n            title: title\n          });\n        });\n      },\n      initPagesBranch: function() {\n        var branch;\n        branch = \"gh-pages\";\n        return post(\"git/trees\", {\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/editor\"\n            }\n          ]\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            message: \"Initial gh-pages commit\",\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return post(\"git/refs\", {\n            ref: \"refs/heads/\" + branch,\n            sha: data.sha\n          });\n        });\n      },\n      writeFile: function(params) {\n        var branch, content, message, path;\n        branch = params.branch, path = params.path, content = params.content, message = params.message;\n        return get(\"contents/\" + path, {\n          ref: branch\n        }).then(function(data) {\n          return put(\"contents/\" + path, {\n            content: content,\n            sha: data.sha,\n            message: message,\n            branch: branch\n          });\n        }, function(request) {\n          var _ref, _ref1;\n          if (((_ref = request.responseJSON) != null ? _ref.message : void 0) === \"No commit found for the ref gh-pages\") {\n            return self.initPagesBranch().then(function() {\n              return self.writeFile(params);\n            });\n          } else if (request.status === 404) {\n            return put(\"contents/\" + path, {\n              content: content,\n              message: message,\n              branch: branch\n            });\n          } else {\n            return (_ref1 = Deferred()).reject.apply(_ref1, arguments);\n          }\n        });\n      },\n      latestTree: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return get(\"\" + data.tree.url + \"?recursive=1\");\n        }).then(function(data) {\n          var files;\n          files = data.tree.select(function(file) {\n            return file.type === \"blob\";\n          });\n          return $.when.apply(null, files.map(function(datum) {\n            return get(datum.url).then(function(data) {\n              return Object.extend(datum, data);\n            });\n          }));\n        }).then(function() {\n          var results;\n          results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return results;\n        });\n      },\n      commitTree: function(_arg) {\n        var branch, latestCommitSha, message, tree;\n        message = _arg.message, tree = _arg.tree;\n        branch = self.branch();\n        if (message == null) {\n          message = \"Updated in browser at strd6.github.io/editor\";\n        }\n        if (!tree) {\n          throw Error(\"Must pass in a tree\");\n        }\n        latestCommitSha = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          latestCommitSha = data.object.sha;\n          return post(\"git/trees\", {\n            tree: tree\n          });\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [latestCommitSha],\n            message: message,\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      commitEmpty: function() {\n        var branch, latestCommit;\n        branch = self.branch();\n        latestCommit = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [data.sha],\n            message: \"This commit intentionally left blank\",\n            tree: data.tree.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      switchToBranch: function(branch) {\n        var ref, setBranch;\n        ref = \"refs/heads/\" + branch;\n        setBranch = function(data) {\n          self.branch(branch);\n          return data;\n        };\n        return get(\"git/\" + ref).then(setBranch, function(request) {\n          var branchNotFound, _ref;\n          branchNotFound = request.status === 404;\n          if (branchNotFound) {\n            return get(\"git/refs/heads/\" + (self.branch())).then(function(data) {\n              return post(\"git/refs\", {\n                ref: ref,\n                sha: data.object.sha\n              });\n            }).then(setBranch);\n          } else {\n            return (_ref = Deferred()).reject.apply(_ref, arguments);\n          }\n        });\n      },\n      mergeInto: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: branch,\n          head: self.branch()\n        });\n      },\n      pullFromBranch: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: self.branch(),\n          head: branch\n        });\n      },\n      publish: function(_arg) {\n        var branch, html, message, path, promise, publishBranch, script;\n        html = _arg.html, script = _arg.script;\n        branch = self.branch();\n        message = \"Built \" + branch + \" in browser in strd6.github.io/tempest\";\n        if (branch === \"master\") {\n          path = \"index.html\";\n        } else {\n          path = \"\" + branch + \".html\";\n        }\n        publishBranch = \"gh-pages\";\n        promise = self.writeFile({\n          path: path,\n          content: Base64.encode(html),\n          branch: publishBranch,\n          message: message\n        });\n        if (script) {\n          return promise.then(self.writeFile({\n            path: \"\" + branch + \".js\",\n            content: Base64.encode(script),\n            branch: publishBranch,\n            message: message\n          }));\n        } else {\n          return promise;\n        }\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  this.TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var $root, actions, branch, builder, classicError, confirmUnsaved, currentNode, distribution, errors, files, filetree, fullName, issues, notices, notify, owner, repo, repository, repositoryLoaded, styleContent, _ref, _ref1;\n\n  files = ENV.source, distribution = ENV.distribution;\n\n  window.ENV = ENV;\n\n  classicError = function(request) {\n    var message;\n    notices([]);\n    if (request.responseJSON) {\n      message = JSON.stringify(request.responseJSON, null, 2);\n    } else {\n      message = \"Error\";\n    }\n    return errors([message]);\n  };\n\n  notify = function(message) {\n    notices([message]);\n    return errors([]);\n  };\n\n  currentNode = function() {\n    var target;\n    target = document.documentElement;\n    while (target.childNodes.length && target.lastChild.nodeType === 1) {\n      target = target.lastChild;\n    }\n    return target.parentNode;\n  };\n\n  $root = $(currentNode());\n\n  if (styleContent = (_ref = distribution[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  Gistquire.onload();\n\n  _ref1 = ENV.repository, owner = _ref1.owner, repo = _ref1.repo, branch = _ref1.branch, fullName = _ref1.full_name;\n\n  fullName || (fullName = \"\" + owner + \"/\" + repo);\n\n  repository = Repository({\n    url: \"repos/\" + fullName\n  });\n\n  errors = Observable([]);\n\n  notices = Observable([\"Loaded!\"]);\n\n  builder = Builder({\n    errors: errors,\n    notices: notices\n  });\n\n  repositoryLoaded = function(repository) {\n    issues.repository = repository;\n    repository.pullRequests().then(issues.reset);\n    return notices([\"Finished loading!\"]);\n  };\n\n  confirmUnsaved = function() {\n    return Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\");\n  };\n\n  issues = Issues();\n\n  builder.addPostProcessor(function(data) {\n    data.repository = {\n      full_name: fullName,\n      branch: branch\n    };\n    return data;\n  });\n\n  builder.addPostProcessor(function(data) {\n    data.progenitor = {\n      url: \"http://strd6.github.io/editor/\"\n    };\n    return data;\n  });\n\n  actions = {\n    save: function() {\n      notices([\"Saving...\"]);\n      return Actions.save({\n        repository: repository,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        filetree.markSaved();\n        return notices([\"Saved and published!\"]);\n      });\n    },\n    run: function() {\n      return Actions.run({\n        builder: builder,\n        filetree: filetree\n      }).fail(errors);\n    },\n    new_file: function() {\n      var name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        return filetree.files.push(File({\n          filename: name,\n          content: \"\"\n        }));\n      }\n    },\n    load_repo: function(skipPrompt) {\n      return confirmUnsaved().then(function() {\n        if (!skipPrompt) {\n          fullName = prompt(\"Github repo\", fullName);\n        }\n        if (fullName) {\n          repository = Repository({\n            url: \"repos/\" + fullName\n          });\n        } else {\n          errors([\"No repo given\"]);\n          return;\n        }\n        notices([\"Loading repo...\"]);\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return repositoryLoaded(repository);\n        }).fail(function() {\n          return errors([\"Error loading \" + (repository.url())]);\n        });\n      });\n    },\n    new_feature: function() {\n      var title;\n      if (title = prompt(\"Description\")) {\n        notices([\"Creating feature branch...\"]);\n        return repository.createPullRequest({\n          title: title\n        }).then(function(data) {\n          var issue;\n          issue = Issue(data);\n          issues.issues.push(issue);\n          issues.silent = true;\n          issues.currentIssue(issue);\n          issues.silent = false;\n          return notices.push(\"Created!\");\n        }, classicError);\n      }\n    },\n    pull_master: function() {\n      return confirmUnsaved().then(function() {\n        notify(\"Merging in default branch...\");\n        return repository.pullFromBranch();\n      }, classicError).then(function() {\n        var branchName;\n        notices.push(\"Merged!\");\n        branchName = repository.branch();\n        notices.push(\"\\nReloading branch \" + branchName + \"...\");\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return notices.push(\"Loaded!\");\n        });\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.templates.editor());\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        return file.content(value);\n      });\n    }\n  });\n\n  repositoryLoaded(repository);\n\n  issues.currentIssue.observe(function(issue) {\n    var changeBranch;\n    if (issues.silent) {\n      return;\n    }\n    changeBranch = function(branchName) {\n      var previousBranch;\n      previousBranch = repository.branch();\n      return confirmUnsaved().then(function() {\n        return repository.switchToBranch(branchName).then(function() {\n          notices.push(\"\\nLoading branch \" + branchName + \"...\");\n          return Actions.load({\n            repository: repository,\n            filetree: filetree\n          }).then(function() {\n            return notices.push(\"Loaded!\");\n          });\n        });\n      }, function() {\n        repository.branch(previousBranch);\n        return errors([\"Error switching to \" + branchName + \", still on \" + previousBranch]);\n      });\n    };\n    if (issue) {\n      notify(issue.fullDescription());\n      return changeBranch(issue.branchName());\n    } else {\n      notify(\"Default branch selected\");\n      return changeBranch(repository.defaultBranch());\n    }\n  });\n\n  $root.append(HAMLjr.templates.main({\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors,\n    issues: issues\n  }));\n\n  Gistquire.api(\"rate_limit\", {\n    complete: function(request, status) {\n      return $root.append(HAMLjr.templates.github_status({\n        request: request\n      }));\n    }\n  });\n\n  window.onbeforeunload = function() {\n    if (filetree.hasUnsavedChanges()) {\n      return \"You have some unsaved changes, if you leave now you will lose your work.\";\n    }\n  };\n\n}).call(this);")({"source":{"TODO":{"path":"TODO","mode":"100644","content":"TODO\n----\nBundled Dependencies\n- Build bundled dependencies into published script\n- Dependency source should not be in revision control\n- Should dependency build files appear in publish metadata?\n- One day we'll need to implement a bundleresque system, but not today\n\nGenerate Docs\n\nHighlighting for Literate Code\n\nLive Update Demo\n- Hot reload css\n- Display Demo Runtime Errors in console\n\nOpen published page in editor and run live demo with same state as when editor was opened\n- Pass git repo/branch metadata to published page for use in editor\n\nPersist state across demo reloads\n\nOrganize File tree by type\nFile icons\n\n.haml and .styl file type support\n- Build our own ace cdn\n\nTests\n\nDisplay Diffs\n\nFirst auth doesn't display in bar\n\nCache Git trees and files in some form of local storage\n\nSometimes editor appears blank when switching files\n\nEditor plugins\n- static analysis\n- find in files\n- source file hygiene\n","type":"blob"},"actions.coffee":{"path":"actions.coffee","mode":"100644","content":"publish = ({builder, fileData, repository}) ->\n  \n    builder.build(fileData)\n    .then (build) ->\n      branch = repository.branch()\n\n      repository.publish builder.standAlone(build, branch)\n\ncommit = ({fileData, repository, message}) ->\n  repository.commitTree\n    tree: fileData\n    message: message\n\n@Actions =\n  save: (params) ->\n    commit(params)\n    .then ->\n      publish(params)\n\n  run: ({builder, filetree}) ->\n    builder.build(filetree.data())\n    .then (build) ->\n      config = Builder.readConfig(build)\n\n      html = builder.standAlone(build).html\n\n      sandbox = Sandbox\n        width: config.width\n        height: config.height\n\n      sandbox.document.open()\n      sandbox.document.write(html)\n      sandbox.document.close()\n\n      builder.I.notices? [\"Running!\"]\n      # TODO: Catch and display runtime errors\n\n  load: ({filetree, repository}) ->\n    # Decode all content in place\n    processDirectory = (items) ->\n      items.each (item) ->\n        return item unless item.content\n\n        item.content = Base64.decode(item.content)\n        item.encoding = \"raw\"\n\n    repository.latestTree()\n    .then (results) ->\n      files = processDirectory results\n      filetree.load files\n","type":"blob"},"actions.haml":{"path":"actions.haml","mode":"100644","content":".actions\n  - actions = @actions\n  - Object.keys(actions).each (name) ->\n    %button\n      = name.titleize()\n      - on \"click\", ->\n        - actions[name]()\n\n  = HAMLjr.templates.issue_selector @issues\n","type":"blob"},"builder.coffee":{"path":"builder.coffee","mode":"100644","content":"arrayToHash = (array) ->\n  array.eachWithObject {}, (file, hash) ->\n    hash[file.path] = file\n\nstripMarkdown = (content) ->\n  content.split(\"\\n\").map (line) ->\n    if match = (/^([ ]{4}|\\t)/).exec line\n      line[match[0].length..]\n    else\n      \"\"\n  .join(\"\\n\")\n\ncompileTemplate = (source, name=\"test\") ->\n  ast = HAMLjr.parser.parse(source)\n  \n  HAMLjr.compile ast, \n    name: name\n    compiler: CoffeeScript\n    \ncompileStyl = (source) ->\n  styl(source, whitespace: true).toString()\n\ncompileFile = ({path, content}) ->\n  [name, extension] = [path.withoutExtension(), path.extension()]\n  \n  result =\n    switch extension\n      when \"js\"\n        code: content\n      when \"coffee\"\n        code: CoffeeScript.compile(content)\n      when \"haml\"\n        code: compileTemplate(content, name)\n      when \"styl\"\n        style: compileStyl(content)\n      when \"md\"\n        # Separate out code and call compile again\n        compileFile\n          path: name\n          content: stripMarkdown(content)\n      else\n        {}\n\n  Object.defaults result,\n    name: name\n    extension: extension\n\n  Object.extend result,\n    path: path\n\n# TODO: Maybe doc more files than just .md?\ndocumentFile = (content, path) ->\n  if path.extension() is \"md\"\n    marked(content)\n  else\n    \"\"\n\n@Builder = (I={}) ->\n  compileTemplate = (source, name=\"test\") ->\n    ast = HAMLjr.parser.parse(source)\n    \n    HAMLjr.compile ast, \n      name: name\n      compiler: CoffeeScript\n  \n  build = (fileData) ->    \n    results = fileData.map ({path, content}) ->\n      try\n        # TODO: Separate out tests\n\n        compileFile\n          path: path\n          content: content\n      catch {location, message}\n        if location?\n          message = \"Error on line #{location.first_line + 1}: #{message}\"\n\n        error: \"#{path} - #{message}\"\n        \n    [errors, data] = results.partition (result) -> result.error\n    \n    if errors.length\n      Deferred().reject(errors.map (e) -> e.error)\n    else\n      Deferred().resolve(data)\n\n  postProcessors = []\n\n  I: I\n  \n  addPostProcessor: (fn) ->\n    postProcessors.push fn\n    \n  buildDocs: (fileData) ->\n    fileData.map ({path, content}) ->\n      try\n        path: path\n        documentation: documentFile(content, path)\n      catch {location, message}\n        if location?\n          message = \"Error on line #{location.first_line + 1}: #{message}\"\n\n        error: \"#{path} - #{message}\"\n\n  build: (fileData) ->\n    I.notices.push \"Building...\"\n\n    build(fileData).then (items) ->\n      results =\n        code: []\n        style: []\n        main: []\n\n      items.eachWithObject results, (item, hash) ->\n        if code = item.code\n          if item.name is \"main\" and (item.extension is \"js\" or item.extension is \"coffee\")\n            hash.main.push code\n          else\n            hash.code.push code\n        else if style = item.style\n          hash.style.push style\n        else\n          # Do nothing, we don't know about this item\n      \n      distCode = results.code.concat(results.main).join(';').trim()\n      distStyle = results.style.join('').trim()\n  \n      dist = []\n  \n      unless distCode.blank()\n        dist.push\n          path: \"build.js\"\n          content: distCode\n          type: \"blob\"\n  \n      unless distStyle.blank()\n        dist.push\n          path: \"style.css\"\n          content: distStyle\n          type: \"blob\"\n  \n      Deferred().resolve postProcessors.pipeline\n        source: arrayToHash(fileData)\n        distribution: arrayToHash(dist)\n\n  program: (build) ->\n    {distribution} = build\n\n    entryPoint = \"build.js\"\n    program = distribution[entryPoint].content\n\n    \"\"\"\n      Function(\"ENV\", #{JSON.stringify(program)})(#{JSON.stringify(build)});\n    \"\"\"\n\n  standAlone: (build, ref) ->\n    {source, distribution} = build\n\n    makeScript = (attrs) -> \n      $(\"<script>\", attrs).prop('outerHTML')\n\n    content = []\n\n    content.push \"\"\"\n      <!doctype html>\n      <head>\n      <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    \"\"\"\n    \n    remoteDependencies = readConfig(build).remoteDependencies\n\n    dependencyScripts = if remoteDependencies\n      remoteDependencies.map (src) ->\n        makeScript\n          class: \"env\"\n          src: src\n    else # Carry forward our own env if no dependencies specified\n      $('script.env').map ->\n        @outerHTML\n      .get()\n\n    content = content.concat dependencyScripts\n\n    program = @program(build)\n\n    scriptTag = if ref\n      makeScript\n        src: \"#{ref}.js\"\n    else\n      \"\"\"\n      <script>\n      #{program}\n      <\\/script>\n      \"\"\"\n\n    content.push \"\"\"\n      </head>\n      <body>\n      #{scriptTag}\n      </body>\n      </html>\n    \"\"\"\n\n    html: content.join \"\\n\"\n    script: program\n\n# TODO: May want to move this to the environment so any program can read its\n# config\nreadConfig = (build) ->\n  if configData = build.source[\"pixie.cson\"]?.content\n    CSON.parse(configData)\n  else if configData = build.source[\"pixie.json\"]?.content\n    JSON.parse(configData)\n  else\n    {}\n\nBuilder.readConfig = readConfig\n","type":"blob"},"deferred.coffee":{"path":"deferred.coffee","mode":"100644","content":"# Use jQuery.Deferred to implement deferreds, but\n# stay insulated by not blasting the $ all over our code\n# that doesn't really depend on jQuery\n# This let's us swap our our Deferred provider more easily later.\n@Deferred = $.Deferred\n\nwithDeferrence = (fn) ->\n  deferred = Deferred()\n\n  # TODO: This try catch may be useless from deferring the fn\n  try\n    fn.defer(deferred)\n  catch e\n    deferred.reject(e)\n\n  return deferred.promise()\n\nDeferred.Confirm = (message) ->\n  withDeferrence (deferred) ->\n    if window.confirm(message)\n      deferred.resolve()\n    else\n      deferred.reject()\n\nDeferred.ConfirmIf = (flag, message) ->\n  if flag\n    return Deferred.Confirm(message)\n  else\n    withDeferrence (deferred) ->\n      deferred.resolve()\n\nDeferred.ExecuteIf = (flag, callback) ->\n  withDeferrence (deferred) ->\n    if flag\n      callback().then deferred.resolve\n    else\n      deferred.resolve()\n","type":"blob"},"duct_tape.coffee.md":{"path":"duct_tape.coffee.md","mode":"100644","content":"Here we have simple extension and utility methods that should be moved into our framework's environment libraries.\n\n`String#dasherize` should be moved into inflecta.\n\nConvert a string with spaces and mixed case into all lower case with spaces replaced with dashes. This is the style that Github branch names are commonly in.\n\n    String::dasherize = ->\n      @trim()\n        .replace(/\\s+/g, \"-\")\n        .toLowerCase()\n\n`Base64` should be moved into a browser polyfil library.\n\nUTF-8 Enabled base64 encoding and decoding.\n\n    @Base64 =\n      encode: (s) ->\n        btoa(unescape(encodeURIComponent(s)))\n    \n      decode: (s) ->\n        decodeURIComponent(escape(atob(s.replace(/\\s/g, ''))))\n\n`CSON` parses CoffeeScript object literals. This is a big hack, but can be \nformalized later if it proves useful.\n\nAnother downside is that it depends on the CoffeeScript compiler when it should\nbe a simple parser of its own.\n\n    @CSON =\n      parse: (source) ->\n        Function(\"return #{CoffeeScript.compile(source, bare: true)}\")()\n\nThis really needs to be improved. To do it correctly we'd need to detect \nobject/array values and indent while moving them to separate lines. Single\nvalues would exist without newlines or indentation. CSON.stringify would be\ncalled recursively.\n\nThe current hack of using JSON works because JSON is valid CSON.\n\n      stringify: (object) ->\n        representation = JSON.parse(JSON.stringify(obj))\n\n        Object.keys(representation).map (key) ->\n          value = representation[key]\n          \"#{key}: #{JSON.stringify(value)}\"\n        .join(\"\\n\")","type":"blob"},"editor.haml":{"path":"editor.haml","mode":"100644","content":".editor-wrap\n  .editor\n","type":"blob"},"errors.haml":{"path":"errors.haml","mode":"100644","content":".console-wrap\n  %pre.errors\n    - each @errors, (error) ->\n      = error\n  %pre.notices\n    - each @notices, (notice) ->\n      = notice\n","type":"blob"},"file.coffee":{"path":"file.coffee","mode":"100644","content":"@File = (I={}) ->\n  I.path ?= I.filename\n  I.filename ?= I.path.split(\"/\").last()\n\n  self = Model(I).observeAll()\n\n  self.extend\n    extension: ->\n      self.filename().extension()\n\n    mode: ->\n      switch extension = self.extension()\n        when \"js\"\n          \"javascript\"\n        when \"md\" # TODO: See about nested markdown code modes for .haml.md, .js.md, and .coffee.md\n          \"markdown\"\n        when \"\"\n          \"text\"\n        else\n          extension\n\n    modified: Observable(false)\n\n    displayName: Observable(self.path())\n\n  self.content.observe ->\n    self.modified(true)\n    \n  self.modified.observe (modified) ->\n    if modified\n      self.displayName(\"*#{self.path()}\")\n    else\n      self.displayName(self.path())\n\n  return self\n","type":"blob"},"filetree.coffee":{"path":"filetree.coffee","mode":"100644","content":"@Filetree = (I={}) ->\n  Object.defaults I,\n    files: []\n\n  self = Model(I).observeAll()\n\n  self.attrObservable \"selectedFile\"\n\n  self.extend\n    # Load files either from an array of file data objects\n    # or from an object with filenames as keys and file data objects as values\n    load: (fileData) ->\n      if Array.isArray(fileData)\n        files = fileData.sort (a, b) ->\n          if a.path < b.path\n            -1\n          else if b.path < a.path\n            1\n          else\n            0\n        .map File\n\n      else\n        files = Object.keys(fileData).sort().map (name) ->\n          File fileData[name]\n\n      self.files(files)\n\n    data: ->\n      self.files.map (file) ->\n        path: file.filename()\n        mode: \"100644\"\n        content: file.content()\n        type: \"blob\"\n\n    hasUnsavedChanges: ->\n      self.files().select (file) ->\n        file.modified()\n      .length\n\n    # TODO: Use git trees and content shas to robustly manage changed state\n    markSaved: ->\n      self.files().each (file) ->\n        file.modified(false)\n\n  return self\n","type":"blob"},"filetree.haml":{"path":"filetree.haml","mode":"100644","content":"%ul.filetree\n  - selectedFile = @selectedFile\n  - files = @files\n  - each files, (file) ->\n    %li= file.displayName\n      - on \"click\", (e) -> \n        - selectedFile(file) if $(e.target).is('li')\n      .delete\n        - on \"click\", -> files.remove(file) if confirm(\"Delete #{file.path()}?\")\n        X\n","type":"blob"},"gist_list.haml":{"path":"gist_list.haml","mode":"100644","content":"%ul.gists\n  - each @gists, (gist) ->\n    %li= gist.id\n      - on \"click\", ->\n        - alert gist.id\n","type":"blob"},"gistquire.coffee":{"path":"gistquire.coffee","mode":"100644","content":"@Gistquire =\n  accessToken: null\n\n  # Calling auth will redirect to github for authentication\n  auth: ->\n    scope = \"gist,repo,user:email\"\n    url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=#{scope}\"\n\n    window.location = url\n\n  # Call onload to check for the code returned from github authentication\n  # and to get our access token from our authorization app.\n  onload: ->\n    # TODO: Namespace local storage key\n\n    if code = window.location.href.match(/\\?code=(.*)/)?[1]\n      $.getJSON \"https://hamljr-auth.herokuapp.com/authenticate/#{code}\", (data) =>\n        if token = data.token\n          @accessToken = token\n          localStorage.authToken = token\n\n    if localStorage.authToken\n      @accessToken = localStorage.authToken\n\n  api: (path, options={}) ->\n    if path.match /^http/\n      url = path\n    else\n      url = \"https://api.github.com/#{path}\"\n    \n    options.headers ||= {}\n    \n    if @accessToken\n      options.headers[\"Authorization\"] = \"token #{@accessToken}\"\n\n    options = Object.extend\n      url: url\n      type: \"GET\"\n      dataType: 'json'\n    , options\n\n    $.ajax options\n","type":"blob"},"github_status.haml":{"path":"github_status.haml","mode":"100644","content":".status\n  - if @request and @request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)\n    Authenticated Scopes:\n    = @request.getResponseHeader(\"X-OAuth-Scopes\")\n    %br\n    Rate Limit Remaining:\n    = @request.getResponseHeader(\"X-RateLimit-Remaining\")\n    = \" / 5000\"\n  - else\n    %button Auth\n      - on \"click\", Gistquire.auth\n","type":"blob"},"issue.coffee":{"path":"issue.coffee","mode":"100644","content":"# TODO: These should mainly only be pull requests, but may have to be compatible\n# with issues created outside the system.\n@Issue = (I={}) ->\n  self = Model(I)\n\n  self.extend\n    optionText: ->\n      \"#{I.title}\"\n\n    fullDescription: ->\n      \"\"\"\n        #{self.optionText()}\n        #{I.html_url}\n        #{I.body}\n      \"\"\"\n\n    branchName: ->\n      I.head?.ref or \"issue-#{I.number}\"\n\n  return self\n","type":"blob"},"issue_selector.haml":{"path":"issue_selector.haml","mode":"100644","content":"%select\n  - on \"change\", @currentIssue\n  %option= \"- Default Branch -\"\n  - each @issues, ->\n    %option= @optionText()\n","type":"blob"},"issues.coffee":{"path":"issues.coffee","mode":"100644","content":"@Issues = (I={}) ->\n  Object.defaults I,\n    issues: []\n\n  self = Model(I)\n\n  self.attrModels \"issues\"\n  self.attrObservable \"currentIssue\"\n\n  self.extend\n    reset: (issueData) ->\n      self.currentIssue(undefined)\n      self.issues issueData.map(Issue)\n\n  return self\n","type":"blob"},"main.coffee":{"path":"main.coffee","mode":"100644","content":"# Get stuff from our env\n{source:files, distribution} = ENV\n\n# For debugging\nwindow.ENV = ENV\n\n# TODO: Move notifications stuff into its own class\nclassicError = (request) ->\n  notices []\n  \n  if request.responseJSON\n    message = JSON.stringify(request.responseJSON, null, 2)\n  else\n    message = \"Error\"\n\n  errors [message]\n\nnotify = (message) ->\n  notices [message]\n  errors []\n\n# TODO: Move to env utils\ncurrentNode = ->\n  target = document.documentElement\n\n  while (target.childNodes.length and target.lastChild.nodeType == 1)\n    target = target.lastChild\n\n  return target.parentNode\n\n# The root is the node that contains the script file.\n$root = $(currentNode())\n\n# Apply our styles\nif styleContent = distribution[\"style.css\"]?.content\n  $root.append $(\"<style>\",\n    html: styleContent\n  )\n\n# Init Github access token stuff\nGistquire.onload()\n  \n# TODO: Real branch and repo info, maybe from ENV\n{owner, repo, branch, full_name:fullName} = ENV.repository\n\nfullName ||= \"#{owner}/#{repo}\"\n\nrepository = Repository\n  url: \"repos/#{fullName}\"\n\nerrors = Observable([])\nnotices = Observable([\"Loaded!\"])\n\nbuilder = Builder\n  errors: errors\n  notices: notices\n\nrepositoryLoaded = (repository) ->\n  issues.repository = repository\n  repository.pullRequests().then issues.reset\n  \n  notices [\"Finished loading!\"]\n  \nconfirmUnsaved = ->\n  Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\")\n\nissues = Issues()\n\n# Repo metadata for env\nbuilder.addPostProcessor (data) ->\n  # TODO: Track commit SHA as well\n  data.repository =\n    full_name: fullName\n    branch: branch\n\n  data\n\nbuilder.addPostProcessor (data) ->\n  # TODO: Think about a robust way to get 'self' and set it as progenitor data\n  data.progenitor =\n    url: \"http://strd6.github.io/editor/\"\n\n  data\n\nactions =\n  save: ->\n    notices [\"Saving...\"]\n    \n    Actions.save\n      repository: repository\n      fileData: filetree.data()\n      builder: builder\n    .then ->\n      # TODO: This could get slightly out of sync if there were changes\n      # during the async call\n      # The correct solution will be to use git shas to determine changed status\n      # but that's a little heavy duty for right now.\n      filetree.markSaved()\n      notices [\"Saved and published!\"]\n\n  run: ->\n    Actions.run({builder, filetree})\n    .fail errors\n\n  new_file: ->\n    if name = prompt(\"File Name\", \"newfile.coffee\")\n      filetree.files.push File\n        filename: name\n        content: \"\"\n\n  load_repo: (skipPrompt) ->\n    confirmUnsaved()\n    .then ->\n      fullName = prompt(\"Github repo\", fullName) unless skipPrompt\n\n      if fullName\n        repository = Repository\n          url: \"repos/#{fullName}\"\n      else\n        errors [\"No repo given\"]\n  \n        return\n  \n      notices [\"Loading repo...\"]\n  \n      Actions.load\n        repository: repository\n        filetree: filetree\n      .then ->\n        repositoryLoaded(repository)\n      .fail ->\n        errors [\"Error loading #{repository.url()}\"]\n        \n  new_feature: ->\n    if title = prompt(\"Description\")\n      notices [\"Creating feature branch...\"]\n    \n      repository.createPullRequest\n        title: title\n      .then (data) ->\n        issue = Issue(data)\n        issues.issues.push issue\n\n        # TODO: Standardize this like backbone or something\n        # or think about using deferreds in some crazy way\n        issues.silent = true\n        issues.currentIssue issue\n        issues.silent = false\n\n        notices.push \"Created!\"\n      , classicError\n      \n  pull_master: ->\n    confirmUnsaved()\n    .then( ->\n      notify \"Merging in default branch...\"\n      repository.pullFromBranch()\n    , classicError\n    ).then ->\n      notices.push \"Merged!\"\n      \n      branchName = repository.branch()\n      notices.push \"\\nReloading branch #{branchName}...\"\n        \n      Actions.load\n        repository: repository\n        filetree: filetree\n      .then ->\n        notices.push \"Loaded!\"\n\nfiletree = Filetree()\nfiletree.load(files)\n\nfiletree.selectedFile.observe (file) ->\n  root = $root.children(\".main\")\n  root.find(\".editor-wrap\").hide()\n  \n  if file.editor\n    file.editor.trigger(\"show\")\n  else\n    root.append(HAMLjr.templates.editor())\n    file.editor = root.find(\".editor-wrap\").last()\n    \n    editor = TextEditor\n      text: file.content()\n      el: file.editor.find('.editor').get(0)\n      mode: file.mode()\n\n    file.editor.on \"show\", ->\n      file.editor.show()\n      editor.editor.focus()\n  \n    editor.text.observe (value) ->\n      file.content(value)\n      \n      # Autorun\n      # actions.run()\n\nrepositoryLoaded(repository)\n\nissues.currentIssue.observe (issue) ->\n  # TODO: Formalize this later\n  return if issues.silent\n  \n  changeBranch = (branchName) ->\n    previousBranch = repository.branch()\n\n    confirmUnsaved()\n    .then ->\n      # Switch to branch for working on the issue\n      repository.switchToBranch(branchName)\n      .then ->\n        notices.push \"\\nLoading branch #{branchName}...\"\n        \n        Actions.load\n          repository: repository\n          filetree: filetree\n        .then ->\n          notices.push \"Loaded!\"\n    , ->\n      # TODO: Issue will appear as being selected even though we cancelled\n      # To correctly handle this we may need to really beef up our observables.\n      # One possibility is to extend observables to full fledged deferreds\n      # which can be rejected by listeners added to the chain.\n      \n      repository.branch(previousBranch)\n\n      errors [\"Error switching to #{branchName}, still on #{previousBranch}\"]\n\n  if issue\n    notify issue.fullDescription()\n    \n    changeBranch issue.branchName()\n  else    \n    notify \"Default branch selected\"\n    \n    changeBranch repository.defaultBranch()\n\n$root\n  .append(HAMLjr.templates.main(\n    filetree: filetree\n    actions: actions\n    notices: notices\n    errors: errors\n    issues: issues\n  ))\n\nGistquire.api \"rate_limit\", \n  complete: (request, status) ->\n    $root.append HAMLjr.templates.github_status\n      request: request\n\nwindow.onbeforeunload = ->\n  if filetree.hasUnsavedChanges()\n    \"You have some unsaved changes, if you leave now you will lose your work.\"\n","type":"blob"},"main.haml":{"path":"main.haml","mode":"100644","content":".main\n  = HAMLjr.templates.actions actions: @actions, issues: @issues\n  = HAMLjr.templates.filetree @filetree\n  = HAMLjr.templates.errors this\n","type":"blob"},"pixie.json":{"path":"pixie.json","mode":"100644","content":"{\n  \"width\": 960,\n  \"height\": 800,\n  \"remoteDependencies\": [\n    \"//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\",\n    \"//code.jquery.com/jquery-1.10.1.min.js\",\n    \"//d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\",\n    \"//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.1/underscore-min.js\",\n    \"http://strd6.github.io/tempest/javascripts/envweb.js\",\n    \"http://strd6.github.io/sandbox/master.js\"\n  ]\n}\n","type":"blob"},"repository.coffee":{"path":"repository.coffee","mode":"100644","content":"@Repository = (I={}) ->\n  Object.defaults I,\n    branch: \"master\"\n    defaultBranch: \"master\"\n\n  self = Model(I).observeAll()\n  \n  # The currently active branch in the working copy\n  self.attrObservable \"branch\"\n  \n  # TODO: Extract all of these methods to an API generator\n  requestOptions = (type, data) ->\n    type: type\n    data: JSON.stringify(data)\n\n  api = (path, options) ->\n    if path.match /^http/\n      url = path\n    else\n      url = \"#{self.url()}/#{path}\"\n          \n    Gistquire.api url, options\n\n  get = (path, data) ->\n    api path, data: data\n\n  put = (path, data) ->\n    api(path, requestOptions(\"PUT\", data))\n    \n  post = (path, data) ->\n    api(path, requestOptions(\"POST\", data))\n    \n  patch = (path, data) ->\n    api path, requestOptions(\"PATCH\", data)\n\n  self.extend\n    pullRequests: ->\n      get \"pulls\"\n\n    createPullRequest: ({title}) ->\n      head = title.dasherize()\n\n      self.switchToBranch(head)\n      .then(self.commitEmpty)\n      .then ->\n        post \"pulls\",\n          base: I.defaultBranch\n          head: head\n          title: title\n\n    initPagesBranch: ->\n      branch = \"gh-pages\"\n    \n      # Post an empty tree to use for the base commit\n      # TODO: Learn how to post an empty tree\n      post \"git/trees\",\n        tree: [{\n          mode: \"1006444\"\n          path: \"tempest.txt\"\n          content: \"created by strd6.github.io/editor\"\n        }]\n      .then (data) ->\n        # Create the base commit for the branch\n        post \"git/commits\",\n          message: \"Initial gh-pages commit\"\n          tree: data.sha\n      .then (data) ->\n        # Create the branch based on the base commit\n        post \"git/refs\",\n          ref: \"refs/heads/#{branch}\"\n          sha: data.sha\n      \n    writeFile: (params) ->\n      {branch, path, content, message} = params\n\n      get \"contents/#{path}\",\n        ref: branch\n      .then (data) ->\n        # The file existed, so we update it using the existing sha\n        put \"contents/#{path}\",\n          content: content\n          sha: data.sha\n          message: message\n          branch: branch\n      , (request) ->\n        # If we fail because the gh-pages branch doesn't exist try creating it and retrying\n        if request.responseJSON?.message is \"No commit found for the ref gh-pages\"\n          self.initPagesBranch().then ->\n            # Trying again after creating the gh-pages branch\n            self.writeFile(params)\n        # The file didn't exist so we create a new one\n        else if request.status is 404\n          put \"contents/#{path}\",\n            content: content\n            message: message\n            branch: branch\n        else\n          Deferred().reject(arguments...)\n\n    latestTree: (branch=self.defaultBranch()) ->\n      get(\"git/refs/heads/#{branch}\")\n      .then (data) ->\n        get data.object.url\n      .then (data) ->\n        get \"#{data.tree.url}?recursive=1\"\n      .then (data) ->\n        files = data.tree.select (file) ->\n          file.type is \"blob\"\n  \n        # Gather the data for each file\n        $.when.apply(null, files.map (datum) ->\n          get(datum.url)\n          .then (data) ->\n            Object.extend(datum, data)\n        )\n      .then (results...) -> \n        results\n\n    commitTree: ({message, tree}) ->\n      branch = self.branch()\n      message ?= \"Updated in browser at strd6.github.io/editor\"\n      \n      unless tree\n        throw Error(\"Must pass in a tree\")\n        \n      # TODO: Is there a cleaner way to pass this through promises?\n      latestCommitSha = null\n\n      get(\"git/refs/heads/#{branch}\")\n      .then (data) ->\n        latestCommitSha = data.object.sha\n        \n        post \"git/trees\",\n          tree: tree\n      .then (data) ->\n        # Create another commit\n        post \"git/commits\",\n          parents: [latestCommitSha]\n          message: message\n          tree: data.sha\n      .then (data) ->\n        # Update the branch head\n        patch \"git/refs/heads/#{branch}\",\n          sha: data.sha\n    \n    # TODO: this is currently a hack because we can't create a pull request\n    # if there are no different commits\n    commitEmpty: ->\n      branch = self.branch()\n      latestCommit = null\n      \n      get(\"git/refs/heads/#{branch}\")\n      .then (data) ->\n        get data.object.url\n      .then (data) ->\n        # Create another commit\n        post \"git/commits\",\n          parents: [data.sha]\n          message: \"This commit intentionally left blank\"\n          tree: data.tree.sha\n      .then (data) ->\n        # Update the branch head\n        patch \"git/refs/heads/#{branch}\",\n          sha: data.sha\n\n    switchToBranch: (branch) ->\n      ref = \"refs/heads/#{branch}\"\n      \n      setBranch = (data) ->\n        self.branch(branch)\n        \n        return data\n\n      get(\"git/#{ref}\")\n      .then setBranch # Success\n      , (request) -> # Failure\n        branchNotFound = (request.status is 404)\n\n        if branchNotFound\n          # Create branch if it doesn't exist\n          # Use our current branch as a base\n          get(\"git/refs/heads/#{self.branch()}\")\n          .then (data) ->\n            post \"git/refs\",\n              ref: ref\n              sha: data.object.sha\n          .then(setBranch)\n        else\n          Deferred().reject(arguments...)\n\n    mergeInto: (branch=self.defaultBranch()) ->\n      # TODO: Use default branch rather than master\n      post \"merges\",\n        base: branch\n        head: self.branch()\n        \n    pullFromBranch: (branch=self.defaultBranch()) ->\n      post \"merges\",\n        base: self.branch()\n        head: branch\n\n    publish: ({html, script}) ->\n      branch = self.branch()\n      message = \"Built #{branch} in browser in strd6.github.io/tempest\"\n\n      if branch is \"master\"\n        path = \"index.html\"\n      else\n        path = \"#{branch}.html\"\n\n      # Assuming git repo with gh-pages branch\n      publishBranch = \"gh-pages\"\n\n      # create <branch>.html\n      promise = self.writeFile\n        path: path\n        content: Base64.encode(html)\n        branch: publishBranch\n        message: message\n\n      # Create <branch>.js\n      if script\n        promise.then self.writeFile\n          path: \"#{branch}.js\"\n          content: Base64.encode(script)\n          branch: publishBranch\n          message: message\n      else\n        promise\n\n  return self\n","type":"blob"},"style.styl":{"path":"style.styl","mode":"100644","content":"html, body\n  margin: 0\n  height: 100%\n\n.main\n  position: relative\n  padding-top: 40px\n  padding-left: 200px\n  padding-bottom: 100px\n  box-sizing: border-box\n  height: 100%\n\n.editor-wrap\n  background-color: white\n  width: 100%\n  height: 100%\n  position: relative\n\n  & > div\n    position: absolute\n    top: 0\n    left: 0\n    right: 0\n    bottom: 0\n\n.filetree\n  margin: 0\n  padding: 0\n  width: 200px\n  position: absolute\n  left: 0\n  top: 40px\n  z-index: 2\n\n  li\n    list-style-type: none\n    padding-left: 1em\n    position: relative\n\n    .delete\n      display: none\n      position: absolute\n      right: 0\n\n    &:hover\n      background-color: lightyellow\n\n      .delete\n        display: inline-block\n\n.actions\n  position: absolute\n  top: 0\n  left: 200px\n\n.console-wrap\n  box-sizing: border-box\n  position: absolute\n  bottom: 0\n  left: 0\n  right: 0\n  padding-left: 200px\n  height: 100px\n  width: 100%\n  margin: 0\n  \n  .errors\n    box-sizing: border-box\n    border-top: 1px solid black\n    color: red\n\n.status\n  top: 0\n  right: 0\n  position: absolute\n","type":"blob"},"text_editor.coffee":{"path":"text_editor.coffee","mode":"100644","content":"@TextEditor = (I) ->\n  Object.reverseMerge I,\n    mode: \"coffee\"\n    text: \"\"\n\n  self = Model(I)\n\n  # We can't use ace on a div not in the DOM :(\n  el = I.el\n  # We can't serialize DOM elements\n  delete I.el\n\n  editor = ace.edit(el)\n  editor.setFontSize(\"16px\")\n  editor.setTheme(\"ace/theme/chrome\")\n  editor.getSession().setUseWorker(false)\n  editor.getSession().setMode(\"ace/mode/#{I.mode}\")\n  editor.getSession().setUseSoftTabs(true)\n  editor.getSession().setTabSize(2)\n\n  reset = (content=\"\") ->\n    editor.setValue(content)\n    editor.moveCursorTo(0, 0)\n    editor.session.selection.clearSelection()\n\n  reset(I.text)\n\n  self.attrObservable \"text\"\n\n  updating = false\n  editor.getSession().on 'change', ->\n    updating = true\n    self.text(editor.getValue())\n    updating = false\n\n  self.text.observe (newValue) ->\n    unless updating\n      reset(newValue)\n\n  self.extend\n    el: el\n    editor: editor\n    reset: reset\n\n  return self\n","type":"blob"},"pixie.cson":{"path":"pixie.cson","mode":"100644","content":"width: 960\nheight: 800\nremoteDependencies: [\n  \"//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\"\n  \"//code.jquery.com/jquery-1.10.1.min.js\"\n  \"//d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\"\n  \"//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.1/underscore-min.js\"\n  \"http://strd6.github.io/tempest/javascripts/envweb.js\"\n  \"http://strd6.github.io/sandbox/master.js\"\n]\n","type":"blob"}},"distribution":{"build.js":{"path":"build.js","content":"(function() {\n  var commit, publish;\n\n  publish = function(_arg) {\n    var builder, fileData, repository;\n    builder = _arg.builder, fileData = _arg.fileData, repository = _arg.repository;\n    return builder.build(fileData).then(function(build) {\n      var branch;\n      branch = repository.branch();\n      return repository.publish(builder.standAlone(build, branch));\n    });\n  };\n\n  commit = function(_arg) {\n    var fileData, message, repository;\n    fileData = _arg.fileData, repository = _arg.repository, message = _arg.message;\n    return repository.commitTree({\n      tree: fileData,\n      message: message\n    });\n  };\n\n  this.Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    },\n    run: function(_arg) {\n      var builder, filetree;\n      builder = _arg.builder, filetree = _arg.filetree;\n      return builder.build(filetree.data()).then(function(build) {\n        var config, html, sandbox, _base;\n        config = Builder.readConfig(build);\n        html = builder.standAlone(build).html;\n        sandbox = Sandbox({\n          width: config.width,\n          height: config.height\n        });\n        sandbox.document.open();\n        sandbox.document.write(html);\n        sandbox.document.close();\n        return typeof (_base = builder.I).notices === \"function\" ? _base.notices([\"Running!\"]) : void 0;\n      });\n    },\n    load: function(_arg) {\n      var filetree, processDirectory, repository;\n      filetree = _arg.filetree, repository = _arg.repository;\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      return repository.latestTree().then(function(results) {\n        var files;\n        files = processDirectory(results);\n        return filetree.load(files);\n      });\n    }\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"actions\"] = function(data) {\n    return (function() {\n      var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"actions\");\n      actions = this.actions;\n      Object.keys(actions).each(function(name) {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, name.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return actions[name]();\n        });\n        return __pop();\n      });\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.issue_selector(this.issues));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var arrayToHash, compileFile, compileStyl, compileTemplate, documentFile, readConfig, stripMarkdown;\n\n  arrayToHash = function(array) {\n    return array.eachWithObject({}, function(file, hash) {\n      return hash[file.path] = file;\n    });\n  };\n\n  stripMarkdown = function(content) {\n    return content.split(\"\\n\").map(function(line) {\n      var match;\n      if (match = /^([ ]{4}|\\t)/.exec(line)) {\n        return line.slice(match[0].length);\n      } else {\n        return \"\";\n      }\n    }).join(\"\\n\");\n  };\n\n  compileTemplate = function(source, name) {\n    var ast;\n    if (name == null) {\n      name = \"test\";\n    }\n    ast = HAMLjr.parser.parse(source);\n    return HAMLjr.compile(ast, {\n      name: name,\n      compiler: CoffeeScript\n    });\n  };\n\n  compileStyl = function(source) {\n    return styl(source, {\n      whitespace: true\n    }).toString();\n  };\n\n  compileFile = function(_arg) {\n    var content, extension, name, path, result, _ref;\n    path = _arg.path, content = _arg.content;\n    _ref = [path.withoutExtension(), path.extension()], name = _ref[0], extension = _ref[1];\n    result = (function() {\n      switch (extension) {\n        case \"js\":\n          return {\n            code: content\n          };\n        case \"coffee\":\n          return {\n            code: CoffeeScript.compile(content)\n          };\n        case \"haml\":\n          return {\n            code: compileTemplate(content, name)\n          };\n        case \"styl\":\n          return {\n            style: compileStyl(content)\n          };\n        case \"md\":\n          return compileFile({\n            path: name,\n            content: stripMarkdown(content)\n          });\n        default:\n          return {};\n      }\n    })();\n    Object.defaults(result, {\n      name: name,\n      extension: extension\n    });\n    return Object.extend(result, {\n      path: path\n    });\n  };\n\n  documentFile = function(content, path) {\n    if (path.extension() === \"md\") {\n      return marked(content);\n    } else {\n      return \"\";\n    }\n  };\n\n  this.Builder = function(I) {\n    var build, postProcessors;\n    if (I == null) {\n      I = {};\n    }\n    compileTemplate = function(source, name) {\n      var ast;\n      if (name == null) {\n        name = \"test\";\n      }\n      ast = HAMLjr.parser.parse(source);\n      return HAMLjr.compile(ast, {\n        name: name,\n        compiler: CoffeeScript\n      });\n    };\n    build = function(fileData) {\n      var data, errors, results, _ref;\n      results = fileData.map(function(_arg) {\n        var content, location, message, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          return compileFile({\n            path: path,\n            content: content\n          });\n        } catch (_error) {\n          location = _error.location, message = _error.message;\n          if (location != null) {\n            message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n          }\n          return {\n            error: \"\" + path + \" - \" + message\n          };\n        }\n      });\n      _ref = results.partition(function(result) {\n        return result.error;\n      }), errors = _ref[0], data = _ref[1];\n      if (errors.length) {\n        return Deferred().reject(errors.map(function(e) {\n          return e.error;\n        }));\n      } else {\n        return Deferred().resolve(data);\n      }\n    };\n    postProcessors = [];\n    return {\n      I: I,\n      addPostProcessor: function(fn) {\n        return postProcessors.push(fn);\n      },\n      buildDocs: function(fileData) {\n        return fileData.map(function(_arg) {\n          var content, location, message, path;\n          path = _arg.path, content = _arg.content;\n          try {\n            return {\n              path: path,\n              documentation: documentFile(content, path)\n            };\n          } catch (_error) {\n            location = _error.location, message = _error.message;\n            if (location != null) {\n              message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n            }\n            return {\n              error: \"\" + path + \" - \" + message\n            };\n          }\n        });\n      },\n      build: function(fileData) {\n        I.notices.push(\"Building...\");\n        return build(fileData).then(function(items) {\n          var dist, distCode, distStyle, results;\n          results = {\n            code: [],\n            style: [],\n            main: []\n          };\n          items.eachWithObject(results, function(item, hash) {\n            var code, style;\n            if (code = item.code) {\n              if (item.name === \"main\" && (item.extension === \"js\" || item.extension === \"coffee\")) {\n                return hash.main.push(code);\n              } else {\n                return hash.code.push(code);\n              }\n            } else if (style = item.style) {\n              return hash.style.push(style);\n            } else {\n\n            }\n          });\n          distCode = results.code.concat(results.main).join(';').trim();\n          distStyle = results.style.join('').trim();\n          dist = [];\n          if (!distCode.blank()) {\n            dist.push({\n              path: \"build.js\",\n              content: distCode,\n              type: \"blob\"\n            });\n          }\n          if (!distStyle.blank()) {\n            dist.push({\n              path: \"style.css\",\n              content: distStyle,\n              type: \"blob\"\n            });\n          }\n          return Deferred().resolve(postProcessors.pipeline({\n            source: arrayToHash(fileData),\n            distribution: arrayToHash(dist)\n          }));\n        });\n      },\n      program: function(build) {\n        var distribution, entryPoint, program;\n        distribution = build.distribution;\n        entryPoint = \"build.js\";\n        program = distribution[entryPoint].content;\n        return \"Function(\\\"ENV\\\", \" + (JSON.stringify(program)) + \")(\" + (JSON.stringify(build)) + \");\";\n      },\n      standAlone: function(build, ref) {\n        var content, dependencyScripts, distribution, makeScript, program, remoteDependencies, scriptTag, source;\n        source = build.source, distribution = build.distribution;\n        makeScript = function(attrs) {\n          return $(\"<script>\", attrs).prop('outerHTML');\n        };\n        content = [];\n        content.push(\"<!doctype html>\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        remoteDependencies = readConfig(build).remoteDependencies;\n        dependencyScripts = remoteDependencies ? remoteDependencies.map(function(src) {\n          return makeScript({\n            \"class\": \"env\",\n            src: src\n          });\n        }) : $('script.env').map(function() {\n          return this.outerHTML;\n        }).get();\n        content = content.concat(dependencyScripts);\n        program = this.program(build);\n        scriptTag = ref ? makeScript({\n          src: \"\" + ref + \".js\"\n        }) : \"<script>\\n\" + program + \"\\n<\\/script>\";\n        content.push(\"</head>\\n<body>\\n\" + scriptTag + \"\\n</body>\\n</html>\");\n        return {\n          html: content.join(\"\\n\"),\n          script: program\n        };\n      }\n    };\n  };\n\n  readConfig = function(build) {\n    var configData, _ref, _ref1;\n    if (configData = (_ref = build.source[\"pixie.cson\"]) != null ? _ref.content : void 0) {\n      return CSON.parse(configData);\n    } else if (configData = (_ref1 = build.source[\"pixie.json\"]) != null ? _ref1.content : void 0) {\n      return JSON.parse(configData);\n    } else {\n      return {};\n    }\n  };\n\n  Builder.readConfig = readConfig;\n\n}).call(this);\n;(function() {\n  var withDeferrence;\n\n  this.Deferred = $.Deferred;\n\n  withDeferrence = function(fn) {\n    var deferred, e;\n    deferred = Deferred();\n    try {\n      fn.defer(deferred);\n    } catch (_error) {\n      e = _error;\n      deferred.reject(e);\n    }\n    return deferred.promise();\n  };\n\n  Deferred.Confirm = function(message) {\n    return withDeferrence(function(deferred) {\n      if (window.confirm(message)) {\n        return deferred.resolve();\n      } else {\n        return deferred.reject();\n      }\n    });\n  };\n\n  Deferred.ConfirmIf = function(flag, message) {\n    if (flag) {\n      return Deferred.Confirm(message);\n    } else {\n      return withDeferrence(function(deferred) {\n        return deferred.resolve();\n      });\n    }\n  };\n\n  Deferred.ExecuteIf = function(flag, callback) {\n    return withDeferrence(function(deferred) {\n      if (flag) {\n        return callback().then(deferred.resolve);\n      } else {\n        return deferred.resolve();\n      }\n    });\n  };\n\n}).call(this);\n;(function() {\n  String.prototype.dasherize = function() {\n    return this.trim().replace(/\\s+/g, \"-\").toLowerCase();\n  };\n\n  this.Base64 = {\n    encode: function(s) {\n      return btoa(unescape(encodeURIComponent(s)));\n    },\n    decode: function(s) {\n      return decodeURIComponent(escape(atob(s.replace(/\\s/g, ''))));\n    }\n  };\n\n  this.CSON = {\n    parse: function(source) {\n      return Function(\"return \" + (CoffeeScript.compile(source, {\n        bare: true\n      })))();\n    },\n    stringify: function(object) {\n      var representation;\n      representation = JSON.parse(JSON.stringify(obj));\n      return Object.keys(representation).map(function(key) {\n        var value;\n        value = representation[key];\n        return \"\" + key + \": \" + (JSON.stringify(value));\n      }).join(\"\\n\");\n    }\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"editor\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"editor\");\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"errors\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"console-wrap\");\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"errors\");\n      __each(this.errors, function(error) {\n        __element = document.createTextNode('');\n        __text(__element, error);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"pre\");\n      __push(__element);\n      __attribute(__element, \"class\", \"notices\");\n      __each(this.notices, function(notice) {\n        __element = document.createTextNode('');\n        __text(__element, notice);\n        __push(__element);\n        return __pop();\n      });\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          case \"md\":\n            return \"markdown\";\n          case \"\":\n            return \"text\";\n          default:\n            return extension;\n        }\n      },\n      modified: Observable(false),\n      displayName: Observable(self.path())\n    });\n    self.content.observe(function() {\n      return self.modified(true);\n    });\n    self.modified.observe(function(modified) {\n      if (modified) {\n        return self.displayName(\"*\" + (self.path()));\n      } else {\n        return self.displayName(self.path());\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  this.Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        if (Array.isArray(fileData)) {\n          files = fileData.sort(function(a, b) {\n            if (a.path < b.path) {\n              return -1;\n            } else if (b.path < a.path) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).map(File);\n        } else {\n          files = Object.keys(fileData).sort().map(function(name) {\n            return File(fileData[name]);\n          });\n        }\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.filename(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      },\n      hasUnsavedChanges: function() {\n        return self.files().select(function(file) {\n          return file.modified();\n        }).length;\n      },\n      markSaved: function() {\n        return self.files().each(function(file) {\n          return file.modified(false);\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"filetree\"] = function(data) {\n    return (function() {\n      var files, selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"filetree\");\n      selectedFile = this.selectedFile;\n      files = this.files;\n      __each(files, function(file) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, file.displayName);\n        __push(__element);\n        __pop();\n        __on(\"click\", function(e) {\n          if ($(e.target).is('li')) {\n            return selectedFile(file);\n          }\n        });\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"delete\");\n        __on(\"click\", function() {\n          if (confirm(\"Delete \" + (file.path()) + \"?\")) {\n            return files.remove(file);\n          }\n        });\n        __element = document.createTextNode('');\n        __text(__element, \"X\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"gist_list\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"gists\");\n      __each(this.gists, function(gist) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, gist.id);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return alert(gist.id);\n        });\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    }\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"github_status\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"status\");\n      if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n        __element = document.createTextNode('');\n        __text(__element, \"Authenticated Scopes:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n        __push(__element);\n        __pop();\n        __element = document.createElement(\"br\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \"Rate Limit Remaining:\\n\");\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n        __push(__element);\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, \" / 5000\");\n        __push(__element);\n        __pop();\n      } else {\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Auth\\n\");\n        __push(__element);\n        __pop();\n        __on(\"click\", Gistquire.auth);\n        __pop();\n      }\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.Issue = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    self = Model(I);\n    self.extend({\n      optionText: function() {\n        return \"\" + I.title;\n      },\n      fullDescription: function() {\n        return \"\" + (self.optionText()) + \"\\n\" + I.html_url + \"\\n\" + I.body;\n      },\n      branchName: function() {\n        var _ref;\n        return ((_ref = I.head) != null ? _ref.ref : void 0) || (\"issue-\" + I.number);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"issue_selector\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"select\");\n      __push(__element);\n      __on(\"change\", this.currentIssue);\n      __element = document.createElement(\"option\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"- Default Branch -\");\n      __push(__element);\n      __pop();\n      __pop();\n      __each(this.issues, function() {\n        __element = document.createElement(\"option\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, this.optionText());\n        __push(__element);\n        __pop();\n        return __pop();\n      });\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  this.Issues = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      issues: []\n    });\n    self = Model(I);\n    self.attrModels(\"issues\");\n    self.attrObservable(\"currentIssue\");\n    self.extend({\n      reset: function(issueData) {\n        self.currentIssue(void 0);\n        return self.issues(issueData.map(Issue));\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"main\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"main\");\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.actions({\n        actions: this.actions,\n        issues: this.issues\n      }));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.filetree(this.filetree));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, HAMLjr.templates.errors(this));\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n;(function() {\n  var __slice = [].slice;\n\n  this.Repository = function(I) {\n    var api, get, patch, post, put, requestOptions, self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      branch: \"master\",\n      defaultBranch: \"master\"\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"branch\");\n    requestOptions = function(type, data) {\n      return {\n        type: type,\n        data: JSON.stringify(data)\n      };\n    };\n    api = function(path, options) {\n      var url;\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"\" + (self.url()) + \"/\" + path;\n      }\n      return Gistquire.api(url, options);\n    };\n    get = function(path, data) {\n      return api(path, {\n        data: data\n      });\n    };\n    put = function(path, data) {\n      return api(path, requestOptions(\"PUT\", data));\n    };\n    post = function(path, data) {\n      return api(path, requestOptions(\"POST\", data));\n    };\n    patch = function(path, data) {\n      return api(path, requestOptions(\"PATCH\", data));\n    };\n    self.extend({\n      pullRequests: function() {\n        return get(\"pulls\");\n      },\n      createPullRequest: function(_arg) {\n        var head, title;\n        title = _arg.title;\n        head = title.dasherize();\n        return self.switchToBranch(head).then(self.commitEmpty).then(function() {\n          return post(\"pulls\", {\n            base: I.defaultBranch,\n            head: head,\n            title: title\n          });\n        });\n      },\n      initPagesBranch: function() {\n        var branch;\n        branch = \"gh-pages\";\n        return post(\"git/trees\", {\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/editor\"\n            }\n          ]\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            message: \"Initial gh-pages commit\",\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return post(\"git/refs\", {\n            ref: \"refs/heads/\" + branch,\n            sha: data.sha\n          });\n        });\n      },\n      writeFile: function(params) {\n        var branch, content, message, path;\n        branch = params.branch, path = params.path, content = params.content, message = params.message;\n        return get(\"contents/\" + path, {\n          ref: branch\n        }).then(function(data) {\n          return put(\"contents/\" + path, {\n            content: content,\n            sha: data.sha,\n            message: message,\n            branch: branch\n          });\n        }, function(request) {\n          var _ref, _ref1;\n          if (((_ref = request.responseJSON) != null ? _ref.message : void 0) === \"No commit found for the ref gh-pages\") {\n            return self.initPagesBranch().then(function() {\n              return self.writeFile(params);\n            });\n          } else if (request.status === 404) {\n            return put(\"contents/\" + path, {\n              content: content,\n              message: message,\n              branch: branch\n            });\n          } else {\n            return (_ref1 = Deferred()).reject.apply(_ref1, arguments);\n          }\n        });\n      },\n      latestTree: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return get(\"\" + data.tree.url + \"?recursive=1\");\n        }).then(function(data) {\n          var files;\n          files = data.tree.select(function(file) {\n            return file.type === \"blob\";\n          });\n          return $.when.apply(null, files.map(function(datum) {\n            return get(datum.url).then(function(data) {\n              return Object.extend(datum, data);\n            });\n          }));\n        }).then(function() {\n          var results;\n          results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return results;\n        });\n      },\n      commitTree: function(_arg) {\n        var branch, latestCommitSha, message, tree;\n        message = _arg.message, tree = _arg.tree;\n        branch = self.branch();\n        if (message == null) {\n          message = \"Updated in browser at strd6.github.io/editor\";\n        }\n        if (!tree) {\n          throw Error(\"Must pass in a tree\");\n        }\n        latestCommitSha = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          latestCommitSha = data.object.sha;\n          return post(\"git/trees\", {\n            tree: tree\n          });\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [latestCommitSha],\n            message: message,\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      commitEmpty: function() {\n        var branch, latestCommit;\n        branch = self.branch();\n        latestCommit = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [data.sha],\n            message: \"This commit intentionally left blank\",\n            tree: data.tree.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      switchToBranch: function(branch) {\n        var ref, setBranch;\n        ref = \"refs/heads/\" + branch;\n        setBranch = function(data) {\n          self.branch(branch);\n          return data;\n        };\n        return get(\"git/\" + ref).then(setBranch, function(request) {\n          var branchNotFound, _ref;\n          branchNotFound = request.status === 404;\n          if (branchNotFound) {\n            return get(\"git/refs/heads/\" + (self.branch())).then(function(data) {\n              return post(\"git/refs\", {\n                ref: ref,\n                sha: data.object.sha\n              });\n            }).then(setBranch);\n          } else {\n            return (_ref = Deferred()).reject.apply(_ref, arguments);\n          }\n        });\n      },\n      mergeInto: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: branch,\n          head: self.branch()\n        });\n      },\n      pullFromBranch: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: self.branch(),\n          head: branch\n        });\n      },\n      publish: function(_arg) {\n        var branch, html, message, path, promise, publishBranch, script;\n        html = _arg.html, script = _arg.script;\n        branch = self.branch();\n        message = \"Built \" + branch + \" in browser in strd6.github.io/tempest\";\n        if (branch === \"master\") {\n          path = \"index.html\";\n        } else {\n          path = \"\" + branch + \".html\";\n        }\n        publishBranch = \"gh-pages\";\n        promise = self.writeFile({\n          path: path,\n          content: Base64.encode(html),\n          branch: publishBranch,\n          message: message\n        });\n        if (script) {\n          return promise.then(self.writeFile({\n            path: \"\" + branch + \".js\",\n            content: Base64.encode(script),\n            branch: publishBranch,\n            message: message\n          }));\n        } else {\n          return promise;\n        }\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  this.TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n}).call(this);\n;(function() {\n  var $root, actions, branch, builder, classicError, confirmUnsaved, currentNode, distribution, errors, files, filetree, fullName, issues, notices, notify, owner, repo, repository, repositoryLoaded, styleContent, _ref, _ref1;\n\n  files = ENV.source, distribution = ENV.distribution;\n\n  window.ENV = ENV;\n\n  classicError = function(request) {\n    var message;\n    notices([]);\n    if (request.responseJSON) {\n      message = JSON.stringify(request.responseJSON, null, 2);\n    } else {\n      message = \"Error\";\n    }\n    return errors([message]);\n  };\n\n  notify = function(message) {\n    notices([message]);\n    return errors([]);\n  };\n\n  currentNode = function() {\n    var target;\n    target = document.documentElement;\n    while (target.childNodes.length && target.lastChild.nodeType === 1) {\n      target = target.lastChild;\n    }\n    return target.parentNode;\n  };\n\n  $root = $(currentNode());\n\n  if (styleContent = (_ref = distribution[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  Gistquire.onload();\n\n  _ref1 = ENV.repository, owner = _ref1.owner, repo = _ref1.repo, branch = _ref1.branch, fullName = _ref1.full_name;\n\n  fullName || (fullName = \"\" + owner + \"/\" + repo);\n\n  repository = Repository({\n    url: \"repos/\" + fullName\n  });\n\n  errors = Observable([]);\n\n  notices = Observable([\"Loaded!\"]);\n\n  builder = Builder({\n    errors: errors,\n    notices: notices\n  });\n\n  repositoryLoaded = function(repository) {\n    issues.repository = repository;\n    repository.pullRequests().then(issues.reset);\n    return notices([\"Finished loading!\"]);\n  };\n\n  confirmUnsaved = function() {\n    return Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\");\n  };\n\n  issues = Issues();\n\n  builder.addPostProcessor(function(data) {\n    data.repository = {\n      full_name: fullName,\n      branch: branch\n    };\n    return data;\n  });\n\n  builder.addPostProcessor(function(data) {\n    data.progenitor = {\n      url: \"http://strd6.github.io/editor/\"\n    };\n    return data;\n  });\n\n  actions = {\n    save: function() {\n      notices([\"Saving...\"]);\n      return Actions.save({\n        repository: repository,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        filetree.markSaved();\n        return notices([\"Saved and published!\"]);\n      });\n    },\n    run: function() {\n      return Actions.run({\n        builder: builder,\n        filetree: filetree\n      }).fail(errors);\n    },\n    new_file: function() {\n      var name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        return filetree.files.push(File({\n          filename: name,\n          content: \"\"\n        }));\n      }\n    },\n    load_repo: function(skipPrompt) {\n      return confirmUnsaved().then(function() {\n        if (!skipPrompt) {\n          fullName = prompt(\"Github repo\", fullName);\n        }\n        if (fullName) {\n          repository = Repository({\n            url: \"repos/\" + fullName\n          });\n        } else {\n          errors([\"No repo given\"]);\n          return;\n        }\n        notices([\"Loading repo...\"]);\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return repositoryLoaded(repository);\n        }).fail(function() {\n          return errors([\"Error loading \" + (repository.url())]);\n        });\n      });\n    },\n    new_feature: function() {\n      var title;\n      if (title = prompt(\"Description\")) {\n        notices([\"Creating feature branch...\"]);\n        return repository.createPullRequest({\n          title: title\n        }).then(function(data) {\n          var issue;\n          issue = Issue(data);\n          issues.issues.push(issue);\n          issues.silent = true;\n          issues.currentIssue(issue);\n          issues.silent = false;\n          return notices.push(\"Created!\");\n        }, classicError);\n      }\n    },\n    pull_master: function() {\n      return confirmUnsaved().then(function() {\n        notify(\"Merging in default branch...\");\n        return repository.pullFromBranch();\n      }, classicError).then(function() {\n        var branchName;\n        notices.push(\"Merged!\");\n        branchName = repository.branch();\n        notices.push(\"\\nReloading branch \" + branchName + \"...\");\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return notices.push(\"Loaded!\");\n        });\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.templates.editor());\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        return file.content(value);\n      });\n    }\n  });\n\n  repositoryLoaded(repository);\n\n  issues.currentIssue.observe(function(issue) {\n    var changeBranch;\n    if (issues.silent) {\n      return;\n    }\n    changeBranch = function(branchName) {\n      var previousBranch;\n      previousBranch = repository.branch();\n      return confirmUnsaved().then(function() {\n        return repository.switchToBranch(branchName).then(function() {\n          notices.push(\"\\nLoading branch \" + branchName + \"...\");\n          return Actions.load({\n            repository: repository,\n            filetree: filetree\n          }).then(function() {\n            return notices.push(\"Loaded!\");\n          });\n        });\n      }, function() {\n        repository.branch(previousBranch);\n        return errors([\"Error switching to \" + branchName + \", still on \" + previousBranch]);\n      });\n    };\n    if (issue) {\n      notify(issue.fullDescription());\n      return changeBranch(issue.branchName());\n    } else {\n      notify(\"Default branch selected\");\n      return changeBranch(repository.defaultBranch());\n    }\n  });\n\n  $root.append(HAMLjr.templates.main({\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors,\n    issues: issues\n  }));\n\n  Gistquire.api(\"rate_limit\", {\n    complete: function(request, status) {\n      return $root.append(HAMLjr.templates.github_status({\n        request: request\n      }));\n    }\n  });\n\n  window.onbeforeunload = function() {\n    if (filetree.hasUnsavedChanges()) {\n      return \"You have some unsaved changes, if you leave now you will lose your work.\";\n    }\n  };\n\n}).call(this);","type":"blob"},"style.css":{"path":"style.css","content":"html,\nbody {\n  margin: 0;\n  height: 100%;\n}\n\n.main {\n  position: relative;\n  padding-top: 40px;\n  padding-left: 200px;\n  padding-bottom: 100px;\n  height: 100%;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.editor-wrap {\n  background-color: white;\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n.editor-wrap > div {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.filetree {\n  margin: 0;\n  padding: 0;\n  width: 200px;\n  position: absolute;\n  left: 0;\n  top: 40px;\n  z-index: 2;\n}\n\n.filetree li .delete {\n  display: none;\n  position: absolute;\n  right: 0;\n}\n\n.filetree li:hover .delete {\n  display: inline-block;\n}\n\n.filetree li:hover {\n  background-color: lightyellow;\n}\n\n.filetree li {\n  list-style-type: none;\n  padding-left: 1em;\n  position: relative;\n}\n\n.actions {\n  position: absolute;\n  top: 0;\n  left: 200px;\n}\n\n.console-wrap {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  padding-left: 200px;\n  height: 100px;\n  width: 100%;\n  margin: 0;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.console-wrap .errors {\n  border-top: 1px solid black;\n  color: red;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.status {\n  top: 0;\n  right: 0;\n  position: absolute;\n}","type":"blob"}},"repository":{"full_name":"STRd6/editor","branch":"master"},"progenitor":{"url":"http://strd6.github.io/editor/"}});