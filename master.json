{
  "source": {
    "TODO": {
      "path": "TODO",
      "mode": "100644",
      "content": "TODO\n----\nBundled Dependencies\n- Build bundled dependencies into published script\n- Dependency source should not be in revision control\n- requires and module.exports\n- inter-component and intra-component dependencies\n- One day we'll need to implement a bundleresque system, but not today\n\nLive Update Demo\n- Hot reload css\n- Display Demo Runtime Errors in console\n\nOpen published page in editor and run live demo with same state as when editor was opened\n- Pass git repo/branch metadata to published page for use in editor\n\nPersist state across demo reloads\n\nOrganize File tree by type\nFile icons\n\nDisplay Diffs\n\nFirst auth doesn't display in bar\n\nCache Git trees and files in some form of local storage\n\nSometimes editor appears blank when switching files\n\nEditor plugins\n- static analysis\n- find in files\n- source file hygiene\n",
      "type": "blob"
    },
    "main.coffee": {
      "path": "main.coffee",
      "mode": "100644",
      "content": "# Get stuff from our env\n{source:files, distribution} = ENV\n\n# For debugging\nwindow.ENV = ENV\n\nrequire(\"./source/duct_tape\")\nrequire(\"./source/deferred\")\n\n# Load and attach Templates\ntemplates = (HAMLjr.templates ||= {})\n[\n  \"actions\"\n  \"editor\"\n  \"filetree\"\n  \"github_status\"\n  \"notices\"\n  \"text_editor\"\n].each (name) ->\n  template = require(\"./templates/#{name}\")\n  # TODO Transitional type check\n  if typeof template is \"function\"\n    templates[name] = template\n\nActions = require(\"./source/actions\")\nBuilder = require(\"./source/builder\")\nRunner = require(\"./source/runner\")\nRuntime = require(\"./source/runtime\")\nGistquire = require(\"./source/gistquire\")\nRepository = require(\"./source/repository\")\nFiletree = require(\"./source/filetree\")\nFile = require(\"./source/file\")\nTextEditor = require(\"./source/text_editor\")\n\n# TODO: Move notifications stuff into its own class\nclassicError = (request, error, message) ->\n  debugger\n  notices []\n  \n  if request.responseJSON\n    message = JSON.stringify(request.responseJSON, null, 2)\n  else\n    message ?= request\n\n  errors [message]\n\nnotify = (message) ->\n  notices [message]\n  errors []\n\n# The root is the node that contains the script file.\nruntime = Runtime(ENV)\nrootNode = runtime.boot()\n\ntry\n  runtime.applyStyleSheet(rootNode, '/style')\n\n$root = $(rootNode)\n\n# Init Github access token stuff\nGistquire.onload()\n  \n# Real branch and repo info, from ENV\n{owner, repo, branch, full_name:fullName} = ENV.repository\n\nfullName ||= \"#{owner}/#{repo}\"\n\nrepository = Repository\n  url: \"repos/#{fullName}\"\n  branch: branch\n\nerrors = Observable([])\nnotices = Observable([])\n\nbuilder = Builder()\n\nrepositoryLoaded = (repository) ->\n  issues.repository = repository\n  repository.pullRequests().then issues.reset\n  \n  notify \"Finished loading!\"\n  \nconfirmUnsaved = ->\n  Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\")\n\n{models:{Issue, Issues}, templates:{issues:issuesTemplate}} = require(\"issues\")\ntemplates[\"issues\"] = issuesTemplate\nissues = Issues()\n\n# Repo metadata for env\nbuilder.addPostProcessor (data) ->\n  # TODO: Track commit SHA as well\n  data.repository =\n    full_name: fullName\n    branch: repository.branch()\n\n  data\n\nbuilder.addPostProcessor (data) ->\n  # TODO: Think about a robust way to get 'self' and set it as progenitor data\n  data.progenitor =\n    url: \"http://strd6.github.io/editor/\"\n\n  data\n\nactions =\n  save: ->\n    notify \"Saving...\"\n\n    Actions.save\n      repository: repository\n      fileData: filetree.data()\n      builder: builder\n    .then ->\n      # TODO: This could get slightly out of sync if there were changes\n      # during the async call\n      # The correct solution will be to use git shas to determine changed status\n      # but that's a little heavy duty for right now.\n      filetree.markSaved()\n      notify \"Saved and published!\"\n    .fail (args...) ->\n      errors args\n\n  run: ->\n    Actions.run({builder, filetree})\n    .fail errors\n\n  test: ->\n    notify \"Running tests...\"\n\n    Actions.test({builder, filetree})\n    .fail errors\n\n  new_file: ->\n    if name = prompt(\"File Name\", \"newfile.coffee\")\n      file = File\n        filename: name\n        content: \"\"\n      filetree.files.push file\n      filetree.selectedFile file      \n\n  load_repo: (skipPrompt) ->\n    confirmUnsaved()\n    .then ->\n      fullName = prompt(\"Github repo\", fullName) unless skipPrompt\n\n      if fullName\n        repository = Repository\n          url: \"repos/#{fullName}\"\n      else\n        errors [\"No repo given\"]\n  \n        return\n  \n      notify \"Loading repo...\"\n  \n      Actions.load\n        repository: repository\n        filetree: filetree\n      .then ->\n        repositoryLoaded(repository)\n        \n        root = $root.children(\".main\")\n        root.find(\".editor-wrap\").remove()\n      .fail classicError\n\n  new_feature: ->\n    if title = prompt(\"Description\")\n      notify \"Creating feature branch...\"\n\n      repository.createPullRequest\n        title: title\n      .then (data) ->\n        issue = Issue(data)\n        issues.issues.push issue\n\n        # TODO: Standardize this like backbone or something\n        # or think about using deferreds in some crazy way\n        issues.silent = true\n        issues.currentIssue issue\n        issues.silent = false\n\n        notices.push \"Created!\"\n      , classicError\n      \n  pull_master: ->\n    confirmUnsaved()\n    .then( ->\n      notify \"Merging in default branch...\"\n      repository.pullFromBranch()\n    , classicError\n    ).then ->\n      notices.push \"Merged!\"\n      \n      branchName = repository.branch()\n      notices.push \"\\nReloading branch #{branchName}...\"\n        \n      Actions.load\n        repository: repository\n        filetree: filetree\n      .then ->\n        notices.push \"Loaded!\"\n      .fail ->\n        errors [\"Error loading #{repository.url()}\"]\n\nfiletree = Filetree()\nfiletree.load(files)\n\nfiletree.selectedFile.observe (file) ->\n  root = $root.children(\".main\")\n  root.find(\".editor-wrap\").hide()\n  \n  if file.editor\n    file.editor.trigger(\"show\")\n  else\n    root.append(HAMLjr.render \"text_editor\")\n    file.editor = root.find(\".editor-wrap\").last()\n    \n    editor = TextEditor\n      text: file.content()\n      el: file.editor.find('.editor').get(0)\n      mode: file.mode()\n\n    file.editor.on \"show\", ->\n      file.editor.show()\n      editor.editor.focus()\n  \n    editor.text.observe (value) ->\n      file.content(value)\n      \n      # TODO May want to move this into a collection listener for all files\n      # in the filetree\n      if file.path().match(/\\.styl$/)\n        hotReloadCSS(file)\n\nhotReloadCSS = ( (file) ->\n  css = styl(file.content(), whitespace: true).toString()\n\n  Runner.hotReloadCSS(css, file.path())\n).debounce(500)\n\nrepositoryLoaded(repository)\n\nissues?.currentIssue.observe (issue) ->\n  # TODO: Formalize this later\n  return if issues.silent\n  \n  changeBranch = (branchName) ->\n    previousBranch = repository.branch()\n\n    confirmUnsaved()\n    .then ->\n      # Switch to branch for working on the issue\n      repository.switchToBranch(branchName)\n      .then ->\n        notices.push \"\\nLoading branch #{branchName}...\"\n        \n        Actions.load\n          repository: repository\n          filetree: filetree\n        .then ->\n          notices.push \"Loaded!\"\n    , ->\n      # TODO: Issue will appear as being selected even though we cancelled\n      # To correctly handle this we may need to really beef up our observables.\n      # One possibility is to extend observables to full fledged deferreds\n      # which can be rejected by listeners added to the chain.\n      \n      repository.branch(previousBranch)\n\n      errors [\"Error switching to #{branchName}, still on #{previousBranch}\"]\n\n  if issue\n    notify issue.fullDescription()\n    \n    changeBranch issue.branchName()\n  else    \n    notify \"Default branch selected\"\n    \n    changeBranch repository.defaultBranch()\n\n$root\n  .append(HAMLjr.render \"editor\",\n    filetree: filetree\n    actions: actions\n    notices: notices\n    errors: errors\n    issues: issues\n  )\n\nGistquire.api(\"rate_limit\")\n.then (data, status, request) ->\n  $root.append HAMLjr.render \"github_status\",\n    request: request\n\nwindow.onbeforeunload = ->\n  if filetree.hasUnsavedChanges()\n    \"You have some unsaved changes, if you leave now you will lose your work.\"\n",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "mode": "100644",
      "content": "width: 960\nheight: 800\nremoteDependencies: [\n  \"//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\"\n  \"//code.jquery.com/jquery-1.10.1.min.js\"\n  \"//d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\"\n  \"http://strd6.github.io/tempest/javascripts/envweb.js\"\n  \"http://strd6.github.io/sandbox/master.js\"\n  \"http://strd6.github.io/require/master.js?01\"\n]\ndependencies:\n  issues: \"http://strd6.github.io/issues/master.json\"\n  test_runner: \"http://strd6.github.io/tests/master.json\"\n",
      "type": "blob"
    },
    "source/actions.coffee.md": {
      "path": "source/actions.coffee.md",
      "mode": "100644",
      "content": "    Runner = require(\"./runner\")\n    Builder = require(\"./builder\")\n    TestRunner = require(\"test_runner\")\n\nThe primary actions of the editor. This should eventually become a mixin.\n\n    publish = ({builder, fileData, repository}) ->\n      \n        builder.build(fileData)\n        .then (build) ->\n          branch = repository.branch()\n    \n          repository.publish builder.standAlone(build, branch)\n    \n    commit = ({fileData, repository, message}) ->\n      repository.commitTree\n        tree: fileData\n        message: message\n\n    Actions =\n      save: (params) ->\n        commit(params)\n        .then ->\n          publish(params)\n    \n      run: ({builder, filetree}) ->\n        sandbox = Runner.run\n          config: Builder.readConfig(ENV) # TODO: Get config from actual file\n\n        builder.runnable(filetree.data())\n        .then ({html}) ->\n          sandbox.document.open()\n          sandbox.document.write(html)\n          sandbox.document.close()\n          \n      test: ({builder, filetree}) ->\n        sandbox = Runner.run\n          config: Builder.readConfig(ENV) # TODO: Get config from actual file\n\n        builder.testScripts(filetree.data())\n        .then (testScripts) ->\n          html = TestRunner.html(testScripts)\n          sandbox.document.open()\n          sandbox.document.write(html)\n          sandbox.document.close()\n\n      load: ({filetree, repository}) ->\n        # Decode all content in place\n        processDirectory = (items) ->\n          items.each (item) ->\n            return item unless item.content\n    \n            item.content = Base64.decode(item.content)\n            item.encoding = \"raw\"\n    \n        repository.latestTree()\n        .then (results) ->\n          files = processDirectory results\n          filetree.load files\n\n    module.exports = Actions\n",
      "type": "blob"
    },
    "source/builder.coffee.md": {
      "path": "source/builder.coffee.md",
      "mode": "100644",
      "content": "Builder\n=======\n\nThe builder knows how to compile a source tree or individual files into various\nbuild products.\n\nThis should be extracted to a separate library eventually.\n\nDependencies\n------------\n\nThis guy helps package our app and manage dependencies.\n\n    packager = require('./packager')()\n\nHelpers\n-------\n\n`arrayToHash` converts an array of fileData objects into an object where each\nfile's path is a key and the fileData is the object.\n\n    arrayToHash = (array) ->\n      array.eachWithObject {}, (file, hash) ->\n        hash[file.path] = file\n\n`stripMarkdown` converts a literate file into pure code for compilation or execution.\n\n    stripMarkdown = (content) ->\n      content.split(\"\\n\").map (line) ->\n        if match = (/^([ ]{4}|\\t)/).exec line\n          line[match[0].length..]\n        else\n          \"\"\n      .join(\"\\n\")\n\n`compileTemplate` compiles a haml file into a HAMLjr program.\n\n    compileTemplate = (source, name=\"test\") ->\n      program = HAMLjr.compile source,\n        compiler: CoffeeScript\n\n      \"module.exports = #{program};\"\n\n`compileStyl` compiles a styl file into css.\n\n    compileStyl = (source) ->\n      styleContent = styl(source, whitespace: true).toString()\n      \n      \"module.exports = #{JSON.stringify(styleContent)}\"\n\n`compileFile` take a fileData and returns a buildData. A buildData has a `path`,\nand properties for what type of content was built.\n\nTODO: Allow for files to generate docs and code at the same time.\n\n    compileFile = ({path, content}) ->\n      [name, extension] = [path.withoutExtension(), path.extension()]\n      \n      result =\n        switch extension\n          when \"js\"\n            code: content\n          when \"coffee\"\n            code: CoffeeScript.compile(content)\n          when \"haml\"\n            code: compileTemplate(content, name)\n          when \"styl\"\n            code: compileStyl(content)\n          when \"md\"\n            # Separate out code and call compile again\n            compileFile\n              path: name\n              content: stripMarkdown(content)\n          else\n            {}\n    \n      Object.defaults result,\n        name: name\n        extension: extension\n\n      Object.extend result,\n        path: path\n\n`documentFile` generates documentation for a literate file. Right now it just\nrenders straight markdown, but it will get more clever in the future.\n\nTODO: Maybe doc more files than just .md?\n\n    documentFile = (content, path) ->\n      if path.extension() is \"md\"\n        marked(content)\n      else\n        \"\"\n\n`makeScript` returns a string representation of a script tag.\n\n    makeScript = (attrs) -> \n      $(\"<script>\", attrs).prop('outerHTML')\n\n`dependencyScripts` returns a string containing the script tags that are\nthe dependencies of this build.\n\n    dependencyScripts = (build) ->\n      remoteDependencies = readConfig(build).remoteDependencies\n  \n      (if remoteDependencies\n        remoteDependencies.map (src) ->\n          makeScript\n            class: \"env\"\n            src: src\n      else # Carry forward our own env if no dependencies specified\n        $('script.env').map ->\n          @outerHTML\n        .get()\n      ).join(\"\\n\")\n\nBuilder\n-------\n\nThe builder instance.\n\nTODO: Extract this whole duder to a separate component.\n\nTODO: Standardize interface to use promises.\n\nTODO: Allow configuration of builder instances, adding additional compilers,\npostprocessors, etc.\n\n    Builder = ->\n      build = (fileData) ->    \n        results = fileData.map ({path, content}) ->\n          try\n            # TODO: Separate out tests\n    \n            compileFile\n              path: path\n              content: content\n          catch {location, message}\n            if location?\n              message = \"Error on line #{location.first_line + 1}: #{message}\"\n    \n            error: \"#{path} - #{message}\"\n            \n        [errors, data] = results.partition (result) -> result.error\n        \n        if errors.length\n          Deferred().reject(errors.map (e) -> e.error)\n        else\n          Deferred().resolve(data)\n    \n      postProcessors = []\n      \n      addPostProcessor: (fn) ->\n        postProcessors.push fn\n        \n      buildDocs: (fileData) ->\n        fileData.map ({path, content}) ->\n          try\n            path: path\n            documentation: documentFile(content, path)\n          catch {location, message}\n            if location?\n              message = \"Error on line #{location.first_line + 1}: #{message}\"\n    \n            error: \"#{path} - #{message}\"\n\nCompile and build a tree of file data into a distribution. The distribution should\ninclude source files, compiled files, and documentation.\n\n      build: (fileData) ->\n        build(fileData)\n        .then (items) ->\n          results = []\n\n          items.eachWithObject results, (item, hash) ->\n            if item.code\n              results.push item\n            else\n              # Do nothing, we don't know about this item\n\n          results = results.map (item) ->\n            path: item.name\n            content: item.code\n            type: \"blob\"\n      \n          # TODO: We should be able to put a lot of this into postProcessors\n      \n          source = arrayToHash(fileData)\n      \n          # TODO: Robustify bundled dependencies\n          # Right now we're always loading them from remote urls during the\n          # build step. The default http caching is probably fine to speed this\n          # up, but we may want to look into keeping our own cache during dev\n          # in addition to using the package's existing dependencies rather\n          # than always updating\n          dependencies = readConfig(source: source).dependencies or {}\n          \n          packager.collectDependencies(dependencies)\n          .then (bundledDependencies) ->\n            postProcessors.pipeline\n              source: source\n              distribution: arrayToHash(results)\n              entryPoint: \"main\"\n              dependencies: bundledDependencies\n    \n      program: (build) ->\n        {distribution, entryPoint} = build\n\n        program = distribution[entryPoint].content\n\n      envDeclaration: (build) ->\n        \"\"\"\n          ENV = #{JSON.stringify(build, null, 2)};\n        \"\"\"\n\n      buildStyle: (fileData) ->\n        @build(fileData)\n        .then (build) ->\n          {distribution} = build\n\n          content = distribution[\"style.css\"]?.content or \"\"\n\n      testScripts: (fileData) ->\n        @build(fileData).then (build) =>\n          {distribution} = build\n\n          testProgram = Object.keys(distribution).select (path) ->\n            path.match /test\\//\n          .map (testPath) ->\n            \"require('./#{testPath}')\"\n          .join \"\\n\"\n          \n          \"\"\"\n            #{dependencyScripts(build)}\n            <script>\n              #{@envDeclaration(build)}\n              #{testProgram}\n            <\\/script>\n          \"\"\"\n          \n      runnable: (fileData) ->\n        @build(fileData)\n        .then (build) =>\n          standAlone = @standAlone(build)\n          standAlone.config = Builder.readConfig(build)\n\n          return standAlone\n\nCreate the standalone components of this package. An html page that loads the \nmain entry point for demonstration purposes and a json package that can be\nused as a dependency in other packages.\n\n      standAlone: (pkg) ->\n        {source, distribution} = pkg\n\n        content = []\n    \n        content.push \"\"\"\n          <!doctype html>\n          <head>\n          <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n        \"\"\"\n\n        content = content.concat dependencyScripts(pkg)\n\n        program = @program(pkg)\n\nGet entry point from package configuration\n\n        entryPoint = readConfig(pkg).entryPoint or \"main\"\n        \n        content.push \"\"\"\n          </head>\n          <body>\n          #{makeScript html: @envDeclaration(pkg)}\n          #{makeScript html: \"require('./#{entryPoint}')\"}\n          </body>\n          </html>\n        \"\"\"\n\n        html: content.join \"\\n\"\n        script: program\n        json: JSON.stringify(pkg, null, 2)\n\nTODO: May want to move this to the environment so any program can read its\nconfig\n\n    readConfig = (build) ->\n      if configData = build.source[\"pixie.cson\"]?.content\n        CSON.parse(configData)\n      else if configData = build.source[\"pixie.json\"]?.content\n        JSON.parse(configData)\n      else\n        {}\n    \n    Builder.readConfig = readConfig\n\n    module.exports = Builder\n",
      "type": "blob"
    },
    "source/deferred.coffee.md": {
      "path": "source/deferred.coffee.md",
      "mode": "100644",
      "content": "Use jQuery.Deferred to implement deferreds, but\nstay insulated by not blasting the $ all over our code\nthat doesn't really depend on jQuery\nThis let's us swap our our Deferred provider more easily later.\n\n    global.Deferred = $.Deferred\n\nA helper to return a promise that may be resolved or rejected by the passed\ncode block.\n\n    withDeferrence = (fn) ->\n      deferred = Deferred()\n    \n      # TODO: This try catch may be useless from deferring the fn\n      try\n        fn.defer(deferred)\n      catch e\n        deferred.reject(e)\n    \n      return deferred.promise()\n\nA deferred encapsulating a confirm dialog.\n\n    Deferred.Confirm = (message) ->\n      withDeferrence (deferred) ->\n        if window.confirm(message)\n          deferred.resolve()\n        else\n          deferred.reject()\n\nA deferred that may present a confirm dialog, but only if a certain condition is\nmet.\n\n    Deferred.ConfirmIf = (flag, message) ->\n      if flag\n        return Deferred.Confirm(message)\n      else\n        withDeferrence (deferred) ->\n          deferred.resolve()\n\nA deferred that encapsulates a conditional execution of a block that returns a\npromise. If the condition is met the promise returning block is executed,\notherwise the deferred is marked as resolved and the block is not executed.\n\n    Deferred.ExecuteIf = (flag, callback) ->\n      withDeferrence (deferred) ->\n        if flag\n          callback().then deferred.resolve\n        else\n          deferred.resolve()\n",
      "type": "blob"
    },
    "source/duct_tape.coffee.md": {
      "path": "source/duct_tape.coffee.md",
      "mode": "100644",
      "content": "Here we have simple extension and utility methods that should be moved into our framework's environment libraries.\n\n`String#dasherize` should be moved into inflecta.\n\nConvert a string with spaces and mixed case into all lower case with spaces replaced with dashes. This is the style that Github branch names are commonly in.\n\n    String::dasherize = ->\n      @trim()\n        .replace(/\\s+/g, \"-\")\n        .toLowerCase()\n\n`CSON` parses CoffeeScript object literals. This is a big hack, but can be \nformalized later if it proves useful.\n\nAnother downside is that it depends on the CoffeeScript compiler when it should\nbe a simple parser of its own.\n\n    global.CSON =\n      parse: (source) ->\n        Function(\"return #{CoffeeScript.compile(source, bare: true)}\")()\n\nThis really needs to be improved. To do it correctly we'd need to detect \nobject/array values and indent while moving them to separate lines. Single\nvalues would exist without newlines or indentation. CSON.stringify would be\ncalled recursively.\n\nThe current hack of using JSON works because JSON is valid CSON.\n\n      stringify: (object) ->\n        representation = JSON.parse(JSON.stringify(obj))\n\n        Object.keys(representation).map (key) ->\n          value = representation[key]\n          \"#{key}: #{JSON.stringify(value)}\"\n        .join(\"\\n\")\n        \nAdds a `render` helper method to HAMLjr. This should work it's way back into the\nHAMLjr runtime.\n\n`render` Looks up a template and renders it with the given object.\n\n    HAMLjr.render = (templateName, object) ->\n      templates = HAMLjr.templates\n      template = templates[templateName] or templates[\"templates/#{templateName}\"]\n\n      if template\n        template(object)\n      else\n        throw \"Could not find template named #{templateName}\"\n",
      "type": "blob"
    },
    "source/file.coffee.md": {
      "path": "source/file.coffee.md",
      "mode": "100644",
      "content": "The `File` model represents a file in a file system. It is populated by data\nreturned from the Github API.\n\n    File = (I={}) ->\n      I.path ?= I.filename\n      I.filename ?= I.path.split(\"/\").last()\n    \n      self = Model(I).observeAll()\n    \n      self.extend\n      \nThe extension is the last part of the filename after the `.`, for example\n`\"coffee\"` for a file named `\"main.coffee\"` or `\"haml\"` for a file named\n`\"filetree.haml\"`.\n      \n        extension: ->\n          self.filename().extension()\n\nThe `mode` of the file is what editor mode to use for our text editor.\n\n        mode: ->\n          switch extension = self.extension()\n            when \"js\"\n              \"javascript\"\n            when \"md\" # TODO: See about nested markdown code modes for .haml.md, .js.md, and .coffee.md\n              \"markdown\"\n            when \"cson\"\n              \"coffee\"\n            when \"\"\n              \"text\"\n            else\n              extension\n\nModified tracks whether the file has been changed since it was created.\n\n        modified: Observable(false)\n\nThe `displayName` is how the file appears in views.\n\n        displayName: Observable(self.path())\n\nWhen our content changes we assume we are modified. In the future we may want to\ntrack the original content and compare with that to get a more accurate modified\nstatus.\n\n      self.content.observe ->\n        self.modified(true)\n\nWhen our modified state changes we adjust the file name to provide a visual\nindication.\n\n      self.modified.observe (modified) ->\n        if modified\n          self.displayName(\"*#{self.path()}\")\n        else\n          self.displayName(self.path())\n    \n      return self\n\nExport\n\n    module.exports = File\n",
      "type": "blob"
    },
    "source/filetree.coffee.md": {
      "path": "source/filetree.coffee.md",
      "mode": "100644",
      "content": "    File = require(\"./file\")\n\nThe `Filetree` model represents a tree of files.\n\n    Filetree = (I={}) ->\n      Object.defaults I,\n        files: []\n    \n      self = Model(I).observeAll()\n\nThe `selectedFile` observable keeps people up to date on what file has been\nselected.\n\n      self.attrObservable \"selectedFile\"\n    \n      self.extend\n        \nLoad files either from an array of file data objects or from an object with\npaths as keys and file data objects as values.\n\nThe files are sorted by name after loading.\n\nTODO: Always maintain the files in a sorted list using some kind of sorted\nobservable.\n\n        load: (fileData) ->\n          if Array.isArray(fileData)\n            files = fileData.sort (a, b) ->\n              if a.path < b.path\n                -1\n              else if b.path < a.path\n                1\n              else\n                0\n            .map File\n    \n          else\n            files = Object.keys(fileData).sort().map (path) ->\n              File fileData[path]\n    \n          self.files(files)\n\nThe `data` method returns an array of file data objects that is compatible with\nthe github tree api.\n\nThe objects have a `path`, `content`, `type`, and `mode`.\n\n        data: ->\n          self.files.map (file) ->\n            path: file.path()\n            mode: \"100644\"\n            content: file.content()\n            type: \"blob\"\n\nThe filetree `hasUnsavedChanges` if any file in the tree is modified.\n\n        hasUnsavedChanges: ->\n          self.files().select (file) ->\n            file.modified()\n          .length\n\nMarking the filetree as saved resets the modification status of each file.\n\nTODO: There can be race conditions since the save is async.\n\nTODO: Use git trees and content shas to robustly manage changed state.\n\n        markSaved: ->\n          self.files().each (file) ->\n            file.modified(false)\n    \n      return self\n\nExport\n\n    module.exports = Filetree\n",
      "type": "blob"
    },
    "source/gistquire.coffee.md": {
      "path": "source/gistquire.coffee.md",
      "mode": "100644",
      "content": "Gistquire handles our connection to the Github API.\n\n    Gistquire =\n      accessToken: null\n\nCalling auth will redirect to github for authentication.\n\nTODO: parameterize the method to allow for different `scope`s or `client_id`s.\n\n      auth: ->\n        scope = \"gist,repo,user:email\"\n        url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=#{scope}\"\n    \n        window.location = url\n    \nCall onload to check for the code returned from github authentication\nand to get our access token from our authorization app.\n\nTODO: Maybe think about returning a deferred?\n\n      onload: ->\n        # TODO: Namespace local storage key\n    \n        if code = window.location.href.match(/\\?code=(.*)/)?[1]\n          $.getJSON \"https://hamljr-auth.herokuapp.com/authenticate/#{code}\", (data) =>\n            if token = data.token\n              @accessToken = token\n              localStorage.authToken = token\n    \n        if localStorage.authToken\n          @accessToken = localStorage.authToken\n\nMake a call to the github API. The path can be either a relative path such as\n`users/STRd6` or an absolute path like `https://api.github.com/users/octocat` or\n`user.url`.\n\nWe attach our `accessToken` if present.\n\n`api` returns a promise for easy chaining.\n\n      api: (path, options={}) ->\n        if path.match /^http/\n          url = path\n        else\n          url = \"https://api.github.com/#{path}\"\n        \n        options.headers ||= {}\n        \n        if @accessToken\n          options.headers[\"Authorization\"] = \"token #{@accessToken}\"\n    \n        options = Object.extend\n          url: url\n          type: \"GET\"\n          dataType: 'json'\n        , options\n    \n        $.ajax options\n\n    module.exports = Gistquire\n",
      "type": "blob"
    },
    "source/packager.coffee.md": {
      "path": "source/packager.coffee.md",
      "mode": "100644",
      "content": "This guy is resopnsible for packaging things, probably related to the builder.\n\nJust putting some things here to try and sort them out.\n\nThe main responsibilities will be bundling dependencies, and creating the\npackage.\n\n    Packager = ->\n      collectDependencies: (dependencies) ->\n        names = Object.keys(dependencies)\n      \n        $.when.apply(null, names.map (name) ->\n          value = dependencies[name]\n          \n          if typeof value is \"string\"\n            $.getJSON(value)\n          else\n            Deferred().reject(\"Can only handle url string dependencies right now\")\n        ).then (results...) ->\n          # WTF: jQuery.when behaves differently for one argument than it does for\n          # two or more.\n          if names.length is 1\n            results = [results]\n          \n          bundledDependencies = {}\n\n          names.each (name, i) ->\n            bundledDependencies[name] = results[i][0]\n\n          return bundledDependencies\n\n    module.exports = Packager\n",
      "type": "blob"
    },
    "source/repository.coffee.md": {
      "path": "source/repository.coffee.md",
      "mode": "100644",
      "content": "Repsoitory\n==========\n\n`Repository` wraps the concept of a Github repository. It includes additional \ndata for the local working copy such as the current branch.\n\nAll of the methods return promises to allow for easy chaining and error\nreporting.\n\n    Gistquire = require(\"./gistquire\")\n\nConstructor\n-----------\n\nCurrently the only parameter needed to initialize a repository instance is a\n`url`. This url is used as a base for the api calls.\n\n    Repository = (I={}) ->\n      Object.defaults I,\n        branch: \"master\"\n        defaultBranch: \"master\"\n    \n      self = Model(I).observeAll()\n      \n      # The currently active branch in the working copy\n      self.attrObservable \"branch\"\n      \n      # TODO: Extract all of these methods to an API generator\n      requestOptions = (type, data) ->\n        type: type\n        data: JSON.stringify(data)\n    \n      api = (path, options) ->\n        if path.match /^http/\n          url = path\n        else\n          url = \"#{self.url()}/#{path}\"\n              \n        Gistquire.api url, options\n    \n      get = (path, data) ->\n        api path, data: data\n    \n      put = (path, data) ->\n        api(path, requestOptions(\"PUT\", data))\n        \n      post = (path, data) ->\n        api(path, requestOptions(\"POST\", data))\n        \n      patch = (path, data) ->\n        api path, requestOptions(\"PATCH\", data)\n    \n      self.extend\n        pullRequests: ->\n          get \"pulls\"\n    \n        createPullRequest: ({title}) ->\n          head = title.dasherize()\n    \n          self.switchToBranch(head)\n          .then(self.commitEmpty)\n          .then ->\n            post \"pulls\",\n              base: I.defaultBranch\n              head: head\n              title: title\n    \n        initPagesBranch: ->\n          branch = \"gh-pages\"\n        \n          # Post an empty tree to use for the base commit\n          # TODO: Learn how to post an empty tree\n          post \"git/trees\",\n            tree: [{\n              mode: \"1006444\"\n              path: \"tempest.txt\"\n              content: \"created by strd6.github.io/editor\"\n            }]\n          .then (data) ->\n            # Create the base commit for the branch\n            post \"git/commits\",\n              message: \"Initial gh-pages commit\"\n              tree: data.sha\n          .then (data) ->\n            # Create the branch based on the base commit\n            post \"git/refs\",\n              ref: \"refs/heads/#{branch}\"\n              sha: data.sha\n          \n        writeFile: (params) ->\n          {branch, path, content, message} = params\n    \n          get \"contents/#{path}\",\n            ref: branch\n          .then (data) ->\n            # The file existed, so we update it using the existing sha\n            put \"contents/#{path}\",\n              content: content\n              sha: data.sha\n              message: message\n              branch: branch\n          , (request) ->\n            # If we fail because the gh-pages branch doesn't exist try creating it and retrying\n            if request.responseJSON?.message is \"No commit found for the ref gh-pages\"\n              self.initPagesBranch().then ->\n                # Trying again after creating the gh-pages branch\n                self.writeFile(params)\n            # The file didn't exist so we create a new one\n            else if request.status is 404\n              put \"contents/#{path}\",\n                content: content\n                message: message\n                branch: branch\n            else\n              Deferred().reject(arguments...)\n    \n        latestTree: (branch=self.branch()) ->\n          get(\"git/refs/heads/#{branch}\")\n          .then (data) ->\n            get data.object.url\n          .then (data) ->\n            get \"#{data.tree.url}?recursive=1\"\n          .then (data) ->\n            files = data.tree.select (file) ->\n              file.type is \"blob\"\n      \n            # Gather the data for each file\n            $.when.apply(null, files.map (datum) ->\n              get(datum.url)\n              .then (data) ->\n                Object.extend(datum, data)\n            )\n          .then (results...) -> \n            results\n    \n        commitTree: ({message, tree}) ->\n          branch = self.branch()\n          message ?= \"Updated in browser at strd6.github.io/editor\"\n          \n          unless tree\n            throw Error(\"Must pass in a tree\")\n            \n          # TODO: Is there a cleaner way to pass this through promises?\n          latestCommitSha = null\n    \n          get(\"git/refs/heads/#{branch}\")\n          .then (data) ->\n            latestCommitSha = data.object.sha\n            \n            post \"git/trees\",\n              tree: tree\n          .then (data) ->\n            # Create another commit\n            post \"git/commits\",\n              parents: [latestCommitSha]\n              message: message\n              tree: data.sha\n          .then (data) ->\n            # Update the branch head\n            patch \"git/refs/heads/#{branch}\",\n              sha: data.sha\n        \n        # TODO: this is currently a hack because we can't create a pull request\n        # if there are no different commits\n        commitEmpty: ->\n          branch = self.branch()\n          latestCommit = null\n          \n          get(\"git/refs/heads/#{branch}\")\n          .then (data) ->\n            get data.object.url\n          .then (data) ->\n            # Create another commit\n            post \"git/commits\",\n              parents: [data.sha]\n              message: \"This commit intentionally left blank\"\n              tree: data.tree.sha\n          .then (data) ->\n            # Update the branch head\n            patch \"git/refs/heads/#{branch}\",\n              sha: data.sha\n    \n        switchToBranch: (branch) ->\n          ref = \"refs/heads/#{branch}\"\n          \n          setBranch = (data) ->\n            self.branch(branch)\n            \n            return data\n    \n          get(\"git/#{ref}\")\n          .then setBranch # Success\n          , (request) -> # Failure\n            branchNotFound = (request.status is 404)\n    \n            if branchNotFound\n              # Create branch if it doesn't exist\n              # Use our current branch as a base\n              get(\"git/refs/heads/#{self.branch()}\")\n              .then (data) ->\n                post \"git/refs\",\n                  ref: ref\n                  sha: data.object.sha\n              .then(setBranch)\n            else\n              Deferred().reject(arguments...)\n    \n        mergeInto: (branch=self.defaultBranch()) ->\n          post \"merges\",\n            base: branch\n            head: self.branch()\n            \n        pullFromBranch: (branch=self.defaultBranch()) ->\n          post \"merges\",\n            base: self.branch()\n            head: branch\n    \n        publish: ({html, script, json}) ->\n          branch = self.branch()\n          message = \"Built #{branch} in browser in strd6.github.io/editor\"\n    \n          if branch is \"master\"\n            path = \"index.html\"\n          else\n            path = \"#{branch}.html\"\n    \n          # Assuming git repo with gh-pages branch\n          publishBranch = \"gh-pages\"\n    \n          # TODO: Make this one commit rather than a sequence of write files\n          # create <branch>.html\n          self.writeFile\n            path: path\n            content: Base64.encode(html)\n            branch: publishBranch\n            message: message\n          .then ->\n            self.writeFile\n              path: \"#{branch}.js\"\n              content: Base64.encode(script)\n              branch: publishBranch\n              message: message\n          .then ->\n            self.writeFile\n              path: \"#{branch}.json\"\n              content: Base64.encode(json)\n              branch: publishBranch\n              message: message\n    \n      return self\n\n\n    module.exports = Repository\n",
      "type": "blob"
    },
    "source/runner.coffee.md": {
      "path": "source/runner.coffee.md",
      "mode": "100644",
      "content": "Runner manages running apps in sandboxed windows and passing messages back and \nforth from the parent to the running instances.\n\nWe keep a list of running windows so we can hot-update them when we modify our\nown code.\n\nOne cool example use is if you are modifying your css you can run several \ninstances of your app and navigate to different states. Then you can see in real\ntime how the css changes affect each one.\n\n    runningWindows = []\n\n    Runner =\n      run: ({config}) ->\n        sandbox = Sandbox\n          width: config.width\n          height: config.height\n\n        runningWindows.push sandbox\n\n        return sandbox\n\n      hotReloadCSS: (css, path) ->      \n        runningWindows = runningWindows.partition (window) ->\n          return false if window.closed\n                    \n          # TODO: We're assuming only one style in the body\n          # which is reasonable in most cases, but we may want\n          # to scope it by the path of the specific css file\n          # to handle a wider range of situations\n          $(window.document).find(\"body style:eq(0)\").html(css)\n          \n          return true\n        .first()\n\n    module.exports = Runner\n",
      "type": "blob"
    },
    "source/runtime.coffee.md": {
      "path": "source/runtime.coffee.md",
      "mode": "100644",
      "content": "The runtime holds utilities to assist with an apps running environment.\n\nIt should me moved into it's own component one day.\n\n    Runtime = (ENV) ->\n\nReturns the node that is the parent of the script element that contains the code\nthat calls this function. If `document.write` has been called before this then the\nresults may not be accurate. Therefore be sure to call currentNode before\nwriting anything to the document.\n\n      currentNode = ->\n        target = document.documentElement\n      \n        while (target.childNodes.length and target.lastChild.nodeType == 1)\n          target = target.lastChild\n      \n        return target.parentNode\n\nDisplay a promo in the console linking back to the creator of this app.\n\n      promo = ->\n        console.log(\"%c You should meet my creator #{ENV.progenitor.url}\", \"\"\"\n          background: #000; \n          color: white; \n          font-size: 2em;\n          line-height: 2em;\n          padding: 40px 100px;\n          margin-bottom: 1em;\n          text-shadow: \n            0 0 0.05em #fff, \n            0 0 0.1em #fff, \n            0 0 0.15em #fff, \n            0 0 0.2em #ff00de, \n            0 0 0.35em #ff00de, \n            0 0 0.4em #ff00de, \n            0 0 0.5em #ff00de, \n            0 0 0.75em #ff00de;'\n        \"\"\")\n\nCall on start to boot up the runtime, get the root node, add styles, display a \npromo.\n\n      boot: ->\n        root = currentNode()\n\n        promo()\n\nReturns the root element, where the app should append all of the elements it\ncreates.\n\n        return root\n        \n      applyStyleSheet: (root, name) ->\n        styleNode = document.createElement(\"style\")\n        styleNode.innerHTML = require(name)\n        styleNode.className = name\n        \n        root.appendChild(styleNode)\n\nExport\n\n    module.exports = Runtime\n",
      "type": "blob"
    },
    "source/text_editor.coffee.md": {
      "path": "source/text_editor.coffee.md",
      "mode": "100644",
      "content": "The `TextEditor` is a model for editing a text file. Currently it uses the Ace\neditor, but we may switch in the future. All the editor specific things live in\nhere.\n\n    TextEditor = (I) ->\n      Object.reverseMerge I,\n        mode: \"coffee\"\n        text: \"\"\n\n      self = Model(I)\n\nWe can't use ace on a div not in the DOM so we need to be sure to pass one in.\n\n      el = I.el\n\nWe can't serialize DOM elements so we need to be sure to delete it.\n\n      delete I.el\n\nHere we create and configure the Ace text editor.\n\nTODO: Load these options from a preferences somewhere.\n\n      editor = ace.edit(el)\n      editor.setFontSize(\"16px\")\n      editor.setTheme(\"ace/theme/chrome\")\n      editor.getSession().setUseWorker(false)\n      editor.getSession().setMode(\"ace/mode/#{I.mode}\")\n      editor.getSession().setUseSoftTabs(true)\n      editor.getSession().setTabSize(2)\n\n`reset` Sets the content of the editor to the given content and also resets any\ncursor position or selection.\n\n      reset = (content=\"\") ->\n        editor.setValue(content)\n        editor.moveCursorTo(0, 0)\n        editor.session.selection.clearSelection()\n    \n      reset(I.text)\n\nOur text attribute is observable so clients can track changes.\n\n      self.attrObservable \"text\"\n\nWe modify our text by listening to change events from Ace.\n\nTODO: Remove these `updating` hacks.\n\n      updating = false\n      editor.getSession().on 'change', ->\n        updating = true\n        self.text(editor.getValue())\n        updating = false\n\nWe also observe any changes to `text` ourselves to stay up to date with outside\nmodifications. Its a bi-directional binding.\n\n      self.text.observe (newValue) ->\n        unless updating\n          reset(newValue)\n\nWe expose some properties and methods.\n\n      self.extend\n        el: el\n        editor: editor\n        reset: reset\n    \n      return self\n\n    module.exports = TextEditor\n",
      "type": "blob"
    },
    "style.styl": {
      "path": "style.styl",
      "mode": "100644",
      "content": "html, body\n  margin: 0\n  height: 100%\n\n.main\n  position: relative\n  padding-top: 40px\n  padding-left: 200px\n  padding-bottom: 100px\n  box-sizing: border-box\n  height: 100%\n\n.editor-wrap\n  background-color: white\n  width: 100%\n  height: 100%\n  position: relative\n\n  & > div\n    position: absolute\n    top: 0\n    left: 0\n    right: 0\n    bottom: 0\n\n.filetree\n  margin: 0\n  padding: 0\n  width: 200px\n  position: absolute\n  left: 0\n  top: 40px\n  z-index: 2\n\n  li\n    list-style-type: none\n    padding-left: 1em\n    position: relative\n    whitespace: nowrap\n\n    .delete\n      display: none\n      position: absolute\n      right: 0\n      top: 0\n\n    &:hover\n      background-color: lightyellow\n\n      .delete\n        display: inline-block\n\n.actions\n  position: absolute\n  top: 0\n  left: 200px\n\n.console-wrap\n  box-sizing: border-box\n  position: absolute\n  bottom: 0\n  left: 0\n  right: 0\n  padding-left: 200px\n  height: 100px\n  width: 100%\n  margin: 0\n  \n  .errors\n    box-sizing: border-box\n    border-top: 1px solid black\n    color: red\n\n.status\n  top: 0\n  right: 0\n  position: absolute\n",
      "type": "blob"
    },
    "templates/actions.haml.md": {
      "path": "templates/actions.haml.md",
      "mode": "100644",
      "content": "The actions bar holds several buttons that can be pressed to perform actions in\nthe editor.\n\n    .actions\n      - actions = @actions\n\nRender a series of buttons, one for each action.\n\n      - Object.keys(actions).each (name) ->\n        %button\n          = name.titleize()\n\nIn our click handler we don't pass any event data to the action.\n\n          - on \"click\", ->\n            - actions[name]()\n\nThe issues selector is also rendered in the actions bar.\n\n      = HAMLjr.render \"issues\", @issues\n",
      "type": "blob"
    },
    "templates/editor.haml.md": {
      "path": "templates/editor.haml.md",
      "mode": "100644",
      "content": "The main editor template renders all the other sub-templates.\n\n    .main\n      = HAMLjr.render \"actions\", actions: @actions, issues: @issues\n      = HAMLjr.render \"filetree\", @filetree\n      = HAMLjr.render \"notices\", this\n",
      "type": "blob"
    },
    "templates/filetree.haml.md": {
      "path": "templates/filetree.haml.md",
      "mode": "100644",
      "content": "Render a list of files as a filetree.\n\n    %ul.filetree\n      - selectedFile = @selectedFile\n      - files = @files\n      - each files, (file) ->\n        %li= file.displayName\n          - on \"click\", (e) -> \n            - selectedFile(file) if $(e.target).is('li')\n          .delete\n            - on \"click\", -> files.remove(file) if confirm(\"Delete #{file.path()}?\")\n            X\n",
      "type": "blob"
    },
    "templates/github_status.haml.md": {
      "path": "templates/github_status.haml.md",
      "mode": "100644",
      "content": "Display information about the current Github api session.\n\n    .status\n      - if @request and @request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)\n        Authenticated Scopes:\n        = @request.getResponseHeader(\"X-OAuth-Scopes\")\n        %br\n        Rate Limit Remaining:\n        = @request.getResponseHeader(\"X-RateLimit-Remaining\")\n        = \" / 5000\"\n      - else\n        %button Auth\n          - on \"click\", Gistquire.auth\n",
      "type": "blob"
    },
    "templates/notices.haml.md": {
      "path": "templates/notices.haml.md",
      "mode": "100644",
      "content": "A simple console to display streams of errors and notices.\n\n    .console-wrap\n      %pre.errors\n        - each @errors, (error) ->\n          = error\n      %pre.notices\n        - each @notices, (notice) ->\n          = notice\n",
      "type": "blob"
    },
    "templates/text_editor.haml.md": {
      "path": "templates/text_editor.haml.md",
      "mode": "100644",
      "content": "A simple wrap to hold a text editor.\n\n    .editor-wrap\n      .editor\n",
      "type": "blob"
    },
    "test/another_test.coffee.md": {
      "path": "test/another_test.coffee.md",
      "mode": "100644",
      "content": "Testing that multiple test files work.\n\n    describe \"editor\", ->\n      it \"should run both files\", ->\n        assert true\n",
      "type": "blob"
    },
    "test/test.coffee.md": {
      "path": "test/test.coffee.md",
      "mode": "100644",
      "content": "Starting with just an assert true to test that testing works at all.\n\n    describe \"editor\", ->\n      it \"should test things\", ->\n        assert true\n",
      "type": "blob"
    }
  },
  "distribution": {
    "main": {
      "path": "main",
      "content": "(function() {\n  var $root, Actions, Builder, File, Filetree, Gistquire, Issue, Issues, Repository, Runner, Runtime, TextEditor, actions, branch, builder, classicError, confirmUnsaved, distribution, errors, files, filetree, fullName, hotReloadCSS, issues, issuesTemplate, notices, notify, owner, repo, repository, repositoryLoaded, rootNode, runtime, templates, _ref, _ref1, _ref2, _ref3,\n    __slice = [].slice;\n\n  files = ENV.source, distribution = ENV.distribution;\n\n  window.ENV = ENV;\n\n  require(\"./source/duct_tape\");\n\n  require(\"./source/deferred\");\n\n  templates = (HAMLjr.templates || (HAMLjr.templates = {}));\n\n  [\"actions\", \"editor\", \"filetree\", \"github_status\", \"notices\", \"text_editor\"].each(function(name) {\n    var template;\n    template = require(\"./templates/\" + name);\n    if (typeof template === \"function\") {\n      return templates[name] = template;\n    }\n  });\n\n  Actions = require(\"./source/actions\");\n\n  Builder = require(\"./source/builder\");\n\n  Runner = require(\"./source/runner\");\n\n  Runtime = require(\"./source/runtime\");\n\n  Gistquire = require(\"./source/gistquire\");\n\n  Repository = require(\"./source/repository\");\n\n  Filetree = require(\"./source/filetree\");\n\n  File = require(\"./source/file\");\n\n  TextEditor = require(\"./source/text_editor\");\n\n  classicError = function(request, error, message) {\n    debugger;\n    notices([]);\n    if (request.responseJSON) {\n      message = JSON.stringify(request.responseJSON, null, 2);\n    } else {\n      if (message == null) {\n        message = request;\n      }\n    }\n    return errors([message]);\n  };\n\n  notify = function(message) {\n    notices([message]);\n    return errors([]);\n  };\n\n  runtime = Runtime(ENV);\n\n  rootNode = runtime.boot();\n\n  try {\n    runtime.applyStyleSheet(rootNode, '/style');\n  } catch (_error) {}\n\n  $root = $(rootNode);\n\n  Gistquire.onload();\n\n  _ref = ENV.repository, owner = _ref.owner, repo = _ref.repo, branch = _ref.branch, fullName = _ref.full_name;\n\n  fullName || (fullName = \"\" + owner + \"/\" + repo);\n\n  repository = Repository({\n    url: \"repos/\" + fullName,\n    branch: branch\n  });\n\n  errors = Observable([]);\n\n  notices = Observable([]);\n\n  builder = Builder();\n\n  repositoryLoaded = function(repository) {\n    issues.repository = repository;\n    repository.pullRequests().then(issues.reset);\n    return notify(\"Finished loading!\");\n  };\n\n  confirmUnsaved = function() {\n    return Deferred.ConfirmIf(filetree.hasUnsavedChanges(), \"You will lose unsaved changes in your current branch, continue?\");\n  };\n\n  _ref1 = require(\"issues\"), (_ref2 = _ref1.models, Issue = _ref2.Issue, Issues = _ref2.Issues), (_ref3 = _ref1.templates, issuesTemplate = _ref3.issues);\n\n  templates[\"issues\"] = issuesTemplate;\n\n  issues = Issues();\n\n  builder.addPostProcessor(function(data) {\n    data.repository = {\n      full_name: fullName,\n      branch: repository.branch()\n    };\n    return data;\n  });\n\n  builder.addPostProcessor(function(data) {\n    data.progenitor = {\n      url: \"http://strd6.github.io/editor/\"\n    };\n    return data;\n  });\n\n  actions = {\n    save: function() {\n      notify(\"Saving...\");\n      return Actions.save({\n        repository: repository,\n        fileData: filetree.data(),\n        builder: builder\n      }).then(function() {\n        filetree.markSaved();\n        return notify(\"Saved and published!\");\n      }).fail(function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return errors(args);\n      });\n    },\n    run: function() {\n      return Actions.run({\n        builder: builder,\n        filetree: filetree\n      }).fail(errors);\n    },\n    test: function() {\n      notify(\"Running tests...\");\n      return Actions.test({\n        builder: builder,\n        filetree: filetree\n      }).fail(errors);\n    },\n    new_file: function() {\n      var file, name;\n      if (name = prompt(\"File Name\", \"newfile.coffee\")) {\n        file = File({\n          filename: name,\n          content: \"\"\n        });\n        filetree.files.push(file);\n        return filetree.selectedFile(file);\n      }\n    },\n    load_repo: function(skipPrompt) {\n      return confirmUnsaved().then(function() {\n        if (!skipPrompt) {\n          fullName = prompt(\"Github repo\", fullName);\n        }\n        if (fullName) {\n          repository = Repository({\n            url: \"repos/\" + fullName\n          });\n        } else {\n          errors([\"No repo given\"]);\n          return;\n        }\n        notify(\"Loading repo...\");\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          var root;\n          repositoryLoaded(repository);\n          root = $root.children(\".main\");\n          return root.find(\".editor-wrap\").remove();\n        }).fail(classicError);\n      });\n    },\n    new_feature: function() {\n      var title;\n      if (title = prompt(\"Description\")) {\n        notify(\"Creating feature branch...\");\n        return repository.createPullRequest({\n          title: title\n        }).then(function(data) {\n          var issue;\n          issue = Issue(data);\n          issues.issues.push(issue);\n          issues.silent = true;\n          issues.currentIssue(issue);\n          issues.silent = false;\n          return notices.push(\"Created!\");\n        }, classicError);\n      }\n    },\n    pull_master: function() {\n      return confirmUnsaved().then(function() {\n        notify(\"Merging in default branch...\");\n        return repository.pullFromBranch();\n      }, classicError).then(function() {\n        var branchName;\n        notices.push(\"Merged!\");\n        branchName = repository.branch();\n        notices.push(\"\\nReloading branch \" + branchName + \"...\");\n        return Actions.load({\n          repository: repository,\n          filetree: filetree\n        }).then(function() {\n          return notices.push(\"Loaded!\");\n        }).fail(function() {\n          return errors([\"Error loading \" + (repository.url())]);\n        });\n      });\n    }\n  };\n\n  filetree = Filetree();\n\n  filetree.load(files);\n\n  filetree.selectedFile.observe(function(file) {\n    var editor, root;\n    root = $root.children(\".main\");\n    root.find(\".editor-wrap\").hide();\n    if (file.editor) {\n      return file.editor.trigger(\"show\");\n    } else {\n      root.append(HAMLjr.render(\"text_editor\"));\n      file.editor = root.find(\".editor-wrap\").last();\n      editor = TextEditor({\n        text: file.content(),\n        el: file.editor.find('.editor').get(0),\n        mode: file.mode()\n      });\n      file.editor.on(\"show\", function() {\n        file.editor.show();\n        return editor.editor.focus();\n      });\n      return editor.text.observe(function(value) {\n        file.content(value);\n        if (file.path().match(/\\.styl$/)) {\n          return hotReloadCSS(file);\n        }\n      });\n    }\n  });\n\n  hotReloadCSS = (function(file) {\n    var css;\n    css = styl(file.content(), {\n      whitespace: true\n    }).toString();\n    return Runner.hotReloadCSS(css, file.path());\n  }).debounce(500);\n\n  repositoryLoaded(repository);\n\n  if (issues != null) {\n    issues.currentIssue.observe(function(issue) {\n      var changeBranch;\n      if (issues.silent) {\n        return;\n      }\n      changeBranch = function(branchName) {\n        var previousBranch;\n        previousBranch = repository.branch();\n        return confirmUnsaved().then(function() {\n          return repository.switchToBranch(branchName).then(function() {\n            notices.push(\"\\nLoading branch \" + branchName + \"...\");\n            return Actions.load({\n              repository: repository,\n              filetree: filetree\n            }).then(function() {\n              return notices.push(\"Loaded!\");\n            });\n          });\n        }, function() {\n          repository.branch(previousBranch);\n          return errors([\"Error switching to \" + branchName + \", still on \" + previousBranch]);\n        });\n      };\n      if (issue) {\n        notify(issue.fullDescription());\n        return changeBranch(issue.branchName());\n      } else {\n        notify(\"Default branch selected\");\n        return changeBranch(repository.defaultBranch());\n      }\n    });\n  }\n\n  $root.append(HAMLjr.render(\"editor\", {\n    filetree: filetree,\n    actions: actions,\n    notices: notices,\n    errors: errors,\n    issues: issues\n  }));\n\n  Gistquire.api(\"rate_limit\").then(function(data, status, request) {\n    return $root.append(HAMLjr.render(\"github_status\", {\n      request: request\n    }));\n  });\n\n  window.onbeforeunload = function() {\n    if (filetree.hasUnsavedChanges()) {\n      return \"You have some unsaved changes, if you leave now you will lose your work.\";\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/actions": {
      "path": "source/actions",
      "content": "(function() {\n  var Actions, Builder, Runner, TestRunner, commit, publish;\n\n  Runner = require(\"./runner\");\n\n  Builder = require(\"./builder\");\n\n  TestRunner = require(\"test_runner\");\n\n  publish = function(_arg) {\n    var builder, fileData, repository;\n    builder = _arg.builder, fileData = _arg.fileData, repository = _arg.repository;\n    return builder.build(fileData).then(function(build) {\n      var branch;\n      branch = repository.branch();\n      return repository.publish(builder.standAlone(build, branch));\n    });\n  };\n\n  commit = function(_arg) {\n    var fileData, message, repository;\n    fileData = _arg.fileData, repository = _arg.repository, message = _arg.message;\n    return repository.commitTree({\n      tree: fileData,\n      message: message\n    });\n  };\n\n  Actions = {\n    save: function(params) {\n      return commit(params).then(function() {\n        return publish(params);\n      });\n    },\n    run: function(_arg) {\n      var builder, filetree, sandbox;\n      builder = _arg.builder, filetree = _arg.filetree;\n      sandbox = Runner.run({\n        config: Builder.readConfig(ENV)\n      });\n      return builder.runnable(filetree.data()).then(function(_arg1) {\n        var html;\n        html = _arg1.html;\n        sandbox.document.open();\n        sandbox.document.write(html);\n        return sandbox.document.close();\n      });\n    },\n    test: function(_arg) {\n      var builder, filetree, sandbox;\n      builder = _arg.builder, filetree = _arg.filetree;\n      sandbox = Runner.run({\n        config: Builder.readConfig(ENV)\n      });\n      return builder.testScripts(filetree.data()).then(function(testScripts) {\n        var html;\n        html = TestRunner.html(testScripts);\n        sandbox.document.open();\n        sandbox.document.write(html);\n        return sandbox.document.close();\n      });\n    },\n    load: function(_arg) {\n      var filetree, processDirectory, repository;\n      filetree = _arg.filetree, repository = _arg.repository;\n      processDirectory = function(items) {\n        return items.each(function(item) {\n          if (!item.content) {\n            return item;\n          }\n          item.content = Base64.decode(item.content);\n          return item.encoding = \"raw\";\n        });\n      };\n      return repository.latestTree().then(function(results) {\n        var files;\n        files = processDirectory(results);\n        return filetree.load(files);\n      });\n    }\n  };\n\n  module.exports = Actions;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/builder": {
      "path": "source/builder",
      "content": "(function() {\n  var Builder, arrayToHash, compileFile, compileStyl, compileTemplate, dependencyScripts, documentFile, makeScript, packager, readConfig, stripMarkdown;\n\n  packager = require('./packager')();\n\n  arrayToHash = function(array) {\n    return array.eachWithObject({}, function(file, hash) {\n      return hash[file.path] = file;\n    });\n  };\n\n  stripMarkdown = function(content) {\n    return content.split(\"\\n\").map(function(line) {\n      var match;\n      if (match = /^([ ]{4}|\\t)/.exec(line)) {\n        return line.slice(match[0].length);\n      } else {\n        return \"\";\n      }\n    }).join(\"\\n\");\n  };\n\n  compileTemplate = function(source, name) {\n    var program;\n    if (name == null) {\n      name = \"test\";\n    }\n    program = HAMLjr.compile(source, {\n      compiler: CoffeeScript\n    });\n    return \"module.exports = \" + program + \";\";\n  };\n\n  compileStyl = function(source) {\n    var styleContent;\n    styleContent = styl(source, {\n      whitespace: true\n    }).toString();\n    return \"module.exports = \" + (JSON.stringify(styleContent));\n  };\n\n  compileFile = function(_arg) {\n    var content, extension, name, path, result, _ref;\n    path = _arg.path, content = _arg.content;\n    _ref = [path.withoutExtension(), path.extension()], name = _ref[0], extension = _ref[1];\n    result = (function() {\n      switch (extension) {\n        case \"js\":\n          return {\n            code: content\n          };\n        case \"coffee\":\n          return {\n            code: CoffeeScript.compile(content)\n          };\n        case \"haml\":\n          return {\n            code: compileTemplate(content, name)\n          };\n        case \"styl\":\n          return {\n            code: compileStyl(content)\n          };\n        case \"md\":\n          return compileFile({\n            path: name,\n            content: stripMarkdown(content)\n          });\n        default:\n          return {};\n      }\n    })();\n    Object.defaults(result, {\n      name: name,\n      extension: extension\n    });\n    return Object.extend(result, {\n      path: path\n    });\n  };\n\n  documentFile = function(content, path) {\n    if (path.extension() === \"md\") {\n      return marked(content);\n    } else {\n      return \"\";\n    }\n  };\n\n  makeScript = function(attrs) {\n    return $(\"<script>\", attrs).prop('outerHTML');\n  };\n\n  dependencyScripts = function(build) {\n    var remoteDependencies;\n    remoteDependencies = readConfig(build).remoteDependencies;\n    return (remoteDependencies ? remoteDependencies.map(function(src) {\n      return makeScript({\n        \"class\": \"env\",\n        src: src\n      });\n    }) : $('script.env').map(function() {\n      return this.outerHTML;\n    }).get()).join(\"\\n\");\n  };\n\n  Builder = function() {\n    var build, postProcessors;\n    build = function(fileData) {\n      var data, errors, results, _ref;\n      results = fileData.map(function(_arg) {\n        var content, location, message, path;\n        path = _arg.path, content = _arg.content;\n        try {\n          return compileFile({\n            path: path,\n            content: content\n          });\n        } catch (_error) {\n          location = _error.location, message = _error.message;\n          if (location != null) {\n            message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n          }\n          return {\n            error: \"\" + path + \" - \" + message\n          };\n        }\n      });\n      _ref = results.partition(function(result) {\n        return result.error;\n      }), errors = _ref[0], data = _ref[1];\n      if (errors.length) {\n        return Deferred().reject(errors.map(function(e) {\n          return e.error;\n        }));\n      } else {\n        return Deferred().resolve(data);\n      }\n    };\n    postProcessors = [];\n    return {\n      addPostProcessor: function(fn) {\n        return postProcessors.push(fn);\n      },\n      buildDocs: function(fileData) {\n        return fileData.map(function(_arg) {\n          var content, location, message, path;\n          path = _arg.path, content = _arg.content;\n          try {\n            return {\n              path: path,\n              documentation: documentFile(content, path)\n            };\n          } catch (_error) {\n            location = _error.location, message = _error.message;\n            if (location != null) {\n              message = \"Error on line \" + (location.first_line + 1) + \": \" + message;\n            }\n            return {\n              error: \"\" + path + \" - \" + message\n            };\n          }\n        });\n      },\n      build: function(fileData) {\n        return build(fileData).then(function(items) {\n          var dependencies, results, source;\n          results = [];\n          items.eachWithObject(results, function(item, hash) {\n            if (item.code) {\n              return results.push(item);\n            } else {\n\n            }\n          });\n          results = results.map(function(item) {\n            return {\n              path: item.name,\n              content: item.code,\n              type: \"blob\"\n            };\n          });\n          source = arrayToHash(fileData);\n          dependencies = readConfig({\n            source: source\n          }).dependencies || {};\n          return packager.collectDependencies(dependencies).then(function(bundledDependencies) {\n            return postProcessors.pipeline({\n              source: source,\n              distribution: arrayToHash(results),\n              entryPoint: \"main\",\n              dependencies: bundledDependencies\n            });\n          });\n        });\n      },\n      program: function(build) {\n        var distribution, entryPoint, program;\n        distribution = build.distribution, entryPoint = build.entryPoint;\n        return program = distribution[entryPoint].content;\n      },\n      envDeclaration: function(build) {\n        return \"ENV = \" + (JSON.stringify(build, null, 2)) + \";\";\n      },\n      buildStyle: function(fileData) {\n        return this.build(fileData).then(function(build) {\n          var content, distribution, _ref;\n          distribution = build.distribution;\n          return content = ((_ref = distribution[\"style.css\"]) != null ? _ref.content : void 0) || \"\";\n        });\n      },\n      testScripts: function(fileData) {\n        var _this = this;\n        return this.build(fileData).then(function(build) {\n          var distribution, testProgram;\n          distribution = build.distribution;\n          testProgram = Object.keys(distribution).select(function(path) {\n            return path.match(/test\\//);\n          }).map(function(testPath) {\n            return \"require('./\" + testPath + \"')\";\n          }).join(\"\\n\");\n          return \"\" + (dependencyScripts(build)) + \"\\n<script>\\n  \" + (_this.envDeclaration(build)) + \"\\n  \" + testProgram + \"\\n<\\/script>\";\n        });\n      },\n      runnable: function(fileData) {\n        var _this = this;\n        return this.build(fileData).then(function(build) {\n          var standAlone;\n          standAlone = _this.standAlone(build);\n          standAlone.config = Builder.readConfig(build);\n          return standAlone;\n        });\n      },\n      standAlone: function(pkg) {\n        var content, distribution, entryPoint, program, source;\n        source = pkg.source, distribution = pkg.distribution;\n        content = [];\n        content.push(\"<!doctype html>\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\" />\");\n        content = content.concat(dependencyScripts(pkg));\n        program = this.program(pkg);\n        entryPoint = readConfig(pkg).entryPoint || \"main\";\n        content.push(\"</head>\\n<body>\\n\" + (makeScript({\n          html: this.envDeclaration(pkg)\n        })) + \"\\n\" + (makeScript({\n          html: \"require('./\" + entryPoint + \"')\"\n        })) + \"\\n</body>\\n</html>\");\n        return {\n          html: content.join(\"\\n\"),\n          script: program,\n          json: JSON.stringify(pkg, null, 2)\n        };\n      }\n    };\n  };\n\n  readConfig = function(build) {\n    var configData, _ref, _ref1;\n    if (configData = (_ref = build.source[\"pixie.cson\"]) != null ? _ref.content : void 0) {\n      return CSON.parse(configData);\n    } else if (configData = (_ref1 = build.source[\"pixie.json\"]) != null ? _ref1.content : void 0) {\n      return JSON.parse(configData);\n    } else {\n      return {};\n    }\n  };\n\n  Builder.readConfig = readConfig;\n\n  module.exports = Builder;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/deferred": {
      "path": "source/deferred",
      "content": "(function() {\n  var withDeferrence;\n\n  global.Deferred = $.Deferred;\n\n  withDeferrence = function(fn) {\n    var deferred, e;\n    deferred = Deferred();\n    try {\n      fn.defer(deferred);\n    } catch (_error) {\n      e = _error;\n      deferred.reject(e);\n    }\n    return deferred.promise();\n  };\n\n  Deferred.Confirm = function(message) {\n    return withDeferrence(function(deferred) {\n      if (window.confirm(message)) {\n        return deferred.resolve();\n      } else {\n        return deferred.reject();\n      }\n    });\n  };\n\n  Deferred.ConfirmIf = function(flag, message) {\n    if (flag) {\n      return Deferred.Confirm(message);\n    } else {\n      return withDeferrence(function(deferred) {\n        return deferred.resolve();\n      });\n    }\n  };\n\n  Deferred.ExecuteIf = function(flag, callback) {\n    return withDeferrence(function(deferred) {\n      if (flag) {\n        return callback().then(deferred.resolve);\n      } else {\n        return deferred.resolve();\n      }\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/duct_tape": {
      "path": "source/duct_tape",
      "content": "(function() {\n  String.prototype.dasherize = function() {\n    return this.trim().replace(/\\s+/g, \"-\").toLowerCase();\n  };\n\n  global.CSON = {\n    parse: function(source) {\n      return Function(\"return \" + (CoffeeScript.compile(source, {\n        bare: true\n      })))();\n    },\n    stringify: function(object) {\n      var representation;\n      representation = JSON.parse(JSON.stringify(obj));\n      return Object.keys(representation).map(function(key) {\n        var value;\n        value = representation[key];\n        return \"\" + key + \": \" + (JSON.stringify(value));\n      }).join(\"\\n\");\n    }\n  };\n\n  HAMLjr.render = function(templateName, object) {\n    var template, templates;\n    templates = HAMLjr.templates;\n    template = templates[templateName] || templates[\"templates/\" + templateName];\n    if (template) {\n      return template(object);\n    } else {\n      throw \"Could not find template named \" + templateName;\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/file": {
      "path": "source/file",
      "content": "(function() {\n  var File;\n\n  File = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    if (I.path == null) {\n      I.path = I.filename;\n    }\n    if (I.filename == null) {\n      I.filename = I.path.split(\"/\").last();\n    }\n    self = Model(I).observeAll();\n    self.extend({\n      extension: function() {\n        return self.filename().extension();\n      },\n      mode: function() {\n        var extension;\n        switch (extension = self.extension()) {\n          case \"js\":\n            return \"javascript\";\n          case \"md\":\n            return \"markdown\";\n          case \"cson\":\n            return \"coffee\";\n          case \"\":\n            return \"text\";\n          default:\n            return extension;\n        }\n      },\n      modified: Observable(false),\n      displayName: Observable(self.path())\n    });\n    self.content.observe(function() {\n      return self.modified(true);\n    });\n    self.modified.observe(function(modified) {\n      if (modified) {\n        return self.displayName(\"*\" + (self.path()));\n      } else {\n        return self.displayName(self.path());\n      }\n    });\n    return self;\n  };\n\n  module.exports = File;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/filetree": {
      "path": "source/filetree",
      "content": "(function() {\n  var File, Filetree;\n\n  File = require(\"./file\");\n\n  Filetree = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      files: []\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"selectedFile\");\n    self.extend({\n      load: function(fileData) {\n        var files;\n        if (Array.isArray(fileData)) {\n          files = fileData.sort(function(a, b) {\n            if (a.path < b.path) {\n              return -1;\n            } else if (b.path < a.path) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).map(File);\n        } else {\n          files = Object.keys(fileData).sort().map(function(path) {\n            return File(fileData[path]);\n          });\n        }\n        return self.files(files);\n      },\n      data: function() {\n        return self.files.map(function(file) {\n          return {\n            path: file.path(),\n            mode: \"100644\",\n            content: file.content(),\n            type: \"blob\"\n          };\n        });\n      },\n      hasUnsavedChanges: function() {\n        return self.files().select(function(file) {\n          return file.modified();\n        }).length;\n      },\n      markSaved: function() {\n        return self.files().each(function(file) {\n          return file.modified(false);\n        });\n      }\n    });\n    return self;\n  };\n\n  module.exports = Filetree;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/gistquire": {
      "path": "source/gistquire",
      "content": "(function() {\n  var Gistquire;\n\n  Gistquire = {\n    accessToken: null,\n    auth: function() {\n      var scope, url;\n      scope = \"gist,repo,user:email\";\n      url = \"https://github.com/login/oauth/authorize?client_id=bc46af967c926ba4ff87&scope=\" + scope;\n      return window.location = url;\n    },\n    onload: function() {\n      var code, _ref,\n        _this = this;\n      if (code = (_ref = window.location.href.match(/\\?code=(.*)/)) != null ? _ref[1] : void 0) {\n        $.getJSON(\"https://hamljr-auth.herokuapp.com/authenticate/\" + code, function(data) {\n          var token;\n          if (token = data.token) {\n            _this.accessToken = token;\n            return localStorage.authToken = token;\n          }\n        });\n      }\n      if (localStorage.authToken) {\n        return this.accessToken = localStorage.authToken;\n      }\n    },\n    api: function(path, options) {\n      var url;\n      if (options == null) {\n        options = {};\n      }\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"https://api.github.com/\" + path;\n      }\n      options.headers || (options.headers = {});\n      if (this.accessToken) {\n        options.headers[\"Authorization\"] = \"token \" + this.accessToken;\n      }\n      options = Object.extend({\n        url: url,\n        type: \"GET\",\n        dataType: 'json'\n      }, options);\n      return $.ajax(options);\n    }\n  };\n\n  module.exports = Gistquire;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/packager": {
      "path": "source/packager",
      "content": "(function() {\n  var Packager,\n    __slice = [].slice;\n\n  Packager = function() {\n    return {\n      collectDependencies: function(dependencies) {\n        var names;\n        names = Object.keys(dependencies);\n        return $.when.apply(null, names.map(function(name) {\n          var value;\n          value = dependencies[name];\n          if (typeof value === \"string\") {\n            return $.getJSON(value);\n          } else {\n            return Deferred().reject(\"Can only handle url string dependencies right now\");\n          }\n        })).then(function() {\n          var bundledDependencies, results;\n          results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          if (names.length === 1) {\n            results = [results];\n          }\n          bundledDependencies = {};\n          names.each(function(name, i) {\n            return bundledDependencies[name] = results[i][0];\n          });\n          return bundledDependencies;\n        });\n      }\n    };\n  };\n\n  module.exports = Packager;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/repository": {
      "path": "source/repository",
      "content": "(function() {\n  var Gistquire, Repository,\n    __slice = [].slice;\n\n  Gistquire = require(\"./gistquire\");\n\n  Repository = function(I) {\n    var api, get, patch, post, put, requestOptions, self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      branch: \"master\",\n      defaultBranch: \"master\"\n    });\n    self = Model(I).observeAll();\n    self.attrObservable(\"branch\");\n    requestOptions = function(type, data) {\n      return {\n        type: type,\n        data: JSON.stringify(data)\n      };\n    };\n    api = function(path, options) {\n      var url;\n      if (path.match(/^http/)) {\n        url = path;\n      } else {\n        url = \"\" + (self.url()) + \"/\" + path;\n      }\n      return Gistquire.api(url, options);\n    };\n    get = function(path, data) {\n      return api(path, {\n        data: data\n      });\n    };\n    put = function(path, data) {\n      return api(path, requestOptions(\"PUT\", data));\n    };\n    post = function(path, data) {\n      return api(path, requestOptions(\"POST\", data));\n    };\n    patch = function(path, data) {\n      return api(path, requestOptions(\"PATCH\", data));\n    };\n    self.extend({\n      pullRequests: function() {\n        return get(\"pulls\");\n      },\n      createPullRequest: function(_arg) {\n        var head, title;\n        title = _arg.title;\n        head = title.dasherize();\n        return self.switchToBranch(head).then(self.commitEmpty).then(function() {\n          return post(\"pulls\", {\n            base: I.defaultBranch,\n            head: head,\n            title: title\n          });\n        });\n      },\n      initPagesBranch: function() {\n        var branch;\n        branch = \"gh-pages\";\n        return post(\"git/trees\", {\n          tree: [\n            {\n              mode: \"1006444\",\n              path: \"tempest.txt\",\n              content: \"created by strd6.github.io/editor\"\n            }\n          ]\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            message: \"Initial gh-pages commit\",\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return post(\"git/refs\", {\n            ref: \"refs/heads/\" + branch,\n            sha: data.sha\n          });\n        });\n      },\n      writeFile: function(params) {\n        var branch, content, message, path;\n        branch = params.branch, path = params.path, content = params.content, message = params.message;\n        return get(\"contents/\" + path, {\n          ref: branch\n        }).then(function(data) {\n          return put(\"contents/\" + path, {\n            content: content,\n            sha: data.sha,\n            message: message,\n            branch: branch\n          });\n        }, function(request) {\n          var _ref, _ref1;\n          if (((_ref = request.responseJSON) != null ? _ref.message : void 0) === \"No commit found for the ref gh-pages\") {\n            return self.initPagesBranch().then(function() {\n              return self.writeFile(params);\n            });\n          } else if (request.status === 404) {\n            return put(\"contents/\" + path, {\n              content: content,\n              message: message,\n              branch: branch\n            });\n          } else {\n            return (_ref1 = Deferred()).reject.apply(_ref1, arguments);\n          }\n        });\n      },\n      latestTree: function(branch) {\n        if (branch == null) {\n          branch = self.branch();\n        }\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return get(\"\" + data.tree.url + \"?recursive=1\");\n        }).then(function(data) {\n          var files;\n          files = data.tree.select(function(file) {\n            return file.type === \"blob\";\n          });\n          return $.when.apply(null, files.map(function(datum) {\n            return get(datum.url).then(function(data) {\n              return Object.extend(datum, data);\n            });\n          }));\n        }).then(function() {\n          var results;\n          results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return results;\n        });\n      },\n      commitTree: function(_arg) {\n        var branch, latestCommitSha, message, tree;\n        message = _arg.message, tree = _arg.tree;\n        branch = self.branch();\n        if (message == null) {\n          message = \"Updated in browser at strd6.github.io/editor\";\n        }\n        if (!tree) {\n          throw Error(\"Must pass in a tree\");\n        }\n        latestCommitSha = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          latestCommitSha = data.object.sha;\n          return post(\"git/trees\", {\n            tree: tree\n          });\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [latestCommitSha],\n            message: message,\n            tree: data.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      commitEmpty: function() {\n        var branch, latestCommit;\n        branch = self.branch();\n        latestCommit = null;\n        return get(\"git/refs/heads/\" + branch).then(function(data) {\n          return get(data.object.url);\n        }).then(function(data) {\n          return post(\"git/commits\", {\n            parents: [data.sha],\n            message: \"This commit intentionally left blank\",\n            tree: data.tree.sha\n          });\n        }).then(function(data) {\n          return patch(\"git/refs/heads/\" + branch, {\n            sha: data.sha\n          });\n        });\n      },\n      switchToBranch: function(branch) {\n        var ref, setBranch;\n        ref = \"refs/heads/\" + branch;\n        setBranch = function(data) {\n          self.branch(branch);\n          return data;\n        };\n        return get(\"git/\" + ref).then(setBranch, function(request) {\n          var branchNotFound, _ref;\n          branchNotFound = request.status === 404;\n          if (branchNotFound) {\n            return get(\"git/refs/heads/\" + (self.branch())).then(function(data) {\n              return post(\"git/refs\", {\n                ref: ref,\n                sha: data.object.sha\n              });\n            }).then(setBranch);\n          } else {\n            return (_ref = Deferred()).reject.apply(_ref, arguments);\n          }\n        });\n      },\n      mergeInto: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: branch,\n          head: self.branch()\n        });\n      },\n      pullFromBranch: function(branch) {\n        if (branch == null) {\n          branch = self.defaultBranch();\n        }\n        return post(\"merges\", {\n          base: self.branch(),\n          head: branch\n        });\n      },\n      publish: function(_arg) {\n        var branch, html, json, message, path, publishBranch, script;\n        html = _arg.html, script = _arg.script, json = _arg.json;\n        branch = self.branch();\n        message = \"Built \" + branch + \" in browser in strd6.github.io/editor\";\n        if (branch === \"master\") {\n          path = \"index.html\";\n        } else {\n          path = \"\" + branch + \".html\";\n        }\n        publishBranch = \"gh-pages\";\n        return self.writeFile({\n          path: path,\n          content: Base64.encode(html),\n          branch: publishBranch,\n          message: message\n        }).then(function() {\n          return self.writeFile({\n            path: \"\" + branch + \".js\",\n            content: Base64.encode(script),\n            branch: publishBranch,\n            message: message\n          });\n        }).then(function() {\n          return self.writeFile({\n            path: \"\" + branch + \".json\",\n            content: Base64.encode(json),\n            branch: publishBranch,\n            message: message\n          });\n        });\n      }\n    });\n    return self;\n  };\n\n  module.exports = Repository;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/runner": {
      "path": "source/runner",
      "content": "(function() {\n  var Runner, runningWindows;\n\n  runningWindows = [];\n\n  Runner = {\n    run: function(_arg) {\n      var config, sandbox;\n      config = _arg.config;\n      sandbox = Sandbox({\n        width: config.width,\n        height: config.height\n      });\n      runningWindows.push(sandbox);\n      return sandbox;\n    },\n    hotReloadCSS: function(css, path) {\n      return runningWindows = runningWindows.partition(function(window) {\n        if (window.closed) {\n          return false;\n        }\n        $(window.document).find(\"body style:eq(0)\").html(css);\n        return true;\n      }).first();\n    }\n  };\n\n  module.exports = Runner;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/runtime": {
      "path": "source/runtime",
      "content": "(function() {\n  var Runtime;\n\n  Runtime = function(ENV) {\n    var currentNode, promo;\n    currentNode = function() {\n      var target;\n      target = document.documentElement;\n      while (target.childNodes.length && target.lastChild.nodeType === 1) {\n        target = target.lastChild;\n      }\n      return target.parentNode;\n    };\n    promo = function() {\n      return console.log(\"%c You should meet my creator \" + ENV.progenitor.url, \"background: #000; \\ncolor: white; \\nfont-size: 2em;\\nline-height: 2em;\\npadding: 40px 100px;\\nmargin-bottom: 1em;\\ntext-shadow: \\n  0 0 0.05em #fff, \\n  0 0 0.1em #fff, \\n  0 0 0.15em #fff, \\n  0 0 0.2em #ff00de, \\n  0 0 0.35em #ff00de, \\n  0 0 0.4em #ff00de, \\n  0 0 0.5em #ff00de, \\n  0 0 0.75em #ff00de;'\");\n    };\n    return {\n      boot: function() {\n        var root;\n        root = currentNode();\n        promo();\n        return root;\n      },\n      applyStyleSheet: function(root, name) {\n        var styleNode;\n        styleNode = document.createElement(\"style\");\n        styleNode.innerHTML = require(name);\n        styleNode.className = name;\n        return root.appendChild(styleNode);\n      }\n    };\n  };\n\n  module.exports = Runtime;\n\n}).call(this);\n",
      "type": "blob"
    },
    "source/text_editor": {
      "path": "source/text_editor",
      "content": "(function() {\n  var TextEditor;\n\n  TextEditor = function(I) {\n    var editor, el, reset, self, updating;\n    Object.reverseMerge(I, {\n      mode: \"coffee\",\n      text: \"\"\n    });\n    self = Model(I);\n    el = I.el;\n    delete I.el;\n    editor = ace.edit(el);\n    editor.setFontSize(\"16px\");\n    editor.setTheme(\"ace/theme/chrome\");\n    editor.getSession().setUseWorker(false);\n    editor.getSession().setMode(\"ace/mode/\" + I.mode);\n    editor.getSession().setUseSoftTabs(true);\n    editor.getSession().setTabSize(2);\n    reset = function(content) {\n      if (content == null) {\n        content = \"\";\n      }\n      editor.setValue(content);\n      editor.moveCursorTo(0, 0);\n      return editor.session.selection.clearSelection();\n    };\n    reset(I.text);\n    self.attrObservable(\"text\");\n    updating = false;\n    editor.getSession().on('change', function() {\n      updating = true;\n      self.text(editor.getValue());\n      return updating = false;\n    });\n    self.text.observe(function(newValue) {\n      if (!updating) {\n        return reset(newValue);\n      }\n    });\n    self.extend({\n      el: el,\n      editor: editor,\n      reset: reset\n    });\n    return self;\n  };\n\n  module.exports = TextEditor;\n\n}).call(this);\n",
      "type": "blob"
    },
    "style": {
      "path": "style",
      "content": "module.exports = \"html,\\nbody {\\n  margin: 0;\\n  height: 100%;\\n}\\n\\n.main {\\n  position: relative;\\n  padding-top: 40px;\\n  padding-left: 200px;\\n  padding-bottom: 100px;\\n  height: 100%;\\n  -ms-box-sizing: border-box;\\n  -moz-box-sizing: border-box;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n}\\n\\n.editor-wrap {\\n  background-color: white;\\n  width: 100%;\\n  height: 100%;\\n  position: relative;\\n}\\n\\n.editor-wrap > div {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n}\\n\\n.filetree {\\n  margin: 0;\\n  padding: 0;\\n  width: 200px;\\n  position: absolute;\\n  left: 0;\\n  top: 40px;\\n  z-index: 2;\\n}\\n\\n.filetree li .delete {\\n  display: none;\\n  position: absolute;\\n  right: 0;\\n  top: 0;\\n}\\n\\n.filetree li:hover .delete {\\n  display: inline-block;\\n}\\n\\n.filetree li:hover {\\n  background-color: lightyellow;\\n}\\n\\n.filetree li {\\n  list-style-type: none;\\n  padding-left: 1em;\\n  position: relative;\\n  whitespace: nowrap;\\n}\\n\\n.actions {\\n  position: absolute;\\n  top: 0;\\n  left: 200px;\\n}\\n\\n.console-wrap {\\n  position: absolute;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n  padding-left: 200px;\\n  height: 100px;\\n  width: 100%;\\n  margin: 0;\\n  -ms-box-sizing: border-box;\\n  -moz-box-sizing: border-box;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n}\\n\\n.console-wrap .errors {\\n  border-top: 1px solid black;\\n  color: red;\\n  -ms-box-sizing: border-box;\\n  -moz-box-sizing: border-box;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n}\\n\\n.status {\\n  top: 0;\\n  right: 0;\\n  position: absolute;\\n}\"",
      "type": "blob"
    },
    "templates/actions": {
      "path": "templates/actions",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var actions, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"div\");\n    __push(__element);\n    __attribute(__element, \"class\", \"actions\");\n    actions = this.actions;\n    Object.keys(actions).each(function(name) {\n      __element = document.createElement(\"button\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, name.titleize());\n      __push(__element);\n      __pop();\n      __on(\"click\", function() {\n        return actions[name]();\n      });\n      return __pop();\n    });\n    __element = document.createTextNode('');\n    __text(__element, HAMLjr.render(\"issues\", this.issues));\n    __push(__element);\n    __pop();\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "templates/editor": {
      "path": "templates/editor",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"div\");\n    __push(__element);\n    __attribute(__element, \"class\", \"main\");\n    __element = document.createTextNode('');\n    __text(__element, HAMLjr.render(\"actions\", {\n      actions: this.actions,\n      issues: this.issues\n    }));\n    __push(__element);\n    __pop();\n    __element = document.createTextNode('');\n    __text(__element, HAMLjr.render(\"filetree\", this.filetree));\n    __push(__element);\n    __pop();\n    __element = document.createTextNode('');\n    __text(__element, HAMLjr.render(\"notices\", this));\n    __push(__element);\n    __pop();\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "templates/filetree": {
      "path": "templates/filetree",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var files, selectedFile, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"ul\");\n    __push(__element);\n    __attribute(__element, \"class\", \"filetree\");\n    selectedFile = this.selectedFile;\n    files = this.files;\n    __each(files, function(file) {\n      __element = document.createElement(\"li\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, file.displayName);\n      __push(__element);\n      __pop();\n      __on(\"click\", function(e) {\n        if ($(e.target).is('li')) {\n          return selectedFile(file);\n        }\n      });\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"delete\");\n      __on(\"click\", function() {\n        if (confirm(\"Delete \" + (file.path()) + \"?\")) {\n          return files.remove(file);\n        }\n      });\n      __element = document.createTextNode('');\n      __text(__element, \"X\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      return __pop();\n    });\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "templates/github_status": {
      "path": "templates/github_status",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"div\");\n    __push(__element);\n    __attribute(__element, \"class\", \"status\");\n    if (this.request && this.request.getAllResponseHeaders().match(/X-RateLimit-Limit: 5000/)) {\n      __element = document.createTextNode('');\n      __text(__element, \"Authenticated Scopes:\\n\");\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, this.request.getResponseHeader(\"X-OAuth-Scopes\"));\n      __push(__element);\n      __pop();\n      __element = document.createElement(\"br\");\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, \"Rate Limit Remaining:\\n\");\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, this.request.getResponseHeader(\"X-RateLimit-Remaining\"));\n      __push(__element);\n      __pop();\n      __element = document.createTextNode('');\n      __text(__element, \" / 5000\");\n      __push(__element);\n      __pop();\n    } else {\n      __element = document.createElement(\"button\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Auth\\n\");\n      __push(__element);\n      __pop();\n      __on(\"click\", Gistquire.auth);\n      __pop();\n    }\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "templates/notices": {
      "path": "templates/notices",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"div\");\n    __push(__element);\n    __attribute(__element, \"class\", \"console-wrap\");\n    __element = document.createElement(\"pre\");\n    __push(__element);\n    __attribute(__element, \"class\", \"errors\");\n    __each(this.errors, function(error) {\n      __element = document.createTextNode('');\n      __text(__element, error);\n      __push(__element);\n      return __pop();\n    });\n    __pop();\n    __element = document.createElement(\"pre\");\n    __push(__element);\n    __attribute(__element, \"class\", \"notices\");\n    __each(this.notices, function(notice) {\n      __element = document.createTextNode('');\n      __text(__element, notice);\n      __push(__element);\n      return __pop();\n    });\n    __pop();\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "templates/text_editor": {
      "path": "templates/text_editor",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"div\");\n    __push(__element);\n    __attribute(__element, \"class\", \"editor-wrap\");\n    __element = document.createElement(\"div\");\n    __push(__element);\n    __attribute(__element, \"class\", \"editor\");\n    __pop();\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "test/another_test": {
      "path": "test/another_test",
      "content": "(function() {\n  describe(\"editor\", function() {\n    return it(\"should run both files\", function() {\n      return assert(true);\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "test/test": {
      "path": "test/test",
      "content": "(function() {\n  describe(\"editor\", function() {\n    return it(\"should test things\", function() {\n      return assert(true);\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    }
  },
  "entryPoint": "main",
  "dependencies": {
    "issues": {
      "source": {
        "README.md": {
          "path": "README.md",
          "mode": "100644",
          "content": "issues\n======\n\nGithub's got issues\n\nGoal\n----\n\nCurrently just provides a dropdown list for choosing an issue from.\n\nMay later expand to forms to create/show/comment on issues for a project.\n",
          "type": "blob"
        },
        "main.coffee.md": {
          "path": "main.coffee.md",
          "mode": "100644",
          "content": "Our main entry point which exports all of our Issue models and templates.\n\n    module.exports =\n      models:\n        Issue: require(\"./source/issue\")\n        Issues: require(\"./source/issues\")\n      templates:\n        issues: require(\"./templates/issues\")\n",
          "type": "blob"
        },
        "source/issue.coffee.md": {
          "path": "source/issue.coffee.md",
          "mode": "100644",
          "content": "A tempest model that wraps issues from github.\n\n    Issue = (I={}) ->\n      self = Model(I)\n    \n      self.extend\n\nThe option text is what appears in the dropdown menu.\n\n        optionText: ->\n          \"#{I.title}\"\n\n        fullDescription: ->\n          \"\"\"\n            #{self.optionText()}\n            #{I.html_url}\n            #{I.body}\n          \"\"\"\n\nA helper method to get a standard branch name for an issue. Pull requests have\ntheir own branches, but an issue branch is generated based on issue number.\n\n        branchName: ->\n          I.head?.ref or \"issue-#{I.number}\"\n    \n      return self\n\n    module.exports = Issue\n",
          "type": "blob"
        },
        "source/issues.coffee.md": {
          "path": "source/issues.coffee.md",
          "mode": "100644",
          "content": "    Issue = require \"./issue\"\n\nA collection of issues including a `currentIssue` to represent the actively\nselected issue.\n\nWe may want to formalize this collection pattern later, but for now lets just\nsee how it goes.\n\n    Issues = (I={}) ->\n      Object.defaults I,\n        issues: []\n\n      self = Model(I)\n\nOur `issues` method is a list of `Issue` models.\n\n      self.attrModels \"issues\", Issue\n\nWe want to expose the currently selected issue as an observable as well.\n\n      self.attrObservable \"currentIssue\"\n\n      self.extend\n\nThe reset method accepts an array of raw issue data, converts it into an array\nof issue objects, replaces the previous issues with the new ones and clears the \nselected issue.\n\n        reset: (issueData) ->\n          self.currentIssue(undefined)\n          self.issues issueData.map(Issue)\n    \n      return self\n\n    module.exports = Issues\n",
          "type": "blob"
        },
        "templates/issues.haml.md": {
          "path": "templates/issues.haml.md",
          "mode": "100644",
          "content": "A simple select element to allow choosing of issues.\n\n    %select\n      - on \"change\", @currentIssue\n      %option= \"- Default Branch -\"\n      - each @issues, ->\n        %option= @optionText()\n",
          "type": "blob"
        }
      },
      "distribution": {
        "main": {
          "path": "main",
          "content": "(function() {\n  module.exports = {\n    models: {\n      Issue: require(\"./source/issue\"),\n      Issues: require(\"./source/issues\")\n    },\n    templates: {\n      issues: require(\"./templates/issues\")\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "source/issue": {
          "path": "source/issue",
          "content": "(function() {\n  var Issue;\n\n  Issue = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    self = Model(I);\n    self.extend({\n      optionText: function() {\n        return \"\" + I.title;\n      },\n      fullDescription: function() {\n        return \"\" + (self.optionText()) + \"\\n\" + I.html_url + \"\\n\" + I.body;\n      },\n      branchName: function() {\n        var _ref;\n        return ((_ref = I.head) != null ? _ref.ref : void 0) || (\"issue-\" + I.number);\n      }\n    });\n    return self;\n  };\n\n  module.exports = Issue;\n\n}).call(this);\n",
          "type": "blob"
        },
        "source/issues": {
          "path": "source/issues",
          "content": "(function() {\n  var Issue, Issues;\n\n  Issue = require(\"./issue\");\n\n  Issues = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      issues: []\n    });\n    self = Model(I);\n    self.attrModels(\"issues\", Issue);\n    self.attrObservable(\"currentIssue\");\n    self.extend({\n      reset: function(issueData) {\n        self.currentIssue(void 0);\n        return self.issues(issueData.map(Issue));\n      }\n    });\n    return self;\n  };\n\n  module.exports = Issues;\n\n}).call(this);\n",
          "type": "blob"
        },
        "templates/issues": {
          "path": "templates/issues",
          "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"select\");\n    __push(__element);\n    __on(\"change\", this.currentIssue);\n    __element = document.createElement(\"option\");\n    __push(__element);\n    __element = document.createTextNode('');\n    __text(__element, \"- Default Branch -\");\n    __push(__element);\n    __pop();\n    __pop();\n    __each(this.issues, function() {\n      __element = document.createElement(\"option\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, this.optionText());\n      __push(__element);\n      __pop();\n      return __pop();\n    });\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
          "type": "blob"
        }
      },
      "entryPoint": "main",
      "dependencies": {},
      "repository": {
        "full_name": "STRd6/issues",
        "branch": "master"
      },
      "progenitor": {
        "url": "http://strd6.github.io/editor/"
      }
    },
    "test_runner": {
      "source": {
        "README.md": {
          "path": "README.md",
          "mode": "100644",
          "content": "tests\n=====\n\nProvide tests to online editor\n",
          "type": "blob"
        },
        "TODO": {
          "path": "TODO",
          "mode": "100644",
          "content": "Investigate Leak Checking\n",
          "type": "blob"
        },
        "main.coffee.md": {
          "path": "main.coffee.md",
          "mode": "100644",
          "content": "\n    module.exports = \n\nGenerate an html template that runs the given script tag strings as tests.\n      \n      html: (testScripts) -> \"\"\"\n        <html>\n        <head>\n          <meta charset=\"utf-8\">\n          <title>Mocha Tests</title>\n          <link rel=\"stylesheet\" href=\"http://strd6.github.io/tests/mocha.css\" />\n        </head>\n        <body>\n          <div id=\"mocha\"></div>\n          <script src=\"http://strd6.github.io/tests/assert.js\"><\\/script>\n          <script src=\"http://strd6.github.io/tests/mocha.js\"><\\/script>\n          <script>mocha.setup('bdd')<\\/script>\n          #{testScripts}\n          <script>\n            mocha.checkLeaks();\n            mocha.globals(['jQuery']);\n            mocha.run();\n          <\\/script>\n        </body>\n        </html>\n      \"\"\"\n",
          "type": "blob"
        }
      },
      "distribution": {
        "main": {
          "path": "main",
          "content": "(function() {\n  module.exports = {\n    html: function(testScripts) {\n      return \"<html>\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n  <title>Mocha Tests</title>\\n  <link rel=\\\"stylesheet\\\" href=\\\"http://strd6.github.io/tests/mocha.css\\\" />\\n</head>\\n<body>\\n  <div id=\\\"mocha\\\"></div>\\n  <script src=\\\"http://strd6.github.io/tests/assert.js\\\"><\\/script>\\n  <script src=\\\"http://strd6.github.io/tests/mocha.js\\\"><\\/script>\\n  <script>mocha.setup('bdd')<\\/script>\\n  \" + testScripts + \"\\n  <script>\\n    mocha.checkLeaks();\\n    mocha.globals(['jQuery']);\\n    mocha.run();\\n  <\\/script>\\n</body>\\n</html>\";\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "entryPoint": "main",
      "dependencies": {},
      "repository": {
        "full_name": "STRd6/tests",
        "branch": "master"
      },
      "progenitor": {
        "url": "http://strd6.github.io/editor/"
      }
    }
  },
  "repository": {
    "full_name": "STRd6/editor",
    "branch": "master"
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  }
}